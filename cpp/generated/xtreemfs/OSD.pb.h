// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/OSD.proto

#ifndef PROTOBUF_xtreemfs_2fOSD_2eproto__INCLUDED
#define PROTOBUF_xtreemfs_2fOSD_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "include/PBRPC.pb.h"
#include "include/Common.pb.h"
#include "xtreemfs/GlobalTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

class InternalGmax;
class Lock;
class ObjectData;
class ObjectList;
class ObjectVersion;
class TruncateRecord;
class TruncateLog;
class XLocSetVersionState;
class ReplicaStatus;
class ObjectVersionMapping;
class AuthoritativeReplicaState;
class InternalReadLocalResponse;
class readRequest;
class truncateRequest;
class unlink_osd_Request;
class writeRequest;
class xtreemfs_broadcast_gmaxRequest;
class xtreemfs_check_objectRequest;
class xtreemfs_cleanup_get_resultsResponse;
class xtreemfs_cleanup_is_runningResponse;
class xtreemfs_cleanup_startRequest;
class xtreemfs_cleanup_statusResponse;
class xtreemfs_finalize_vouchersRequest;
class xtreemfs_rwr_fetchRequest;
class xtreemfs_repair_objectRequest;
class xtreemfs_rwr_flease_msgRequest;
class xtreemfs_rwr_set_primary_epochRequest;
class xtreemfs_rwr_statusRequest;
class xtreemfs_rwr_truncateRequest;
class xtreemfs_rwr_updateRequest;
class xtreemfs_internal_get_gmaxRequest;
class xtreemfs_internal_get_file_sizeRequest;
class xtreemfs_internal_get_file_sizeResponse;
class xtreemfs_internal_read_localRequest;
class xtreemfs_internal_get_object_setRequest;
class xtreemfs_internal_get_fileid_listResponse;
class lockRequest;
class xtreemfs_pingMesssage;
class xtreemfs_rwr_auth_stateRequest;
class xtreemfs_rwr_reset_completeRequest;
class xtreemfs_xloc_set_invalidateRequest;
class xtreemfs_xloc_set_invalidateResponse;
class xtreemfs_rwr_reset_statusRequest;
class xtreemfs_rwr_reset_statusResponse;

enum OSDHealthResult {
  OSD_HEALTH_RESULT_PASSED = 0,
  OSD_HEALTH_RESULT_WARNING = 1,
  OSD_HEALTH_RESULT_FAILED = 2,
  OSD_HEALTH_RESULT_NOT_AVAIL = 3
};
bool OSDHealthResult_IsValid(int value);
const OSDHealthResult OSDHealthResult_MIN = OSD_HEALTH_RESULT_PASSED;
const OSDHealthResult OSDHealthResult_MAX = OSD_HEALTH_RESULT_NOT_AVAIL;
const int OSDHealthResult_ARRAYSIZE = OSDHealthResult_MAX + 1;

const ::google::protobuf::EnumDescriptor* OSDHealthResult_descriptor();
inline const ::std::string& OSDHealthResult_Name(OSDHealthResult value) {
  return ::google::protobuf::internal::NameOfEnum(
    OSDHealthResult_descriptor(), value);
}
inline bool OSDHealthResult_Parse(
    const ::std::string& name, OSDHealthResult* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OSDHealthResult>(
    OSDHealthResult_descriptor(), name, value);
}
// ===================================================================

class InternalGmax : public ::google::protobuf::Message {
 public:
  InternalGmax();
  virtual ~InternalGmax();

  InternalGmax(const InternalGmax& from);

  inline InternalGmax& operator=(const InternalGmax& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalGmax& default_instance();

  void Swap(InternalGmax* other);

  // implements Message ----------------------------------------------

  InternalGmax* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalGmax& from);
  void MergeFrom(const InternalGmax& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 epoch = 1;
  inline bool has_epoch() const;
  inline void clear_epoch();
  static const int kEpochFieldNumber = 1;
  inline ::google::protobuf::uint64 epoch() const;
  inline void set_epoch(::google::protobuf::uint64 value);

  // required fixed64 file_size = 2;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 2;
  inline ::google::protobuf::uint64 file_size() const;
  inline void set_file_size(::google::protobuf::uint64 value);

  // required fixed64 last_object_id = 3;
  inline bool has_last_object_id() const;
  inline void clear_last_object_id();
  static const int kLastObjectIdFieldNumber = 3;
  inline ::google::protobuf::uint64 last_object_id() const;
  inline void set_last_object_id(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.InternalGmax)
 private:
  inline void set_has_epoch();
  inline void clear_has_epoch();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_last_object_id();
  inline void clear_has_last_object_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 epoch_;
  ::google::protobuf::uint64 file_size_;
  ::google::protobuf::uint64 last_object_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static InternalGmax* default_instance_;
};
// -------------------------------------------------------------------

class Lock : public ::google::protobuf::Message {
 public:
  Lock();
  virtual ~Lock();

  Lock(const Lock& from);

  inline Lock& operator=(const Lock& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Lock& default_instance();

  void Swap(Lock* other);

  // implements Message ----------------------------------------------

  Lock* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Lock& from);
  void MergeFrom(const Lock& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 client_pid = 1;
  inline bool has_client_pid() const;
  inline void clear_client_pid();
  static const int kClientPidFieldNumber = 1;
  inline ::google::protobuf::uint32 client_pid() const;
  inline void set_client_pid(::google::protobuf::uint32 value);

  // required string client_uuid = 2;
  inline bool has_client_uuid() const;
  inline void clear_client_uuid();
  static const int kClientUuidFieldNumber = 2;
  inline const ::std::string& client_uuid() const;
  inline void set_client_uuid(const ::std::string& value);
  inline void set_client_uuid(const char* value);
  inline void set_client_uuid(const char* value, size_t size);
  inline ::std::string* mutable_client_uuid();
  inline ::std::string* release_client_uuid();
  inline void set_allocated_client_uuid(::std::string* client_uuid);

  // required fixed64 length = 3;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 3;
  inline ::google::protobuf::uint64 length() const;
  inline void set_length(::google::protobuf::uint64 value);

  // required fixed64 offset = 4;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 4;
  inline ::google::protobuf::uint64 offset() const;
  inline void set_offset(::google::protobuf::uint64 value);

  // required bool exclusive = 5;
  inline bool has_exclusive() const;
  inline void clear_exclusive();
  static const int kExclusiveFieldNumber = 5;
  inline bool exclusive() const;
  inline void set_exclusive(bool value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Lock)
 private:
  inline void set_has_client_pid();
  inline void clear_has_client_pid();
  inline void set_has_client_uuid();
  inline void clear_has_client_uuid();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_exclusive();
  inline void clear_has_exclusive();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* client_uuid_;
  ::google::protobuf::uint64 length_;
  ::google::protobuf::uint32 client_pid_;
  bool exclusive_;
  ::google::protobuf::uint64 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static Lock* default_instance_;
};
// -------------------------------------------------------------------

class ObjectData : public ::google::protobuf::Message {
 public:
  ObjectData();
  virtual ~ObjectData();

  ObjectData(const ObjectData& from);

  inline ObjectData& operator=(const ObjectData& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectData& default_instance();

  void Swap(ObjectData* other);

  // implements Message ----------------------------------------------

  ObjectData* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectData& from);
  void MergeFrom(const ObjectData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 checksum = 1;
  inline bool has_checksum() const;
  inline void clear_checksum();
  static const int kChecksumFieldNumber = 1;
  inline ::google::protobuf::uint32 checksum() const;
  inline void set_checksum(::google::protobuf::uint32 value);

  // required bool invalid_checksum_on_osd = 2;
  inline bool has_invalid_checksum_on_osd() const;
  inline void clear_invalid_checksum_on_osd();
  static const int kInvalidChecksumOnOsdFieldNumber = 2;
  inline bool invalid_checksum_on_osd() const;
  inline void set_invalid_checksum_on_osd(bool value);

  // required fixed32 zero_padding = 3;
  inline bool has_zero_padding() const;
  inline void clear_zero_padding();
  static const int kZeroPaddingFieldNumber = 3;
  inline ::google::protobuf::uint32 zero_padding() const;
  inline void set_zero_padding(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.ObjectData)
 private:
  inline void set_has_checksum();
  inline void clear_has_checksum();
  inline void set_has_invalid_checksum_on_osd();
  inline void clear_has_invalid_checksum_on_osd();
  inline void set_has_zero_padding();
  inline void clear_has_zero_padding();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 checksum_;
  bool invalid_checksum_on_osd_;
  ::google::protobuf::uint32 zero_padding_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static ObjectData* default_instance_;
};
// -------------------------------------------------------------------

class ObjectList : public ::google::protobuf::Message {
 public:
  ObjectList();
  virtual ~ObjectList();

  ObjectList(const ObjectList& from);

  inline ObjectList& operator=(const ObjectList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectList& default_instance();

  void Swap(ObjectList* other);

  // implements Message ----------------------------------------------

  ObjectList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectList& from);
  void MergeFrom(const ObjectList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes set = 1;
  inline bool has_set() const;
  inline void clear_set();
  static const int kSetFieldNumber = 1;
  inline const ::std::string& set() const;
  inline void set_set(const ::std::string& value);
  inline void set_set(const char* value);
  inline void set_set(const void* value, size_t size);
  inline ::std::string* mutable_set();
  inline ::std::string* release_set();
  inline void set_allocated_set(::std::string* set);

  // required fixed32 stripe_width = 2;
  inline bool has_stripe_width() const;
  inline void clear_stripe_width();
  static const int kStripeWidthFieldNumber = 2;
  inline ::google::protobuf::uint32 stripe_width() const;
  inline void set_stripe_width(::google::protobuf::uint32 value);

  // required fixed32 first_ = 3;
  inline bool has_first_() const;
  inline void clear_first_();
  static const int kFirstFieldNumber = 3;
  inline ::google::protobuf::uint32 first_() const;
  inline void set_first_(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.ObjectList)
 private:
  inline void set_has_set();
  inline void clear_has_set();
  inline void set_has_stripe_width();
  inline void clear_has_stripe_width();
  inline void set_has_first_();
  inline void clear_has_first_();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* set_;
  ::google::protobuf::uint32 stripe_width_;
  ::google::protobuf::uint32 first__;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static ObjectList* default_instance_;
};
// -------------------------------------------------------------------

class ObjectVersion : public ::google::protobuf::Message {
 public:
  ObjectVersion();
  virtual ~ObjectVersion();

  ObjectVersion(const ObjectVersion& from);

  inline ObjectVersion& operator=(const ObjectVersion& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectVersion& default_instance();

  void Swap(ObjectVersion* other);

  // implements Message ----------------------------------------------

  ObjectVersion* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectVersion& from);
  void MergeFrom(const ObjectVersion& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 object_number = 1;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 1;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 2;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.ObjectVersion)
 private:
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static ObjectVersion* default_instance_;
};
// -------------------------------------------------------------------

class TruncateRecord : public ::google::protobuf::Message {
 public:
  TruncateRecord();
  virtual ~TruncateRecord();

  TruncateRecord(const TruncateRecord& from);

  inline TruncateRecord& operator=(const TruncateRecord& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateRecord& default_instance();

  void Swap(TruncateRecord* other);

  // implements Message ----------------------------------------------

  TruncateRecord* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TruncateRecord& from);
  void MergeFrom(const TruncateRecord& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint64 version() const;
  inline void set_version(::google::protobuf::uint64 value);

  // required fixed64 last_object_number = 2;
  inline bool has_last_object_number() const;
  inline void clear_last_object_number();
  static const int kLastObjectNumberFieldNumber = 2;
  inline ::google::protobuf::uint64 last_object_number() const;
  inline void set_last_object_number(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.TruncateRecord)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_last_object_number();
  inline void clear_has_last_object_number();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 version_;
  ::google::protobuf::uint64 last_object_number_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static TruncateRecord* default_instance_;
};
// -------------------------------------------------------------------

class TruncateLog : public ::google::protobuf::Message {
 public:
  TruncateLog();
  virtual ~TruncateLog();

  TruncateLog(const TruncateLog& from);

  inline TruncateLog& operator=(const TruncateLog& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TruncateLog& default_instance();

  void Swap(TruncateLog* other);

  // implements Message ----------------------------------------------

  TruncateLog* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TruncateLog& from);
  void MergeFrom(const TruncateLog& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.TruncateRecord records = 1;
  inline int records_size() const;
  inline void clear_records();
  static const int kRecordsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::TruncateRecord& records(int index) const;
  inline ::xtreemfs::pbrpc::TruncateRecord* mutable_records(int index);
  inline ::xtreemfs::pbrpc::TruncateRecord* add_records();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::TruncateRecord >&
      records() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::TruncateRecord >*
      mutable_records();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.TruncateLog)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::TruncateRecord > records_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static TruncateLog* default_instance_;
};
// -------------------------------------------------------------------

class XLocSetVersionState : public ::google::protobuf::Message {
 public:
  XLocSetVersionState();
  virtual ~XLocSetVersionState();

  XLocSetVersionState(const XLocSetVersionState& from);

  inline XLocSetVersionState& operator=(const XLocSetVersionState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XLocSetVersionState& default_instance();

  void Swap(XLocSetVersionState* other);

  // implements Message ----------------------------------------------

  XLocSetVersionState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XLocSetVersionState& from);
  void MergeFrom(const XLocSetVersionState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required bool invalidated = 2;
  inline bool has_invalidated() const;
  inline void clear_invalidated();
  static const int kInvalidatedFieldNumber = 2;
  inline bool invalidated() const;
  inline void set_invalidated(bool value);

  // optional fixed64 modified_time = 3;
  inline bool has_modified_time() const;
  inline void clear_modified_time();
  static const int kModifiedTimeFieldNumber = 3;
  inline ::google::protobuf::uint64 modified_time() const;
  inline void set_modified_time(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.XLocSetVersionState)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_invalidated();
  inline void clear_has_invalidated();
  inline void set_has_modified_time();
  inline void clear_has_modified_time();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 version_;
  bool invalidated_;
  ::google::protobuf::uint64 modified_time_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static XLocSetVersionState* default_instance_;
};
// -------------------------------------------------------------------

class ReplicaStatus : public ::google::protobuf::Message {
 public:
  ReplicaStatus();
  virtual ~ReplicaStatus();

  ReplicaStatus(const ReplicaStatus& from);

  inline ReplicaStatus& operator=(const ReplicaStatus& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ReplicaStatus& default_instance();

  void Swap(ReplicaStatus* other);

  // implements Message ----------------------------------------------

  ReplicaStatus* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ReplicaStatus& from);
  void MergeFrom(const ReplicaStatus& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 truncate_epoch = 1;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 1;
  inline ::google::protobuf::uint64 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint64 value);

  // required fixed64 file_size = 2;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 2;
  inline ::google::protobuf::uint64 file_size() const;
  inline void set_file_size(::google::protobuf::uint64 value);

  // required fixed64 max_obj_version = 3;
  inline bool has_max_obj_version() const;
  inline void clear_max_obj_version();
  static const int kMaxObjVersionFieldNumber = 3;
  inline ::google::protobuf::uint64 max_obj_version() const;
  inline void set_max_obj_version(::google::protobuf::uint64 value);

  // required fixed32 primary_epoch = 4;
  inline bool has_primary_epoch() const;
  inline void clear_primary_epoch();
  static const int kPrimaryEpochFieldNumber = 4;
  inline ::google::protobuf::uint32 primary_epoch() const;
  inline void set_primary_epoch(::google::protobuf::uint32 value);

  // repeated .xtreemfs.pbrpc.ObjectVersion objectVersions = 5;
  inline int objectversions_size() const;
  inline void clear_objectversions();
  static const int kObjectVersionsFieldNumber = 5;
  inline const ::xtreemfs::pbrpc::ObjectVersion& objectversions(int index) const;
  inline ::xtreemfs::pbrpc::ObjectVersion* mutable_objectversions(int index);
  inline ::xtreemfs::pbrpc::ObjectVersion* add_objectversions();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersion >&
      objectversions() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersion >*
      mutable_objectversions();

  // required .xtreemfs.pbrpc.TruncateLog truncate_log = 6;
  inline bool has_truncate_log() const;
  inline void clear_truncate_log();
  static const int kTruncateLogFieldNumber = 6;
  inline const ::xtreemfs::pbrpc::TruncateLog& truncate_log() const;
  inline ::xtreemfs::pbrpc::TruncateLog* mutable_truncate_log();
  inline ::xtreemfs::pbrpc::TruncateLog* release_truncate_log();
  inline void set_allocated_truncate_log(::xtreemfs::pbrpc::TruncateLog* truncate_log);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.ReplicaStatus)
 private:
  inline void set_has_truncate_epoch();
  inline void clear_has_truncate_epoch();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_max_obj_version();
  inline void clear_has_max_obj_version();
  inline void set_has_primary_epoch();
  inline void clear_has_primary_epoch();
  inline void set_has_truncate_log();
  inline void clear_has_truncate_log();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 truncate_epoch_;
  ::google::protobuf::uint64 file_size_;
  ::google::protobuf::uint64 max_obj_version_;
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersion > objectversions_;
  ::xtreemfs::pbrpc::TruncateLog* truncate_log_;
  ::google::protobuf::uint32 primary_epoch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static ReplicaStatus* default_instance_;
};
// -------------------------------------------------------------------

class ObjectVersionMapping : public ::google::protobuf::Message {
 public:
  ObjectVersionMapping();
  virtual ~ObjectVersionMapping();

  ObjectVersionMapping(const ObjectVersionMapping& from);

  inline ObjectVersionMapping& operator=(const ObjectVersionMapping& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ObjectVersionMapping& default_instance();

  void Swap(ObjectVersionMapping* other);

  // implements Message ----------------------------------------------

  ObjectVersionMapping* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const ObjectVersionMapping& from);
  void MergeFrom(const ObjectVersionMapping& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 object_number = 1;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 1;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 2;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 2;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // repeated string osd_uuids = 3;
  inline int osd_uuids_size() const;
  inline void clear_osd_uuids();
  static const int kOsdUuidsFieldNumber = 3;
  inline const ::std::string& osd_uuids(int index) const;
  inline ::std::string* mutable_osd_uuids(int index);
  inline void set_osd_uuids(int index, const ::std::string& value);
  inline void set_osd_uuids(int index, const char* value);
  inline void set_osd_uuids(int index, const char* value, size_t size);
  inline ::std::string* add_osd_uuids();
  inline void add_osd_uuids(const ::std::string& value);
  inline void add_osd_uuids(const char* value);
  inline void add_osd_uuids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& osd_uuids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_osd_uuids();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.ObjectVersionMapping)
 private:
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;
  ::google::protobuf::RepeatedPtrField< ::std::string> osd_uuids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static ObjectVersionMapping* default_instance_;
};
// -------------------------------------------------------------------

class AuthoritativeReplicaState : public ::google::protobuf::Message {
 public:
  AuthoritativeReplicaState();
  virtual ~AuthoritativeReplicaState();

  AuthoritativeReplicaState(const AuthoritativeReplicaState& from);

  inline AuthoritativeReplicaState& operator=(const AuthoritativeReplicaState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthoritativeReplicaState& default_instance();

  void Swap(AuthoritativeReplicaState* other);

  // implements Message ----------------------------------------------

  AuthoritativeReplicaState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthoritativeReplicaState& from);
  void MergeFrom(const AuthoritativeReplicaState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 truncate_epoch = 1;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 1;
  inline ::google::protobuf::uint64 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint64 value);

  // required fixed64 max_obj_version = 4;
  inline bool has_max_obj_version() const;
  inline void clear_max_obj_version();
  static const int kMaxObjVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 max_obj_version() const;
  inline void set_max_obj_version(::google::protobuf::uint64 value);

  // repeated .xtreemfs.pbrpc.ObjectVersionMapping objectVersions = 2;
  inline int objectversions_size() const;
  inline void clear_objectversions();
  static const int kObjectVersionsFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::ObjectVersionMapping& objectversions(int index) const;
  inline ::xtreemfs::pbrpc::ObjectVersionMapping* mutable_objectversions(int index);
  inline ::xtreemfs::pbrpc::ObjectVersionMapping* add_objectversions();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersionMapping >&
      objectversions() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersionMapping >*
      mutable_objectversions();

  // required .xtreemfs.pbrpc.TruncateLog truncate_log = 3;
  inline bool has_truncate_log() const;
  inline void clear_truncate_log();
  static const int kTruncateLogFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::TruncateLog& truncate_log() const;
  inline ::xtreemfs::pbrpc::TruncateLog* mutable_truncate_log();
  inline ::xtreemfs::pbrpc::TruncateLog* release_truncate_log();
  inline void set_allocated_truncate_log(::xtreemfs::pbrpc::TruncateLog* truncate_log);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.AuthoritativeReplicaState)
 private:
  inline void set_has_truncate_epoch();
  inline void clear_has_truncate_epoch();
  inline void set_has_max_obj_version();
  inline void clear_has_max_obj_version();
  inline void set_has_truncate_log();
  inline void clear_has_truncate_log();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 truncate_epoch_;
  ::google::protobuf::uint64 max_obj_version_;
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersionMapping > objectversions_;
  ::xtreemfs::pbrpc::TruncateLog* truncate_log_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static AuthoritativeReplicaState* default_instance_;
};
// -------------------------------------------------------------------

class InternalReadLocalResponse : public ::google::protobuf::Message {
 public:
  InternalReadLocalResponse();
  virtual ~InternalReadLocalResponse();

  InternalReadLocalResponse(const InternalReadLocalResponse& from);

  inline InternalReadLocalResponse& operator=(const InternalReadLocalResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const InternalReadLocalResponse& default_instance();

  void Swap(InternalReadLocalResponse* other);

  // implements Message ----------------------------------------------

  InternalReadLocalResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const InternalReadLocalResponse& from);
  void MergeFrom(const InternalReadLocalResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.ObjectData data = 1;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::ObjectData& data() const;
  inline ::xtreemfs::pbrpc::ObjectData* mutable_data();
  inline ::xtreemfs::pbrpc::ObjectData* release_data();
  inline void set_allocated_data(::xtreemfs::pbrpc::ObjectData* data);

  // repeated .xtreemfs.pbrpc.ObjectList object_set = 2;
  inline int object_set_size() const;
  inline void clear_object_set();
  static const int kObjectSetFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::ObjectList& object_set(int index) const;
  inline ::xtreemfs::pbrpc::ObjectList* mutable_object_set(int index);
  inline ::xtreemfs::pbrpc::ObjectList* add_object_set();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList >&
      object_set() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList >*
      mutable_object_set();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.InternalReadLocalResponse)
 private:
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::ObjectData* data_;
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList > object_set_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static InternalReadLocalResponse* default_instance_;
};
// -------------------------------------------------------------------

class readRequest : public ::google::protobuf::Message {
 public:
  readRequest();
  virtual ~readRequest();

  readRequest(const readRequest& from);

  inline readRequest& operator=(const readRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const readRequest& default_instance();

  void Swap(readRequest* other);

  // implements Message ----------------------------------------------

  readRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const readRequest& from);
  void MergeFrom(const readRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 object_number = 3;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 4;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // required fixed32 offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // required fixed32 length = 6;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 6;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.readRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_length();
  inline void clear_has_length();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static readRequest* default_instance_;
};
// -------------------------------------------------------------------

class truncateRequest : public ::google::protobuf::Message {
 public:
  truncateRequest();
  virtual ~truncateRequest();

  truncateRequest(const truncateRequest& from);

  inline truncateRequest& operator=(const truncateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const truncateRequest& default_instance();

  void Swap(truncateRequest* other);

  // implements Message ----------------------------------------------

  truncateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const truncateRequest& from);
  void MergeFrom(const truncateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 new_file_size = 3;
  inline bool has_new_file_size() const;
  inline void clear_new_file_size();
  static const int kNewFileSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 new_file_size() const;
  inline void set_new_file_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.truncateRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_new_file_size();
  inline void clear_has_new_file_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 new_file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static truncateRequest* default_instance_;
};
// -------------------------------------------------------------------

class unlink_osd_Request : public ::google::protobuf::Message {
 public:
  unlink_osd_Request();
  virtual ~unlink_osd_Request();

  unlink_osd_Request(const unlink_osd_Request& from);

  inline unlink_osd_Request& operator=(const unlink_osd_Request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const unlink_osd_Request& default_instance();

  void Swap(unlink_osd_Request* other);

  // implements Message ----------------------------------------------

  unlink_osd_Request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unlink_osd_Request& from);
  void MergeFrom(const unlink_osd_Request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.unlink_osd_Request)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static unlink_osd_Request* default_instance_;
};
// -------------------------------------------------------------------

class writeRequest : public ::google::protobuf::Message {
 public:
  writeRequest();
  virtual ~writeRequest();

  writeRequest(const writeRequest& from);

  inline writeRequest& operator=(const writeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const writeRequest& default_instance();

  void Swap(writeRequest* other);

  // implements Message ----------------------------------------------

  writeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const writeRequest& from);
  void MergeFrom(const writeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 object_number = 3;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 4;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // required fixed32 offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // required fixed64 lease_timeout = 6;
  inline bool has_lease_timeout() const;
  inline void clear_lease_timeout();
  static const int kLeaseTimeoutFieldNumber = 6;
  inline ::google::protobuf::uint64 lease_timeout() const;
  inline void set_lease_timeout(::google::protobuf::uint64 value);

  // required .xtreemfs.pbrpc.ObjectData object_data = 7;
  inline bool has_object_data() const;
  inline void clear_object_data();
  static const int kObjectDataFieldNumber = 7;
  inline const ::xtreemfs::pbrpc::ObjectData& object_data() const;
  inline ::xtreemfs::pbrpc::ObjectData* mutable_object_data();
  inline ::xtreemfs::pbrpc::ObjectData* release_object_data();
  inline void set_allocated_object_data(::xtreemfs::pbrpc::ObjectData* object_data);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.writeRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_lease_timeout();
  inline void clear_has_lease_timeout();
  inline void set_has_object_data();
  inline void clear_has_object_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;
  ::google::protobuf::uint64 lease_timeout_;
  ::xtreemfs::pbrpc::ObjectData* object_data_;
  ::google::protobuf::uint32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static writeRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_broadcast_gmaxRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_broadcast_gmaxRequest();
  virtual ~xtreemfs_broadcast_gmaxRequest();

  xtreemfs_broadcast_gmaxRequest(const xtreemfs_broadcast_gmaxRequest& from);

  inline xtreemfs_broadcast_gmaxRequest& operator=(const xtreemfs_broadcast_gmaxRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_broadcast_gmaxRequest& default_instance();

  void Swap(xtreemfs_broadcast_gmaxRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_broadcast_gmaxRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_broadcast_gmaxRequest& from);
  void MergeFrom(const xtreemfs_broadcast_gmaxRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 truncate_epoch = 2;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 2;
  inline ::google::protobuf::uint64 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint64 value);

  // required fixed64 last_object = 3;
  inline bool has_last_object() const;
  inline void clear_last_object();
  static const int kLastObjectFieldNumber = 3;
  inline ::google::protobuf::uint64 last_object() const;
  inline void set_last_object(::google::protobuf::uint64 value);

  // required fixed64 file_size = 4;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 4;
  inline ::google::protobuf::uint64 file_size() const;
  inline void set_file_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_broadcast_gmaxRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_truncate_epoch();
  inline void clear_has_truncate_epoch();
  inline void set_has_last_object();
  inline void clear_has_last_object();
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::google::protobuf::uint64 truncate_epoch_;
  ::google::protobuf::uint64 last_object_;
  ::google::protobuf::uint64 file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_broadcast_gmaxRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_check_objectRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_check_objectRequest();
  virtual ~xtreemfs_check_objectRequest();

  xtreemfs_check_objectRequest(const xtreemfs_check_objectRequest& from);

  inline xtreemfs_check_objectRequest& operator=(const xtreemfs_check_objectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_check_objectRequest& default_instance();

  void Swap(xtreemfs_check_objectRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_check_objectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_check_objectRequest& from);
  void MergeFrom(const xtreemfs_check_objectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 object_number = 3;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 4;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_check_objectRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_check_objectRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_cleanup_get_resultsResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_cleanup_get_resultsResponse();
  virtual ~xtreemfs_cleanup_get_resultsResponse();

  xtreemfs_cleanup_get_resultsResponse(const xtreemfs_cleanup_get_resultsResponse& from);

  inline xtreemfs_cleanup_get_resultsResponse& operator=(const xtreemfs_cleanup_get_resultsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_cleanup_get_resultsResponse& default_instance();

  void Swap(xtreemfs_cleanup_get_resultsResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_cleanup_get_resultsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_cleanup_get_resultsResponse& from);
  void MergeFrom(const xtreemfs_cleanup_get_resultsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string results = 1;
  inline int results_size() const;
  inline void clear_results();
  static const int kResultsFieldNumber = 1;
  inline const ::std::string& results(int index) const;
  inline ::std::string* mutable_results(int index);
  inline void set_results(int index, const ::std::string& value);
  inline void set_results(int index, const char* value);
  inline void set_results(int index, const char* value, size_t size);
  inline ::std::string* add_results();
  inline void add_results(const ::std::string& value);
  inline void add_results(const char* value);
  inline void add_results(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& results() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_results();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_cleanup_get_resultsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> results_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_cleanup_get_resultsResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_cleanup_is_runningResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_cleanup_is_runningResponse();
  virtual ~xtreemfs_cleanup_is_runningResponse();

  xtreemfs_cleanup_is_runningResponse(const xtreemfs_cleanup_is_runningResponse& from);

  inline xtreemfs_cleanup_is_runningResponse& operator=(const xtreemfs_cleanup_is_runningResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_cleanup_is_runningResponse& default_instance();

  void Swap(xtreemfs_cleanup_is_runningResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_cleanup_is_runningResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_cleanup_is_runningResponse& from);
  void MergeFrom(const xtreemfs_cleanup_is_runningResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool is_running = 1;
  inline bool has_is_running() const;
  inline void clear_is_running();
  static const int kIsRunningFieldNumber = 1;
  inline bool is_running() const;
  inline void set_is_running(bool value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_cleanup_is_runningResponse)
 private:
  inline void set_has_is_running();
  inline void clear_has_is_running();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool is_running_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_cleanup_is_runningResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_cleanup_startRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_cleanup_startRequest();
  virtual ~xtreemfs_cleanup_startRequest();

  xtreemfs_cleanup_startRequest(const xtreemfs_cleanup_startRequest& from);

  inline xtreemfs_cleanup_startRequest& operator=(const xtreemfs_cleanup_startRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_cleanup_startRequest& default_instance();

  void Swap(xtreemfs_cleanup_startRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_cleanup_startRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_cleanup_startRequest& from);
  void MergeFrom(const xtreemfs_cleanup_startRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool remove_zombies = 1;
  inline bool has_remove_zombies() const;
  inline void clear_remove_zombies();
  static const int kRemoveZombiesFieldNumber = 1;
  inline bool remove_zombies() const;
  inline void set_remove_zombies(bool value);

  // required bool remove_unavail_volume = 2;
  inline bool has_remove_unavail_volume() const;
  inline void clear_remove_unavail_volume();
  static const int kRemoveUnavailVolumeFieldNumber = 2;
  inline bool remove_unavail_volume() const;
  inline void set_remove_unavail_volume(bool value);

  // required bool lost_and_found = 3;
  inline bool has_lost_and_found() const;
  inline void clear_lost_and_found();
  static const int kLostAndFoundFieldNumber = 3;
  inline bool lost_and_found() const;
  inline void set_lost_and_found(bool value);

  // required bool delete_metadata = 4;
  inline bool has_delete_metadata() const;
  inline void clear_delete_metadata();
  static const int kDeleteMetadataFieldNumber = 4;
  inline bool delete_metadata() const;
  inline void set_delete_metadata(bool value);

  // required fixed32 metadata_timeout = 5;
  inline bool has_metadata_timeout() const;
  inline void clear_metadata_timeout();
  static const int kMetadataTimeoutFieldNumber = 5;
  inline ::google::protobuf::uint32 metadata_timeout() const;
  inline void set_metadata_timeout(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_cleanup_startRequest)
 private:
  inline void set_has_remove_zombies();
  inline void clear_has_remove_zombies();
  inline void set_has_remove_unavail_volume();
  inline void clear_has_remove_unavail_volume();
  inline void set_has_lost_and_found();
  inline void clear_has_lost_and_found();
  inline void set_has_delete_metadata();
  inline void clear_has_delete_metadata();
  inline void set_has_metadata_timeout();
  inline void clear_has_metadata_timeout();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool remove_zombies_;
  bool remove_unavail_volume_;
  bool lost_and_found_;
  bool delete_metadata_;
  ::google::protobuf::uint32 metadata_timeout_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_cleanup_startRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_cleanup_statusResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_cleanup_statusResponse();
  virtual ~xtreemfs_cleanup_statusResponse();

  xtreemfs_cleanup_statusResponse(const xtreemfs_cleanup_statusResponse& from);

  inline xtreemfs_cleanup_statusResponse& operator=(const xtreemfs_cleanup_statusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_cleanup_statusResponse& default_instance();

  void Swap(xtreemfs_cleanup_statusResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_cleanup_statusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_cleanup_statusResponse& from);
  void MergeFrom(const xtreemfs_cleanup_statusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string status = 1;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 1;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_cleanup_statusResponse)
 private:
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* status_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_cleanup_statusResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_finalize_vouchersRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_finalize_vouchersRequest();
  virtual ~xtreemfs_finalize_vouchersRequest();

  xtreemfs_finalize_vouchersRequest(const xtreemfs_finalize_vouchersRequest& from);

  inline xtreemfs_finalize_vouchersRequest& operator=(const xtreemfs_finalize_vouchersRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_finalize_vouchersRequest& default_instance();

  void Swap(xtreemfs_finalize_vouchersRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_finalize_vouchersRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_finalize_vouchersRequest& from);
  void MergeFrom(const xtreemfs_finalize_vouchersRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // repeated fixed64 expire_time_ms = 2;
  inline int expire_time_ms_size() const;
  inline void clear_expire_time_ms();
  static const int kExpireTimeMsFieldNumber = 2;
  inline ::google::protobuf::uint64 expire_time_ms(int index) const;
  inline void set_expire_time_ms(int index, ::google::protobuf::uint64 value);
  inline void add_expire_time_ms(::google::protobuf::uint64 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
      expire_time_ms() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
      mutable_expire_time_ms();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_finalize_vouchersRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::google::protobuf::RepeatedField< ::google::protobuf::uint64 > expire_time_ms_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_finalize_vouchersRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_fetchRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_fetchRequest();
  virtual ~xtreemfs_rwr_fetchRequest();

  xtreemfs_rwr_fetchRequest(const xtreemfs_rwr_fetchRequest& from);

  inline xtreemfs_rwr_fetchRequest& operator=(const xtreemfs_rwr_fetchRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_fetchRequest& default_instance();

  void Swap(xtreemfs_rwr_fetchRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_fetchRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_fetchRequest& from);
  void MergeFrom(const xtreemfs_rwr_fetchRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 object_number = 3;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 4;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_fetchRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_fetchRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_repair_objectRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_repair_objectRequest();
  virtual ~xtreemfs_repair_objectRequest();

  xtreemfs_repair_objectRequest(const xtreemfs_repair_objectRequest& from);

  inline xtreemfs_repair_objectRequest& operator=(const xtreemfs_repair_objectRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_repair_objectRequest& default_instance();

  void Swap(xtreemfs_repair_objectRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_repair_objectRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_repair_objectRequest& from);
  void MergeFrom(const xtreemfs_repair_objectRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 object_number = 3;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 4;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_repair_objectRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_repair_objectRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_flease_msgRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_flease_msgRequest();
  virtual ~xtreemfs_rwr_flease_msgRequest();

  xtreemfs_rwr_flease_msgRequest(const xtreemfs_rwr_flease_msgRequest& from);

  inline xtreemfs_rwr_flease_msgRequest& operator=(const xtreemfs_rwr_flease_msgRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_flease_msgRequest& default_instance();

  void Swap(xtreemfs_rwr_flease_msgRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_flease_msgRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_flease_msgRequest& from);
  void MergeFrom(const xtreemfs_rwr_flease_msgRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string sender_hostname = 1;
  inline bool has_sender_hostname() const;
  inline void clear_sender_hostname();
  static const int kSenderHostnameFieldNumber = 1;
  inline const ::std::string& sender_hostname() const;
  inline void set_sender_hostname(const ::std::string& value);
  inline void set_sender_hostname(const char* value);
  inline void set_sender_hostname(const char* value, size_t size);
  inline ::std::string* mutable_sender_hostname();
  inline ::std::string* release_sender_hostname();
  inline void set_allocated_sender_hostname(::std::string* sender_hostname);

  // required fixed32 sender_port = 2;
  inline bool has_sender_port() const;
  inline void clear_sender_port();
  static const int kSenderPortFieldNumber = 2;
  inline ::google::protobuf::uint32 sender_port() const;
  inline void set_sender_port(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_flease_msgRequest)
 private:
  inline void set_has_sender_hostname();
  inline void clear_has_sender_hostname();
  inline void set_has_sender_port();
  inline void clear_has_sender_port();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* sender_hostname_;
  ::google::protobuf::uint32 sender_port_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_flease_msgRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_set_primary_epochRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_set_primary_epochRequest();
  virtual ~xtreemfs_rwr_set_primary_epochRequest();

  xtreemfs_rwr_set_primary_epochRequest(const xtreemfs_rwr_set_primary_epochRequest& from);

  inline xtreemfs_rwr_set_primary_epochRequest& operator=(const xtreemfs_rwr_set_primary_epochRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_set_primary_epochRequest& default_instance();

  void Swap(xtreemfs_rwr_set_primary_epochRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_set_primary_epochRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_set_primary_epochRequest& from);
  void MergeFrom(const xtreemfs_rwr_set_primary_epochRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed32 primary_epoch = 3;
  inline bool has_primary_epoch() const;
  inline void clear_primary_epoch();
  static const int kPrimaryEpochFieldNumber = 3;
  inline ::google::protobuf::uint32 primary_epoch() const;
  inline void set_primary_epoch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_set_primary_epochRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_primary_epoch();
  inline void clear_has_primary_epoch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint32 primary_epoch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_set_primary_epochRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_statusRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_statusRequest();
  virtual ~xtreemfs_rwr_statusRequest();

  xtreemfs_rwr_statusRequest(const xtreemfs_rwr_statusRequest& from);

  inline xtreemfs_rwr_statusRequest& operator=(const xtreemfs_rwr_statusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_statusRequest& default_instance();

  void Swap(xtreemfs_rwr_statusRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_statusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_statusRequest& from);
  void MergeFrom(const xtreemfs_rwr_statusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 max_local_obj_version = 3;
  inline bool has_max_local_obj_version() const;
  inline void clear_max_local_obj_version();
  static const int kMaxLocalObjVersionFieldNumber = 3;
  inline ::google::protobuf::uint64 max_local_obj_version() const;
  inline void set_max_local_obj_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_statusRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_max_local_obj_version();
  inline void clear_has_max_local_obj_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 max_local_obj_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_statusRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_truncateRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_truncateRequest();
  virtual ~xtreemfs_rwr_truncateRequest();

  xtreemfs_rwr_truncateRequest(const xtreemfs_rwr_truncateRequest& from);

  inline xtreemfs_rwr_truncateRequest& operator=(const xtreemfs_rwr_truncateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_truncateRequest& default_instance();

  void Swap(xtreemfs_rwr_truncateRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_truncateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_truncateRequest& from);
  void MergeFrom(const xtreemfs_rwr_truncateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 new_file_size = 3;
  inline bool has_new_file_size() const;
  inline void clear_new_file_size();
  static const int kNewFileSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 new_file_size() const;
  inline void set_new_file_size(::google::protobuf::uint64 value);

  // required fixed64 object_version = 4;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_truncateRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_new_file_size();
  inline void clear_has_new_file_size();
  inline void set_has_object_version();
  inline void clear_has_object_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 new_file_size_;
  ::google::protobuf::uint64 object_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_truncateRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_updateRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_updateRequest();
  virtual ~xtreemfs_rwr_updateRequest();

  xtreemfs_rwr_updateRequest(const xtreemfs_rwr_updateRequest& from);

  inline xtreemfs_rwr_updateRequest& operator=(const xtreemfs_rwr_updateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_updateRequest& default_instance();

  void Swap(xtreemfs_rwr_updateRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_updateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_updateRequest& from);
  void MergeFrom(const xtreemfs_rwr_updateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 new_file_size = 3;
  inline bool has_new_file_size() const;
  inline void clear_new_file_size();
  static const int kNewFileSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 new_file_size() const;
  inline void set_new_file_size(::google::protobuf::uint64 value);

  // required fixed64 object_number = 7;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 7;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 4;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // required fixed32 offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // required .xtreemfs.pbrpc.ObjectData obj = 6;
  inline bool has_obj() const;
  inline void clear_obj();
  static const int kObjFieldNumber = 6;
  inline const ::xtreemfs::pbrpc::ObjectData& obj() const;
  inline ::xtreemfs::pbrpc::ObjectData* mutable_obj();
  inline ::xtreemfs::pbrpc::ObjectData* release_obj();
  inline void set_allocated_obj(::xtreemfs::pbrpc::ObjectData* obj);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_updateRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_new_file_size();
  inline void clear_has_new_file_size();
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_obj();
  inline void clear_has_obj();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 new_file_size_;
  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;
  ::xtreemfs::pbrpc::ObjectData* obj_;
  ::google::protobuf::uint32 offset_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_updateRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_internal_get_gmaxRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_internal_get_gmaxRequest();
  virtual ~xtreemfs_internal_get_gmaxRequest();

  xtreemfs_internal_get_gmaxRequest(const xtreemfs_internal_get_gmaxRequest& from);

  inline xtreemfs_internal_get_gmaxRequest& operator=(const xtreemfs_internal_get_gmaxRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_internal_get_gmaxRequest& default_instance();

  void Swap(xtreemfs_internal_get_gmaxRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_internal_get_gmaxRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_internal_get_gmaxRequest& from);
  void MergeFrom(const xtreemfs_internal_get_gmaxRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_internal_get_gmaxRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_internal_get_gmaxRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_internal_get_file_sizeRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_internal_get_file_sizeRequest();
  virtual ~xtreemfs_internal_get_file_sizeRequest();

  xtreemfs_internal_get_file_sizeRequest(const xtreemfs_internal_get_file_sizeRequest& from);

  inline xtreemfs_internal_get_file_sizeRequest& operator=(const xtreemfs_internal_get_file_sizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_internal_get_file_sizeRequest& default_instance();

  void Swap(xtreemfs_internal_get_file_sizeRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_internal_get_file_sizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_internal_get_file_sizeRequest& from);
  void MergeFrom(const xtreemfs_internal_get_file_sizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_internal_get_file_sizeRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_internal_get_file_sizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_internal_get_file_sizeResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_internal_get_file_sizeResponse();
  virtual ~xtreemfs_internal_get_file_sizeResponse();

  xtreemfs_internal_get_file_sizeResponse(const xtreemfs_internal_get_file_sizeResponse& from);

  inline xtreemfs_internal_get_file_sizeResponse& operator=(const xtreemfs_internal_get_file_sizeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_internal_get_file_sizeResponse& default_instance();

  void Swap(xtreemfs_internal_get_file_sizeResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_internal_get_file_sizeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_internal_get_file_sizeResponse& from);
  void MergeFrom(const xtreemfs_internal_get_file_sizeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 file_size = 1;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 file_size() const;
  inline void set_file_size(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_internal_get_file_sizeResponse)
 private:
  inline void set_has_file_size();
  inline void clear_has_file_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 file_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_internal_get_file_sizeResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_internal_read_localRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_internal_read_localRequest();
  virtual ~xtreemfs_internal_read_localRequest();

  xtreemfs_internal_read_localRequest(const xtreemfs_internal_read_localRequest& from);

  inline xtreemfs_internal_read_localRequest& operator=(const xtreemfs_internal_read_localRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_internal_read_localRequest& default_instance();

  void Swap(xtreemfs_internal_read_localRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_internal_read_localRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_internal_read_localRequest& from);
  void MergeFrom(const xtreemfs_internal_read_localRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 object_number = 3;
  inline bool has_object_number() const;
  inline void clear_object_number();
  static const int kObjectNumberFieldNumber = 3;
  inline ::google::protobuf::uint64 object_number() const;
  inline void set_object_number(::google::protobuf::uint64 value);

  // required fixed64 object_version = 4;
  inline bool has_object_version() const;
  inline void clear_object_version();
  static const int kObjectVersionFieldNumber = 4;
  inline ::google::protobuf::uint64 object_version() const;
  inline void set_object_version(::google::protobuf::uint64 value);

  // required fixed32 offset = 5;
  inline bool has_offset() const;
  inline void clear_offset();
  static const int kOffsetFieldNumber = 5;
  inline ::google::protobuf::uint32 offset() const;
  inline void set_offset(::google::protobuf::uint32 value);

  // required fixed32 length = 6;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 6;
  inline ::google::protobuf::uint32 length() const;
  inline void set_length(::google::protobuf::uint32 value);

  // required bool attach_object_list = 7;
  inline bool has_attach_object_list() const;
  inline void clear_attach_object_list();
  static const int kAttachObjectListFieldNumber = 7;
  inline bool attach_object_list() const;
  inline void set_attach_object_list(bool value);

  // repeated .xtreemfs.pbrpc.ObjectList required_objects = 8;
  inline int required_objects_size() const;
  inline void clear_required_objects();
  static const int kRequiredObjectsFieldNumber = 8;
  inline const ::xtreemfs::pbrpc::ObjectList& required_objects(int index) const;
  inline ::xtreemfs::pbrpc::ObjectList* mutable_required_objects(int index);
  inline ::xtreemfs::pbrpc::ObjectList* add_required_objects();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList >&
      required_objects() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList >*
      mutable_required_objects();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_internal_read_localRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_object_number();
  inline void clear_has_object_number();
  inline void set_has_object_version();
  inline void clear_has_object_version();
  inline void set_has_offset();
  inline void clear_has_offset();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_attach_object_list();
  inline void clear_has_attach_object_list();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 object_number_;
  ::google::protobuf::uint64 object_version_;
  ::google::protobuf::uint32 offset_;
  ::google::protobuf::uint32 length_;
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList > required_objects_;
  bool attach_object_list_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_internal_read_localRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_internal_get_object_setRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_internal_get_object_setRequest();
  virtual ~xtreemfs_internal_get_object_setRequest();

  xtreemfs_internal_get_object_setRequest(const xtreemfs_internal_get_object_setRequest& from);

  inline xtreemfs_internal_get_object_setRequest& operator=(const xtreemfs_internal_get_object_setRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_internal_get_object_setRequest& default_instance();

  void Swap(xtreemfs_internal_get_object_setRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_internal_get_object_setRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_internal_get_object_setRequest& from);
  void MergeFrom(const xtreemfs_internal_get_object_setRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_internal_get_object_setRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_internal_get_object_setRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_internal_get_fileid_listResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_internal_get_fileid_listResponse();
  virtual ~xtreemfs_internal_get_fileid_listResponse();

  xtreemfs_internal_get_fileid_listResponse(const xtreemfs_internal_get_fileid_listResponse& from);

  inline xtreemfs_internal_get_fileid_listResponse& operator=(const xtreemfs_internal_get_fileid_listResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_internal_get_fileid_listResponse& default_instance();

  void Swap(xtreemfs_internal_get_fileid_listResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_internal_get_fileid_listResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_internal_get_fileid_listResponse& from);
  void MergeFrom(const xtreemfs_internal_get_fileid_listResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string file_ids = 1;
  inline int file_ids_size() const;
  inline void clear_file_ids();
  static const int kFileIdsFieldNumber = 1;
  inline const ::std::string& file_ids(int index) const;
  inline ::std::string* mutable_file_ids(int index);
  inline void set_file_ids(int index, const ::std::string& value);
  inline void set_file_ids(int index, const char* value);
  inline void set_file_ids(int index, const char* value, size_t size);
  inline ::std::string* add_file_ids();
  inline void add_file_ids(const ::std::string& value);
  inline void add_file_ids(const char* value);
  inline void add_file_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& file_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_file_ids();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_internal_get_fileid_listResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> file_ids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_internal_get_fileid_listResponse* default_instance_;
};
// -------------------------------------------------------------------

class lockRequest : public ::google::protobuf::Message {
 public:
  lockRequest();
  virtual ~lockRequest();

  lockRequest(const lockRequest& from);

  inline lockRequest& operator=(const lockRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const lockRequest& default_instance();

  void Swap(lockRequest* other);

  // implements Message ----------------------------------------------

  lockRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const lockRequest& from);
  void MergeFrom(const lockRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required .xtreemfs.pbrpc.Lock lock_request = 2;
  inline bool has_lock_request() const;
  inline void clear_lock_request();
  static const int kLockRequestFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::Lock& lock_request() const;
  inline ::xtreemfs::pbrpc::Lock* mutable_lock_request();
  inline ::xtreemfs::pbrpc::Lock* release_lock_request();
  inline void set_allocated_lock_request(::xtreemfs::pbrpc::Lock* lock_request);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.lockRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_lock_request();
  inline void clear_has_lock_request();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::xtreemfs::pbrpc::Lock* lock_request_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static lockRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_pingMesssage : public ::google::protobuf::Message {
 public:
  xtreemfs_pingMesssage();
  virtual ~xtreemfs_pingMesssage();

  xtreemfs_pingMesssage(const xtreemfs_pingMesssage& from);

  inline xtreemfs_pingMesssage& operator=(const xtreemfs_pingMesssage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_pingMesssage& default_instance();

  void Swap(xtreemfs_pingMesssage* other);

  // implements Message ----------------------------------------------

  xtreemfs_pingMesssage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_pingMesssage& from);
  void MergeFrom(const xtreemfs_pingMesssage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 1;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::VivaldiCoordinates& coordinates() const;
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* mutable_coordinates();
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* release_coordinates();
  inline void set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates);

  // required bool request_response = 2;
  inline bool has_request_response() const;
  inline void clear_request_response();
  static const int kRequestResponseFieldNumber = 2;
  inline bool request_response() const;
  inline void set_request_response(bool value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_pingMesssage)
 private:
  inline void set_has_coordinates();
  inline void clear_has_coordinates();
  inline void set_has_request_response();
  inline void clear_has_request_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::VivaldiCoordinates* coordinates_;
  bool request_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_pingMesssage* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_auth_stateRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_auth_stateRequest();
  virtual ~xtreemfs_rwr_auth_stateRequest();

  xtreemfs_rwr_auth_stateRequest(const xtreemfs_rwr_auth_stateRequest& from);

  inline xtreemfs_rwr_auth_stateRequest& operator=(const xtreemfs_rwr_auth_stateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_auth_stateRequest& default_instance();

  void Swap(xtreemfs_rwr_auth_stateRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_auth_stateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_auth_stateRequest& from);
  void MergeFrom(const xtreemfs_rwr_auth_stateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required .xtreemfs.pbrpc.AuthoritativeReplicaState state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::AuthoritativeReplicaState& state() const;
  inline ::xtreemfs::pbrpc::AuthoritativeReplicaState* mutable_state();
  inline ::xtreemfs::pbrpc::AuthoritativeReplicaState* release_state();
  inline void set_allocated_state(::xtreemfs::pbrpc::AuthoritativeReplicaState* state);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_auth_stateRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::xtreemfs::pbrpc::AuthoritativeReplicaState* state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_auth_stateRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_reset_completeRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_reset_completeRequest();
  virtual ~xtreemfs_rwr_reset_completeRequest();

  xtreemfs_rwr_reset_completeRequest(const xtreemfs_rwr_reset_completeRequest& from);

  inline xtreemfs_rwr_reset_completeRequest& operator=(const xtreemfs_rwr_reset_completeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_reset_completeRequest& default_instance();

  void Swap(xtreemfs_rwr_reset_completeRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_reset_completeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_reset_completeRequest& from);
  void MergeFrom(const xtreemfs_rwr_reset_completeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed32 primary_epoch = 3;
  inline bool has_primary_epoch() const;
  inline void clear_primary_epoch();
  static const int kPrimaryEpochFieldNumber = 3;
  inline ::google::protobuf::uint32 primary_epoch() const;
  inline void set_primary_epoch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_reset_completeRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_primary_epoch();
  inline void clear_has_primary_epoch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::google::protobuf::uint32 primary_epoch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_reset_completeRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_xloc_set_invalidateRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_xloc_set_invalidateRequest();
  virtual ~xtreemfs_xloc_set_invalidateRequest();

  xtreemfs_xloc_set_invalidateRequest(const xtreemfs_xloc_set_invalidateRequest& from);

  inline xtreemfs_xloc_set_invalidateRequest& operator=(const xtreemfs_xloc_set_invalidateRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_xloc_set_invalidateRequest& default_instance();

  void Swap(xtreemfs_xloc_set_invalidateRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_xloc_set_invalidateRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_xloc_set_invalidateRequest& from);
  void MergeFrom(const xtreemfs_xloc_set_invalidateRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_xloc_set_invalidateRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_xloc_set_invalidateRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_xloc_set_invalidateResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_xloc_set_invalidateResponse();
  virtual ~xtreemfs_xloc_set_invalidateResponse();

  xtreemfs_xloc_set_invalidateResponse(const xtreemfs_xloc_set_invalidateResponse& from);

  inline xtreemfs_xloc_set_invalidateResponse& operator=(const xtreemfs_xloc_set_invalidateResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_xloc_set_invalidateResponse& default_instance();

  void Swap(xtreemfs_xloc_set_invalidateResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_xloc_set_invalidateResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_xloc_set_invalidateResponse& from);
  void MergeFrom(const xtreemfs_xloc_set_invalidateResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.LeaseState lease_state = 1;
  inline bool has_lease_state() const;
  inline void clear_lease_state();
  static const int kLeaseStateFieldNumber = 1;
  inline ::xtreemfs::pbrpc::LeaseState lease_state() const;
  inline void set_lease_state(::xtreemfs::pbrpc::LeaseState value);

  // optional .xtreemfs.pbrpc.ReplicaStatus replica_status = 2;
  inline bool has_replica_status() const;
  inline void clear_replica_status();
  static const int kReplicaStatusFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::ReplicaStatus& replica_status() const;
  inline ::xtreemfs::pbrpc::ReplicaStatus* mutable_replica_status();
  inline ::xtreemfs::pbrpc::ReplicaStatus* release_replica_status();
  inline void set_allocated_replica_status(::xtreemfs::pbrpc::ReplicaStatus* replica_status);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_xloc_set_invalidateResponse)
 private:
  inline void set_has_lease_state();
  inline void clear_has_lease_state();
  inline void set_has_replica_status();
  inline void clear_has_replica_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::ReplicaStatus* replica_status_;
  int lease_state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_xloc_set_invalidateResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_reset_statusRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_reset_statusRequest();
  virtual ~xtreemfs_rwr_reset_statusRequest();

  xtreemfs_rwr_reset_statusRequest(const xtreemfs_rwr_reset_statusRequest& from);

  inline xtreemfs_rwr_reset_statusRequest& operator=(const xtreemfs_rwr_reset_statusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_reset_statusRequest& default_instance();

  void Swap(xtreemfs_rwr_reset_statusRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_reset_statusRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_reset_statusRequest& from);
  void MergeFrom(const xtreemfs_rwr_reset_statusRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required .xtreemfs.pbrpc.AuthoritativeReplicaState state = 3;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::AuthoritativeReplicaState& state() const;
  inline ::xtreemfs::pbrpc::AuthoritativeReplicaState* mutable_state();
  inline ::xtreemfs::pbrpc::AuthoritativeReplicaState* release_state();
  inline void set_allocated_state(::xtreemfs::pbrpc::AuthoritativeReplicaState* state);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_reset_statusRequest)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_state();
  inline void clear_has_state();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;
  ::std::string* file_id_;
  ::xtreemfs::pbrpc::AuthoritativeReplicaState* state_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_reset_statusRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rwr_reset_statusResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_rwr_reset_statusResponse();
  virtual ~xtreemfs_rwr_reset_statusResponse();

  xtreemfs_rwr_reset_statusResponse(const xtreemfs_rwr_reset_statusResponse& from);

  inline xtreemfs_rwr_reset_statusResponse& operator=(const xtreemfs_rwr_reset_statusResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rwr_reset_statusResponse& default_instance();

  void Swap(xtreemfs_rwr_reset_statusResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_rwr_reset_statusResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rwr_reset_statusResponse& from);
  void MergeFrom(const xtreemfs_rwr_reset_statusResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool running = 1;
  inline bool has_running() const;
  inline void clear_running();
  static const int kRunningFieldNumber = 1;
  inline bool running() const;
  inline void set_running(bool value);

  // required bool complete = 2;
  inline bool has_complete() const;
  inline void clear_complete();
  static const int kCompleteFieldNumber = 2;
  inline bool complete() const;
  inline void set_complete(bool value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rwr_reset_statusResponse)
 private:
  inline void set_has_running();
  inline void clear_has_running();
  inline void set_has_complete();
  inline void clear_has_complete();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool running_;
  bool complete_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fOSD_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fOSD_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rwr_reset_statusResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// InternalGmax

// required fixed64 epoch = 1;
inline bool InternalGmax::has_epoch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalGmax::set_has_epoch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalGmax::clear_has_epoch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalGmax::clear_epoch() {
  epoch_ = GOOGLE_ULONGLONG(0);
  clear_has_epoch();
}
inline ::google::protobuf::uint64 InternalGmax::epoch() const {
  return epoch_;
}
inline void InternalGmax::set_epoch(::google::protobuf::uint64 value) {
  set_has_epoch();
  epoch_ = value;
}

// required fixed64 file_size = 2;
inline bool InternalGmax::has_file_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InternalGmax::set_has_file_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void InternalGmax::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void InternalGmax::clear_file_size() {
  file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::uint64 InternalGmax::file_size() const {
  return file_size_;
}
inline void InternalGmax::set_file_size(::google::protobuf::uint64 value) {
  set_has_file_size();
  file_size_ = value;
}

// required fixed64 last_object_id = 3;
inline bool InternalGmax::has_last_object_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InternalGmax::set_has_last_object_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void InternalGmax::clear_has_last_object_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void InternalGmax::clear_last_object_id() {
  last_object_id_ = GOOGLE_ULONGLONG(0);
  clear_has_last_object_id();
}
inline ::google::protobuf::uint64 InternalGmax::last_object_id() const {
  return last_object_id_;
}
inline void InternalGmax::set_last_object_id(::google::protobuf::uint64 value) {
  set_has_last_object_id();
  last_object_id_ = value;
}

// -------------------------------------------------------------------

// Lock

// required fixed32 client_pid = 1;
inline bool Lock::has_client_pid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Lock::set_has_client_pid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Lock::clear_has_client_pid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Lock::clear_client_pid() {
  client_pid_ = 0u;
  clear_has_client_pid();
}
inline ::google::protobuf::uint32 Lock::client_pid() const {
  return client_pid_;
}
inline void Lock::set_client_pid(::google::protobuf::uint32 value) {
  set_has_client_pid();
  client_pid_ = value;
}

// required string client_uuid = 2;
inline bool Lock::has_client_uuid() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Lock::set_has_client_uuid() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Lock::clear_has_client_uuid() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Lock::clear_client_uuid() {
  if (client_uuid_ != &::google::protobuf::internal::kEmptyString) {
    client_uuid_->clear();
  }
  clear_has_client_uuid();
}
inline const ::std::string& Lock::client_uuid() const {
  return *client_uuid_;
}
inline void Lock::set_client_uuid(const ::std::string& value) {
  set_has_client_uuid();
  if (client_uuid_ == &::google::protobuf::internal::kEmptyString) {
    client_uuid_ = new ::std::string;
  }
  client_uuid_->assign(value);
}
inline void Lock::set_client_uuid(const char* value) {
  set_has_client_uuid();
  if (client_uuid_ == &::google::protobuf::internal::kEmptyString) {
    client_uuid_ = new ::std::string;
  }
  client_uuid_->assign(value);
}
inline void Lock::set_client_uuid(const char* value, size_t size) {
  set_has_client_uuid();
  if (client_uuid_ == &::google::protobuf::internal::kEmptyString) {
    client_uuid_ = new ::std::string;
  }
  client_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Lock::mutable_client_uuid() {
  set_has_client_uuid();
  if (client_uuid_ == &::google::protobuf::internal::kEmptyString) {
    client_uuid_ = new ::std::string;
  }
  return client_uuid_;
}
inline ::std::string* Lock::release_client_uuid() {
  clear_has_client_uuid();
  if (client_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_uuid_;
    client_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Lock::set_allocated_client_uuid(::std::string* client_uuid) {
  if (client_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete client_uuid_;
  }
  if (client_uuid) {
    set_has_client_uuid();
    client_uuid_ = client_uuid;
  } else {
    clear_has_client_uuid();
    client_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 length = 3;
inline bool Lock::has_length() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Lock::set_has_length() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Lock::clear_has_length() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Lock::clear_length() {
  length_ = GOOGLE_ULONGLONG(0);
  clear_has_length();
}
inline ::google::protobuf::uint64 Lock::length() const {
  return length_;
}
inline void Lock::set_length(::google::protobuf::uint64 value) {
  set_has_length();
  length_ = value;
}

// required fixed64 offset = 4;
inline bool Lock::has_offset() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Lock::set_has_offset() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Lock::clear_has_offset() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Lock::clear_offset() {
  offset_ = GOOGLE_ULONGLONG(0);
  clear_has_offset();
}
inline ::google::protobuf::uint64 Lock::offset() const {
  return offset_;
}
inline void Lock::set_offset(::google::protobuf::uint64 value) {
  set_has_offset();
  offset_ = value;
}

// required bool exclusive = 5;
inline bool Lock::has_exclusive() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Lock::set_has_exclusive() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Lock::clear_has_exclusive() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Lock::clear_exclusive() {
  exclusive_ = false;
  clear_has_exclusive();
}
inline bool Lock::exclusive() const {
  return exclusive_;
}
inline void Lock::set_exclusive(bool value) {
  set_has_exclusive();
  exclusive_ = value;
}

// -------------------------------------------------------------------

// ObjectData

// required fixed32 checksum = 1;
inline bool ObjectData::has_checksum() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectData::set_has_checksum() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectData::clear_has_checksum() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectData::clear_checksum() {
  checksum_ = 0u;
  clear_has_checksum();
}
inline ::google::protobuf::uint32 ObjectData::checksum() const {
  return checksum_;
}
inline void ObjectData::set_checksum(::google::protobuf::uint32 value) {
  set_has_checksum();
  checksum_ = value;
}

// required bool invalid_checksum_on_osd = 2;
inline bool ObjectData::has_invalid_checksum_on_osd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectData::set_has_invalid_checksum_on_osd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectData::clear_has_invalid_checksum_on_osd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectData::clear_invalid_checksum_on_osd() {
  invalid_checksum_on_osd_ = false;
  clear_has_invalid_checksum_on_osd();
}
inline bool ObjectData::invalid_checksum_on_osd() const {
  return invalid_checksum_on_osd_;
}
inline void ObjectData::set_invalid_checksum_on_osd(bool value) {
  set_has_invalid_checksum_on_osd();
  invalid_checksum_on_osd_ = value;
}

// required fixed32 zero_padding = 3;
inline bool ObjectData::has_zero_padding() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectData::set_has_zero_padding() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectData::clear_has_zero_padding() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectData::clear_zero_padding() {
  zero_padding_ = 0u;
  clear_has_zero_padding();
}
inline ::google::protobuf::uint32 ObjectData::zero_padding() const {
  return zero_padding_;
}
inline void ObjectData::set_zero_padding(::google::protobuf::uint32 value) {
  set_has_zero_padding();
  zero_padding_ = value;
}

// -------------------------------------------------------------------

// ObjectList

// required bytes set = 1;
inline bool ObjectList::has_set() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectList::set_has_set() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectList::clear_has_set() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectList::clear_set() {
  if (set_ != &::google::protobuf::internal::kEmptyString) {
    set_->clear();
  }
  clear_has_set();
}
inline const ::std::string& ObjectList::set() const {
  return *set_;
}
inline void ObjectList::set_set(const ::std::string& value) {
  set_has_set();
  if (set_ == &::google::protobuf::internal::kEmptyString) {
    set_ = new ::std::string;
  }
  set_->assign(value);
}
inline void ObjectList::set_set(const char* value) {
  set_has_set();
  if (set_ == &::google::protobuf::internal::kEmptyString) {
    set_ = new ::std::string;
  }
  set_->assign(value);
}
inline void ObjectList::set_set(const void* value, size_t size) {
  set_has_set();
  if (set_ == &::google::protobuf::internal::kEmptyString) {
    set_ = new ::std::string;
  }
  set_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectList::mutable_set() {
  set_has_set();
  if (set_ == &::google::protobuf::internal::kEmptyString) {
    set_ = new ::std::string;
  }
  return set_;
}
inline ::std::string* ObjectList::release_set() {
  clear_has_set();
  if (set_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = set_;
    set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ObjectList::set_allocated_set(::std::string* set) {
  if (set_ != &::google::protobuf::internal::kEmptyString) {
    delete set_;
  }
  if (set) {
    set_has_set();
    set_ = set;
  } else {
    clear_has_set();
    set_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 stripe_width = 2;
inline bool ObjectList::has_stripe_width() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectList::set_has_stripe_width() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectList::clear_has_stripe_width() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectList::clear_stripe_width() {
  stripe_width_ = 0u;
  clear_has_stripe_width();
}
inline ::google::protobuf::uint32 ObjectList::stripe_width() const {
  return stripe_width_;
}
inline void ObjectList::set_stripe_width(::google::protobuf::uint32 value) {
  set_has_stripe_width();
  stripe_width_ = value;
}

// required fixed32 first_ = 3;
inline bool ObjectList::has_first_() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ObjectList::set_has_first_() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ObjectList::clear_has_first_() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ObjectList::clear_first_() {
  first__ = 0u;
  clear_has_first_();
}
inline ::google::protobuf::uint32 ObjectList::first_() const {
  return first__;
}
inline void ObjectList::set_first_(::google::protobuf::uint32 value) {
  set_has_first_();
  first__ = value;
}

// -------------------------------------------------------------------

// ObjectVersion

// required fixed64 object_number = 1;
inline bool ObjectVersion::has_object_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectVersion::set_has_object_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectVersion::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectVersion::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 ObjectVersion::object_number() const {
  return object_number_;
}
inline void ObjectVersion::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 2;
inline bool ObjectVersion::has_object_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectVersion::set_has_object_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectVersion::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectVersion::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 ObjectVersion::object_version() const {
  return object_version_;
}
inline void ObjectVersion::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// -------------------------------------------------------------------

// TruncateRecord

// required fixed64 version = 1;
inline bool TruncateRecord::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TruncateRecord::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TruncateRecord::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TruncateRecord::clear_version() {
  version_ = GOOGLE_ULONGLONG(0);
  clear_has_version();
}
inline ::google::protobuf::uint64 TruncateRecord::version() const {
  return version_;
}
inline void TruncateRecord::set_version(::google::protobuf::uint64 value) {
  set_has_version();
  version_ = value;
}

// required fixed64 last_object_number = 2;
inline bool TruncateRecord::has_last_object_number() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TruncateRecord::set_has_last_object_number() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TruncateRecord::clear_has_last_object_number() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TruncateRecord::clear_last_object_number() {
  last_object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_last_object_number();
}
inline ::google::protobuf::uint64 TruncateRecord::last_object_number() const {
  return last_object_number_;
}
inline void TruncateRecord::set_last_object_number(::google::protobuf::uint64 value) {
  set_has_last_object_number();
  last_object_number_ = value;
}

// -------------------------------------------------------------------

// TruncateLog

// repeated .xtreemfs.pbrpc.TruncateRecord records = 1;
inline int TruncateLog::records_size() const {
  return records_.size();
}
inline void TruncateLog::clear_records() {
  records_.Clear();
}
inline const ::xtreemfs::pbrpc::TruncateRecord& TruncateLog::records(int index) const {
  return records_.Get(index);
}
inline ::xtreemfs::pbrpc::TruncateRecord* TruncateLog::mutable_records(int index) {
  return records_.Mutable(index);
}
inline ::xtreemfs::pbrpc::TruncateRecord* TruncateLog::add_records() {
  return records_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::TruncateRecord >&
TruncateLog::records() const {
  return records_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::TruncateRecord >*
TruncateLog::mutable_records() {
  return &records_;
}

// -------------------------------------------------------------------

// XLocSetVersionState

// required fixed32 version = 1;
inline bool XLocSetVersionState::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XLocSetVersionState::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XLocSetVersionState::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XLocSetVersionState::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 XLocSetVersionState::version() const {
  return version_;
}
inline void XLocSetVersionState::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// required bool invalidated = 2;
inline bool XLocSetVersionState::has_invalidated() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XLocSetVersionState::set_has_invalidated() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XLocSetVersionState::clear_has_invalidated() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XLocSetVersionState::clear_invalidated() {
  invalidated_ = false;
  clear_has_invalidated();
}
inline bool XLocSetVersionState::invalidated() const {
  return invalidated_;
}
inline void XLocSetVersionState::set_invalidated(bool value) {
  set_has_invalidated();
  invalidated_ = value;
}

// optional fixed64 modified_time = 3;
inline bool XLocSetVersionState::has_modified_time() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XLocSetVersionState::set_has_modified_time() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XLocSetVersionState::clear_has_modified_time() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XLocSetVersionState::clear_modified_time() {
  modified_time_ = GOOGLE_ULONGLONG(0);
  clear_has_modified_time();
}
inline ::google::protobuf::uint64 XLocSetVersionState::modified_time() const {
  return modified_time_;
}
inline void XLocSetVersionState::set_modified_time(::google::protobuf::uint64 value) {
  set_has_modified_time();
  modified_time_ = value;
}

// -------------------------------------------------------------------

// ReplicaStatus

// required fixed64 truncate_epoch = 1;
inline bool ReplicaStatus::has_truncate_epoch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReplicaStatus::set_has_truncate_epoch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReplicaStatus::clear_has_truncate_epoch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReplicaStatus::clear_truncate_epoch() {
  truncate_epoch_ = GOOGLE_ULONGLONG(0);
  clear_has_truncate_epoch();
}
inline ::google::protobuf::uint64 ReplicaStatus::truncate_epoch() const {
  return truncate_epoch_;
}
inline void ReplicaStatus::set_truncate_epoch(::google::protobuf::uint64 value) {
  set_has_truncate_epoch();
  truncate_epoch_ = value;
}

// required fixed64 file_size = 2;
inline bool ReplicaStatus::has_file_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReplicaStatus::set_has_file_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReplicaStatus::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReplicaStatus::clear_file_size() {
  file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::uint64 ReplicaStatus::file_size() const {
  return file_size_;
}
inline void ReplicaStatus::set_file_size(::google::protobuf::uint64 value) {
  set_has_file_size();
  file_size_ = value;
}

// required fixed64 max_obj_version = 3;
inline bool ReplicaStatus::has_max_obj_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ReplicaStatus::set_has_max_obj_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ReplicaStatus::clear_has_max_obj_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ReplicaStatus::clear_max_obj_version() {
  max_obj_version_ = GOOGLE_ULONGLONG(0);
  clear_has_max_obj_version();
}
inline ::google::protobuf::uint64 ReplicaStatus::max_obj_version() const {
  return max_obj_version_;
}
inline void ReplicaStatus::set_max_obj_version(::google::protobuf::uint64 value) {
  set_has_max_obj_version();
  max_obj_version_ = value;
}

// required fixed32 primary_epoch = 4;
inline bool ReplicaStatus::has_primary_epoch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ReplicaStatus::set_has_primary_epoch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ReplicaStatus::clear_has_primary_epoch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ReplicaStatus::clear_primary_epoch() {
  primary_epoch_ = 0u;
  clear_has_primary_epoch();
}
inline ::google::protobuf::uint32 ReplicaStatus::primary_epoch() const {
  return primary_epoch_;
}
inline void ReplicaStatus::set_primary_epoch(::google::protobuf::uint32 value) {
  set_has_primary_epoch();
  primary_epoch_ = value;
}

// repeated .xtreemfs.pbrpc.ObjectVersion objectVersions = 5;
inline int ReplicaStatus::objectversions_size() const {
  return objectversions_.size();
}
inline void ReplicaStatus::clear_objectversions() {
  objectversions_.Clear();
}
inline const ::xtreemfs::pbrpc::ObjectVersion& ReplicaStatus::objectversions(int index) const {
  return objectversions_.Get(index);
}
inline ::xtreemfs::pbrpc::ObjectVersion* ReplicaStatus::mutable_objectversions(int index) {
  return objectversions_.Mutable(index);
}
inline ::xtreemfs::pbrpc::ObjectVersion* ReplicaStatus::add_objectversions() {
  return objectversions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersion >&
ReplicaStatus::objectversions() const {
  return objectversions_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersion >*
ReplicaStatus::mutable_objectversions() {
  return &objectversions_;
}

// required .xtreemfs.pbrpc.TruncateLog truncate_log = 6;
inline bool ReplicaStatus::has_truncate_log() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ReplicaStatus::set_has_truncate_log() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ReplicaStatus::clear_has_truncate_log() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ReplicaStatus::clear_truncate_log() {
  if (truncate_log_ != NULL) truncate_log_->::xtreemfs::pbrpc::TruncateLog::Clear();
  clear_has_truncate_log();
}
inline const ::xtreemfs::pbrpc::TruncateLog& ReplicaStatus::truncate_log() const {
  return truncate_log_ != NULL ? *truncate_log_ : *default_instance_->truncate_log_;
}
inline ::xtreemfs::pbrpc::TruncateLog* ReplicaStatus::mutable_truncate_log() {
  set_has_truncate_log();
  if (truncate_log_ == NULL) truncate_log_ = new ::xtreemfs::pbrpc::TruncateLog;
  return truncate_log_;
}
inline ::xtreemfs::pbrpc::TruncateLog* ReplicaStatus::release_truncate_log() {
  clear_has_truncate_log();
  ::xtreemfs::pbrpc::TruncateLog* temp = truncate_log_;
  truncate_log_ = NULL;
  return temp;
}
inline void ReplicaStatus::set_allocated_truncate_log(::xtreemfs::pbrpc::TruncateLog* truncate_log) {
  delete truncate_log_;
  truncate_log_ = truncate_log;
  if (truncate_log) {
    set_has_truncate_log();
  } else {
    clear_has_truncate_log();
  }
}

// -------------------------------------------------------------------

// ObjectVersionMapping

// required fixed64 object_number = 1;
inline bool ObjectVersionMapping::has_object_number() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ObjectVersionMapping::set_has_object_number() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ObjectVersionMapping::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ObjectVersionMapping::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 ObjectVersionMapping::object_number() const {
  return object_number_;
}
inline void ObjectVersionMapping::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 2;
inline bool ObjectVersionMapping::has_object_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ObjectVersionMapping::set_has_object_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ObjectVersionMapping::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ObjectVersionMapping::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 ObjectVersionMapping::object_version() const {
  return object_version_;
}
inline void ObjectVersionMapping::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// repeated string osd_uuids = 3;
inline int ObjectVersionMapping::osd_uuids_size() const {
  return osd_uuids_.size();
}
inline void ObjectVersionMapping::clear_osd_uuids() {
  osd_uuids_.Clear();
}
inline const ::std::string& ObjectVersionMapping::osd_uuids(int index) const {
  return osd_uuids_.Get(index);
}
inline ::std::string* ObjectVersionMapping::mutable_osd_uuids(int index) {
  return osd_uuids_.Mutable(index);
}
inline void ObjectVersionMapping::set_osd_uuids(int index, const ::std::string& value) {
  osd_uuids_.Mutable(index)->assign(value);
}
inline void ObjectVersionMapping::set_osd_uuids(int index, const char* value) {
  osd_uuids_.Mutable(index)->assign(value);
}
inline void ObjectVersionMapping::set_osd_uuids(int index, const char* value, size_t size) {
  osd_uuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ObjectVersionMapping::add_osd_uuids() {
  return osd_uuids_.Add();
}
inline void ObjectVersionMapping::add_osd_uuids(const ::std::string& value) {
  osd_uuids_.Add()->assign(value);
}
inline void ObjectVersionMapping::add_osd_uuids(const char* value) {
  osd_uuids_.Add()->assign(value);
}
inline void ObjectVersionMapping::add_osd_uuids(const char* value, size_t size) {
  osd_uuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
ObjectVersionMapping::osd_uuids() const {
  return osd_uuids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
ObjectVersionMapping::mutable_osd_uuids() {
  return &osd_uuids_;
}

// -------------------------------------------------------------------

// AuthoritativeReplicaState

// required fixed64 truncate_epoch = 1;
inline bool AuthoritativeReplicaState::has_truncate_epoch() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthoritativeReplicaState::set_has_truncate_epoch() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthoritativeReplicaState::clear_has_truncate_epoch() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthoritativeReplicaState::clear_truncate_epoch() {
  truncate_epoch_ = GOOGLE_ULONGLONG(0);
  clear_has_truncate_epoch();
}
inline ::google::protobuf::uint64 AuthoritativeReplicaState::truncate_epoch() const {
  return truncate_epoch_;
}
inline void AuthoritativeReplicaState::set_truncate_epoch(::google::protobuf::uint64 value) {
  set_has_truncate_epoch();
  truncate_epoch_ = value;
}

// required fixed64 max_obj_version = 4;
inline bool AuthoritativeReplicaState::has_max_obj_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AuthoritativeReplicaState::set_has_max_obj_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AuthoritativeReplicaState::clear_has_max_obj_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AuthoritativeReplicaState::clear_max_obj_version() {
  max_obj_version_ = GOOGLE_ULONGLONG(0);
  clear_has_max_obj_version();
}
inline ::google::protobuf::uint64 AuthoritativeReplicaState::max_obj_version() const {
  return max_obj_version_;
}
inline void AuthoritativeReplicaState::set_max_obj_version(::google::protobuf::uint64 value) {
  set_has_max_obj_version();
  max_obj_version_ = value;
}

// repeated .xtreemfs.pbrpc.ObjectVersionMapping objectVersions = 2;
inline int AuthoritativeReplicaState::objectversions_size() const {
  return objectversions_.size();
}
inline void AuthoritativeReplicaState::clear_objectversions() {
  objectversions_.Clear();
}
inline const ::xtreemfs::pbrpc::ObjectVersionMapping& AuthoritativeReplicaState::objectversions(int index) const {
  return objectversions_.Get(index);
}
inline ::xtreemfs::pbrpc::ObjectVersionMapping* AuthoritativeReplicaState::mutable_objectversions(int index) {
  return objectversions_.Mutable(index);
}
inline ::xtreemfs::pbrpc::ObjectVersionMapping* AuthoritativeReplicaState::add_objectversions() {
  return objectversions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersionMapping >&
AuthoritativeReplicaState::objectversions() const {
  return objectversions_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectVersionMapping >*
AuthoritativeReplicaState::mutable_objectversions() {
  return &objectversions_;
}

// required .xtreemfs.pbrpc.TruncateLog truncate_log = 3;
inline bool AuthoritativeReplicaState::has_truncate_log() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AuthoritativeReplicaState::set_has_truncate_log() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AuthoritativeReplicaState::clear_has_truncate_log() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AuthoritativeReplicaState::clear_truncate_log() {
  if (truncate_log_ != NULL) truncate_log_->::xtreemfs::pbrpc::TruncateLog::Clear();
  clear_has_truncate_log();
}
inline const ::xtreemfs::pbrpc::TruncateLog& AuthoritativeReplicaState::truncate_log() const {
  return truncate_log_ != NULL ? *truncate_log_ : *default_instance_->truncate_log_;
}
inline ::xtreemfs::pbrpc::TruncateLog* AuthoritativeReplicaState::mutable_truncate_log() {
  set_has_truncate_log();
  if (truncate_log_ == NULL) truncate_log_ = new ::xtreemfs::pbrpc::TruncateLog;
  return truncate_log_;
}
inline ::xtreemfs::pbrpc::TruncateLog* AuthoritativeReplicaState::release_truncate_log() {
  clear_has_truncate_log();
  ::xtreemfs::pbrpc::TruncateLog* temp = truncate_log_;
  truncate_log_ = NULL;
  return temp;
}
inline void AuthoritativeReplicaState::set_allocated_truncate_log(::xtreemfs::pbrpc::TruncateLog* truncate_log) {
  delete truncate_log_;
  truncate_log_ = truncate_log;
  if (truncate_log) {
    set_has_truncate_log();
  } else {
    clear_has_truncate_log();
  }
}

// -------------------------------------------------------------------

// InternalReadLocalResponse

// required .xtreemfs.pbrpc.ObjectData data = 1;
inline bool InternalReadLocalResponse::has_data() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InternalReadLocalResponse::set_has_data() {
  _has_bits_[0] |= 0x00000001u;
}
inline void InternalReadLocalResponse::clear_has_data() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void InternalReadLocalResponse::clear_data() {
  if (data_ != NULL) data_->::xtreemfs::pbrpc::ObjectData::Clear();
  clear_has_data();
}
inline const ::xtreemfs::pbrpc::ObjectData& InternalReadLocalResponse::data() const {
  return data_ != NULL ? *data_ : *default_instance_->data_;
}
inline ::xtreemfs::pbrpc::ObjectData* InternalReadLocalResponse::mutable_data() {
  set_has_data();
  if (data_ == NULL) data_ = new ::xtreemfs::pbrpc::ObjectData;
  return data_;
}
inline ::xtreemfs::pbrpc::ObjectData* InternalReadLocalResponse::release_data() {
  clear_has_data();
  ::xtreemfs::pbrpc::ObjectData* temp = data_;
  data_ = NULL;
  return temp;
}
inline void InternalReadLocalResponse::set_allocated_data(::xtreemfs::pbrpc::ObjectData* data) {
  delete data_;
  data_ = data;
  if (data) {
    set_has_data();
  } else {
    clear_has_data();
  }
}

// repeated .xtreemfs.pbrpc.ObjectList object_set = 2;
inline int InternalReadLocalResponse::object_set_size() const {
  return object_set_.size();
}
inline void InternalReadLocalResponse::clear_object_set() {
  object_set_.Clear();
}
inline const ::xtreemfs::pbrpc::ObjectList& InternalReadLocalResponse::object_set(int index) const {
  return object_set_.Get(index);
}
inline ::xtreemfs::pbrpc::ObjectList* InternalReadLocalResponse::mutable_object_set(int index) {
  return object_set_.Mutable(index);
}
inline ::xtreemfs::pbrpc::ObjectList* InternalReadLocalResponse::add_object_set() {
  return object_set_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList >&
InternalReadLocalResponse::object_set() const {
  return object_set_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList >*
InternalReadLocalResponse::mutable_object_set() {
  return &object_set_;
}

// -------------------------------------------------------------------

// readRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool readRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void readRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void readRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void readRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& readRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* readRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* readRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void readRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool readRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void readRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void readRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void readRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& readRequest::file_id() const {
  return *file_id_;
}
inline void readRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void readRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void readRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* readRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void readRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 object_number = 3;
inline bool readRequest::has_object_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void readRequest::set_has_object_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void readRequest::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void readRequest::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 readRequest::object_number() const {
  return object_number_;
}
inline void readRequest::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 4;
inline bool readRequest::has_object_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void readRequest::set_has_object_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void readRequest::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void readRequest::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 readRequest::object_version() const {
  return object_version_;
}
inline void readRequest::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// required fixed32 offset = 5;
inline bool readRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void readRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void readRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void readRequest::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 readRequest::offset() const {
  return offset_;
}
inline void readRequest::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// required fixed32 length = 6;
inline bool readRequest::has_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void readRequest::set_has_length() {
  _has_bits_[0] |= 0x00000020u;
}
inline void readRequest::clear_has_length() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void readRequest::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 readRequest::length() const {
  return length_;
}
inline void readRequest::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// -------------------------------------------------------------------

// truncateRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool truncateRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void truncateRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void truncateRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void truncateRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& truncateRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* truncateRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* truncateRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void truncateRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool truncateRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void truncateRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void truncateRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void truncateRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& truncateRequest::file_id() const {
  return *file_id_;
}
inline void truncateRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void truncateRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void truncateRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* truncateRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* truncateRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void truncateRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 new_file_size = 3;
inline bool truncateRequest::has_new_file_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void truncateRequest::set_has_new_file_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void truncateRequest::clear_has_new_file_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void truncateRequest::clear_new_file_size() {
  new_file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_new_file_size();
}
inline ::google::protobuf::uint64 truncateRequest::new_file_size() const {
  return new_file_size_;
}
inline void truncateRequest::set_new_file_size(::google::protobuf::uint64 value) {
  set_has_new_file_size();
  new_file_size_ = value;
}

// -------------------------------------------------------------------

// unlink_osd_Request

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool unlink_osd_Request::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void unlink_osd_Request::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void unlink_osd_Request::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void unlink_osd_Request::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& unlink_osd_Request::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* unlink_osd_Request::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* unlink_osd_Request::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void unlink_osd_Request::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool unlink_osd_Request::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void unlink_osd_Request::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void unlink_osd_Request::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void unlink_osd_Request::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& unlink_osd_Request::file_id() const {
  return *file_id_;
}
inline void unlink_osd_Request::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void unlink_osd_Request::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void unlink_osd_Request::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* unlink_osd_Request::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* unlink_osd_Request::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void unlink_osd_Request::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// writeRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool writeRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void writeRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void writeRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void writeRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& writeRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* writeRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* writeRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void writeRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool writeRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void writeRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void writeRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void writeRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& writeRequest::file_id() const {
  return *file_id_;
}
inline void writeRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void writeRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void writeRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* writeRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* writeRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void writeRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 object_number = 3;
inline bool writeRequest::has_object_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void writeRequest::set_has_object_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void writeRequest::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void writeRequest::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 writeRequest::object_number() const {
  return object_number_;
}
inline void writeRequest::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 4;
inline bool writeRequest::has_object_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void writeRequest::set_has_object_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void writeRequest::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void writeRequest::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 writeRequest::object_version() const {
  return object_version_;
}
inline void writeRequest::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// required fixed32 offset = 5;
inline bool writeRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void writeRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void writeRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void writeRequest::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 writeRequest::offset() const {
  return offset_;
}
inline void writeRequest::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// required fixed64 lease_timeout = 6;
inline bool writeRequest::has_lease_timeout() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void writeRequest::set_has_lease_timeout() {
  _has_bits_[0] |= 0x00000020u;
}
inline void writeRequest::clear_has_lease_timeout() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void writeRequest::clear_lease_timeout() {
  lease_timeout_ = GOOGLE_ULONGLONG(0);
  clear_has_lease_timeout();
}
inline ::google::protobuf::uint64 writeRequest::lease_timeout() const {
  return lease_timeout_;
}
inline void writeRequest::set_lease_timeout(::google::protobuf::uint64 value) {
  set_has_lease_timeout();
  lease_timeout_ = value;
}

// required .xtreemfs.pbrpc.ObjectData object_data = 7;
inline bool writeRequest::has_object_data() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void writeRequest::set_has_object_data() {
  _has_bits_[0] |= 0x00000040u;
}
inline void writeRequest::clear_has_object_data() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void writeRequest::clear_object_data() {
  if (object_data_ != NULL) object_data_->::xtreemfs::pbrpc::ObjectData::Clear();
  clear_has_object_data();
}
inline const ::xtreemfs::pbrpc::ObjectData& writeRequest::object_data() const {
  return object_data_ != NULL ? *object_data_ : *default_instance_->object_data_;
}
inline ::xtreemfs::pbrpc::ObjectData* writeRequest::mutable_object_data() {
  set_has_object_data();
  if (object_data_ == NULL) object_data_ = new ::xtreemfs::pbrpc::ObjectData;
  return object_data_;
}
inline ::xtreemfs::pbrpc::ObjectData* writeRequest::release_object_data() {
  clear_has_object_data();
  ::xtreemfs::pbrpc::ObjectData* temp = object_data_;
  object_data_ = NULL;
  return temp;
}
inline void writeRequest::set_allocated_object_data(::xtreemfs::pbrpc::ObjectData* object_data) {
  delete object_data_;
  object_data_ = object_data;
  if (object_data) {
    set_has_object_data();
  } else {
    clear_has_object_data();
  }
}

// -------------------------------------------------------------------

// xtreemfs_broadcast_gmaxRequest

// required string file_id = 1;
inline bool xtreemfs_broadcast_gmaxRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_broadcast_gmaxRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_broadcast_gmaxRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_broadcast_gmaxRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_broadcast_gmaxRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_broadcast_gmaxRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_broadcast_gmaxRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_broadcast_gmaxRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_broadcast_gmaxRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_broadcast_gmaxRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_broadcast_gmaxRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 truncate_epoch = 2;
inline bool xtreemfs_broadcast_gmaxRequest::has_truncate_epoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_broadcast_gmaxRequest::set_has_truncate_epoch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_broadcast_gmaxRequest::clear_has_truncate_epoch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_broadcast_gmaxRequest::clear_truncate_epoch() {
  truncate_epoch_ = GOOGLE_ULONGLONG(0);
  clear_has_truncate_epoch();
}
inline ::google::protobuf::uint64 xtreemfs_broadcast_gmaxRequest::truncate_epoch() const {
  return truncate_epoch_;
}
inline void xtreemfs_broadcast_gmaxRequest::set_truncate_epoch(::google::protobuf::uint64 value) {
  set_has_truncate_epoch();
  truncate_epoch_ = value;
}

// required fixed64 last_object = 3;
inline bool xtreemfs_broadcast_gmaxRequest::has_last_object() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_broadcast_gmaxRequest::set_has_last_object() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_broadcast_gmaxRequest::clear_has_last_object() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_broadcast_gmaxRequest::clear_last_object() {
  last_object_ = GOOGLE_ULONGLONG(0);
  clear_has_last_object();
}
inline ::google::protobuf::uint64 xtreemfs_broadcast_gmaxRequest::last_object() const {
  return last_object_;
}
inline void xtreemfs_broadcast_gmaxRequest::set_last_object(::google::protobuf::uint64 value) {
  set_has_last_object();
  last_object_ = value;
}

// required fixed64 file_size = 4;
inline bool xtreemfs_broadcast_gmaxRequest::has_file_size() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_broadcast_gmaxRequest::set_has_file_size() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_broadcast_gmaxRequest::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_broadcast_gmaxRequest::clear_file_size() {
  file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::uint64 xtreemfs_broadcast_gmaxRequest::file_size() const {
  return file_size_;
}
inline void xtreemfs_broadcast_gmaxRequest::set_file_size(::google::protobuf::uint64 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_check_objectRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_check_objectRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_check_objectRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_check_objectRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_check_objectRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_check_objectRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_check_objectRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_check_objectRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_check_objectRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_check_objectRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_check_objectRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_check_objectRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_check_objectRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_check_objectRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_check_objectRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_check_objectRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_check_objectRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_check_objectRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_check_objectRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_check_objectRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 object_number = 3;
inline bool xtreemfs_check_objectRequest::has_object_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_check_objectRequest::set_has_object_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_check_objectRequest::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_check_objectRequest::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 xtreemfs_check_objectRequest::object_number() const {
  return object_number_;
}
inline void xtreemfs_check_objectRequest::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 4;
inline bool xtreemfs_check_objectRequest::has_object_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_check_objectRequest::set_has_object_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_check_objectRequest::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_check_objectRequest::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 xtreemfs_check_objectRequest::object_version() const {
  return object_version_;
}
inline void xtreemfs_check_objectRequest::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_cleanup_get_resultsResponse

// repeated string results = 1;
inline int xtreemfs_cleanup_get_resultsResponse::results_size() const {
  return results_.size();
}
inline void xtreemfs_cleanup_get_resultsResponse::clear_results() {
  results_.Clear();
}
inline const ::std::string& xtreemfs_cleanup_get_resultsResponse::results(int index) const {
  return results_.Get(index);
}
inline ::std::string* xtreemfs_cleanup_get_resultsResponse::mutable_results(int index) {
  return results_.Mutable(index);
}
inline void xtreemfs_cleanup_get_resultsResponse::set_results(int index, const ::std::string& value) {
  results_.Mutable(index)->assign(value);
}
inline void xtreemfs_cleanup_get_resultsResponse::set_results(int index, const char* value) {
  results_.Mutable(index)->assign(value);
}
inline void xtreemfs_cleanup_get_resultsResponse::set_results(int index, const char* value, size_t size) {
  results_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_cleanup_get_resultsResponse::add_results() {
  return results_.Add();
}
inline void xtreemfs_cleanup_get_resultsResponse::add_results(const ::std::string& value) {
  results_.Add()->assign(value);
}
inline void xtreemfs_cleanup_get_resultsResponse::add_results(const char* value) {
  results_.Add()->assign(value);
}
inline void xtreemfs_cleanup_get_resultsResponse::add_results(const char* value, size_t size) {
  results_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
xtreemfs_cleanup_get_resultsResponse::results() const {
  return results_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
xtreemfs_cleanup_get_resultsResponse::mutable_results() {
  return &results_;
}

// -------------------------------------------------------------------

// xtreemfs_cleanup_is_runningResponse

// required bool is_running = 1;
inline bool xtreemfs_cleanup_is_runningResponse::has_is_running() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_cleanup_is_runningResponse::set_has_is_running() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_cleanup_is_runningResponse::clear_has_is_running() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_cleanup_is_runningResponse::clear_is_running() {
  is_running_ = false;
  clear_has_is_running();
}
inline bool xtreemfs_cleanup_is_runningResponse::is_running() const {
  return is_running_;
}
inline void xtreemfs_cleanup_is_runningResponse::set_is_running(bool value) {
  set_has_is_running();
  is_running_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_cleanup_startRequest

// required bool remove_zombies = 1;
inline bool xtreemfs_cleanup_startRequest::has_remove_zombies() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_cleanup_startRequest::set_has_remove_zombies() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_cleanup_startRequest::clear_has_remove_zombies() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_cleanup_startRequest::clear_remove_zombies() {
  remove_zombies_ = false;
  clear_has_remove_zombies();
}
inline bool xtreemfs_cleanup_startRequest::remove_zombies() const {
  return remove_zombies_;
}
inline void xtreemfs_cleanup_startRequest::set_remove_zombies(bool value) {
  set_has_remove_zombies();
  remove_zombies_ = value;
}

// required bool remove_unavail_volume = 2;
inline bool xtreemfs_cleanup_startRequest::has_remove_unavail_volume() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_cleanup_startRequest::set_has_remove_unavail_volume() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_cleanup_startRequest::clear_has_remove_unavail_volume() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_cleanup_startRequest::clear_remove_unavail_volume() {
  remove_unavail_volume_ = false;
  clear_has_remove_unavail_volume();
}
inline bool xtreemfs_cleanup_startRequest::remove_unavail_volume() const {
  return remove_unavail_volume_;
}
inline void xtreemfs_cleanup_startRequest::set_remove_unavail_volume(bool value) {
  set_has_remove_unavail_volume();
  remove_unavail_volume_ = value;
}

// required bool lost_and_found = 3;
inline bool xtreemfs_cleanup_startRequest::has_lost_and_found() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_cleanup_startRequest::set_has_lost_and_found() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_cleanup_startRequest::clear_has_lost_and_found() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_cleanup_startRequest::clear_lost_and_found() {
  lost_and_found_ = false;
  clear_has_lost_and_found();
}
inline bool xtreemfs_cleanup_startRequest::lost_and_found() const {
  return lost_and_found_;
}
inline void xtreemfs_cleanup_startRequest::set_lost_and_found(bool value) {
  set_has_lost_and_found();
  lost_and_found_ = value;
}

// required bool delete_metadata = 4;
inline bool xtreemfs_cleanup_startRequest::has_delete_metadata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_cleanup_startRequest::set_has_delete_metadata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_cleanup_startRequest::clear_has_delete_metadata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_cleanup_startRequest::clear_delete_metadata() {
  delete_metadata_ = false;
  clear_has_delete_metadata();
}
inline bool xtreemfs_cleanup_startRequest::delete_metadata() const {
  return delete_metadata_;
}
inline void xtreemfs_cleanup_startRequest::set_delete_metadata(bool value) {
  set_has_delete_metadata();
  delete_metadata_ = value;
}

// required fixed32 metadata_timeout = 5;
inline bool xtreemfs_cleanup_startRequest::has_metadata_timeout() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void xtreemfs_cleanup_startRequest::set_has_metadata_timeout() {
  _has_bits_[0] |= 0x00000010u;
}
inline void xtreemfs_cleanup_startRequest::clear_has_metadata_timeout() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void xtreemfs_cleanup_startRequest::clear_metadata_timeout() {
  metadata_timeout_ = 0u;
  clear_has_metadata_timeout();
}
inline ::google::protobuf::uint32 xtreemfs_cleanup_startRequest::metadata_timeout() const {
  return metadata_timeout_;
}
inline void xtreemfs_cleanup_startRequest::set_metadata_timeout(::google::protobuf::uint32 value) {
  set_has_metadata_timeout();
  metadata_timeout_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_cleanup_statusResponse

// required string status = 1;
inline bool xtreemfs_cleanup_statusResponse::has_status() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_cleanup_statusResponse::set_has_status() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_cleanup_statusResponse::clear_has_status() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_cleanup_statusResponse::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& xtreemfs_cleanup_statusResponse::status() const {
  return *status_;
}
inline void xtreemfs_cleanup_statusResponse::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void xtreemfs_cleanup_statusResponse::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void xtreemfs_cleanup_statusResponse::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_cleanup_statusResponse::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* xtreemfs_cleanup_statusResponse::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_cleanup_statusResponse::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_finalize_vouchersRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_finalize_vouchersRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_finalize_vouchersRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_finalize_vouchersRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_finalize_vouchersRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_finalize_vouchersRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_finalize_vouchersRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_finalize_vouchersRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_finalize_vouchersRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// repeated fixed64 expire_time_ms = 2;
inline int xtreemfs_finalize_vouchersRequest::expire_time_ms_size() const {
  return expire_time_ms_.size();
}
inline void xtreemfs_finalize_vouchersRequest::clear_expire_time_ms() {
  expire_time_ms_.Clear();
}
inline ::google::protobuf::uint64 xtreemfs_finalize_vouchersRequest::expire_time_ms(int index) const {
  return expire_time_ms_.Get(index);
}
inline void xtreemfs_finalize_vouchersRequest::set_expire_time_ms(int index, ::google::protobuf::uint64 value) {
  expire_time_ms_.Set(index, value);
}
inline void xtreemfs_finalize_vouchersRequest::add_expire_time_ms(::google::protobuf::uint64 value) {
  expire_time_ms_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >&
xtreemfs_finalize_vouchersRequest::expire_time_ms() const {
  return expire_time_ms_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::uint64 >*
xtreemfs_finalize_vouchersRequest::mutable_expire_time_ms() {
  return &expire_time_ms_;
}

// -------------------------------------------------------------------

// xtreemfs_rwr_fetchRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_rwr_fetchRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_fetchRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_fetchRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_fetchRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_rwr_fetchRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_fetchRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_fetchRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_fetchRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_rwr_fetchRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_fetchRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_fetchRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_fetchRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_rwr_fetchRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_rwr_fetchRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_fetchRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_fetchRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_fetchRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_rwr_fetchRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_fetchRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 object_number = 3;
inline bool xtreemfs_rwr_fetchRequest::has_object_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_rwr_fetchRequest::set_has_object_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_rwr_fetchRequest::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_rwr_fetchRequest::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 xtreemfs_rwr_fetchRequest::object_number() const {
  return object_number_;
}
inline void xtreemfs_rwr_fetchRequest::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 4;
inline bool xtreemfs_rwr_fetchRequest::has_object_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_rwr_fetchRequest::set_has_object_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_rwr_fetchRequest::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_rwr_fetchRequest::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 xtreemfs_rwr_fetchRequest::object_version() const {
  return object_version_;
}
inline void xtreemfs_rwr_fetchRequest::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_repair_objectRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_repair_objectRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_repair_objectRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_repair_objectRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_repair_objectRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_repair_objectRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_repair_objectRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_repair_objectRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_repair_objectRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_repair_objectRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_repair_objectRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_repair_objectRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_repair_objectRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_repair_objectRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_repair_objectRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_repair_objectRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_repair_objectRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_repair_objectRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_repair_objectRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_repair_objectRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 object_number = 3;
inline bool xtreemfs_repair_objectRequest::has_object_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_repair_objectRequest::set_has_object_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_repair_objectRequest::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_repair_objectRequest::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 xtreemfs_repair_objectRequest::object_number() const {
  return object_number_;
}
inline void xtreemfs_repair_objectRequest::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 4;
inline bool xtreemfs_repair_objectRequest::has_object_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_repair_objectRequest::set_has_object_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_repair_objectRequest::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_repair_objectRequest::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 xtreemfs_repair_objectRequest::object_version() const {
  return object_version_;
}
inline void xtreemfs_repair_objectRequest::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_rwr_flease_msgRequest

// required string sender_hostname = 1;
inline bool xtreemfs_rwr_flease_msgRequest::has_sender_hostname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_flease_msgRequest::set_has_sender_hostname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_flease_msgRequest::clear_has_sender_hostname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_flease_msgRequest::clear_sender_hostname() {
  if (sender_hostname_ != &::google::protobuf::internal::kEmptyString) {
    sender_hostname_->clear();
  }
  clear_has_sender_hostname();
}
inline const ::std::string& xtreemfs_rwr_flease_msgRequest::sender_hostname() const {
  return *sender_hostname_;
}
inline void xtreemfs_rwr_flease_msgRequest::set_sender_hostname(const ::std::string& value) {
  set_has_sender_hostname();
  if (sender_hostname_ == &::google::protobuf::internal::kEmptyString) {
    sender_hostname_ = new ::std::string;
  }
  sender_hostname_->assign(value);
}
inline void xtreemfs_rwr_flease_msgRequest::set_sender_hostname(const char* value) {
  set_has_sender_hostname();
  if (sender_hostname_ == &::google::protobuf::internal::kEmptyString) {
    sender_hostname_ = new ::std::string;
  }
  sender_hostname_->assign(value);
}
inline void xtreemfs_rwr_flease_msgRequest::set_sender_hostname(const char* value, size_t size) {
  set_has_sender_hostname();
  if (sender_hostname_ == &::google::protobuf::internal::kEmptyString) {
    sender_hostname_ = new ::std::string;
  }
  sender_hostname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_flease_msgRequest::mutable_sender_hostname() {
  set_has_sender_hostname();
  if (sender_hostname_ == &::google::protobuf::internal::kEmptyString) {
    sender_hostname_ = new ::std::string;
  }
  return sender_hostname_;
}
inline ::std::string* xtreemfs_rwr_flease_msgRequest::release_sender_hostname() {
  clear_has_sender_hostname();
  if (sender_hostname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = sender_hostname_;
    sender_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_flease_msgRequest::set_allocated_sender_hostname(::std::string* sender_hostname) {
  if (sender_hostname_ != &::google::protobuf::internal::kEmptyString) {
    delete sender_hostname_;
  }
  if (sender_hostname) {
    set_has_sender_hostname();
    sender_hostname_ = sender_hostname;
  } else {
    clear_has_sender_hostname();
    sender_hostname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 sender_port = 2;
inline bool xtreemfs_rwr_flease_msgRequest::has_sender_port() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_flease_msgRequest::set_has_sender_port() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_flease_msgRequest::clear_has_sender_port() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_flease_msgRequest::clear_sender_port() {
  sender_port_ = 0u;
  clear_has_sender_port();
}
inline ::google::protobuf::uint32 xtreemfs_rwr_flease_msgRequest::sender_port() const {
  return sender_port_;
}
inline void xtreemfs_rwr_flease_msgRequest::set_sender_port(::google::protobuf::uint32 value) {
  set_has_sender_port();
  sender_port_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_rwr_set_primary_epochRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_rwr_set_primary_epochRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_set_primary_epochRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_set_primary_epochRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_rwr_set_primary_epochRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_set_primary_epochRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_set_primary_epochRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_rwr_set_primary_epochRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_set_primary_epochRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_set_primary_epochRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_rwr_set_primary_epochRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_set_primary_epochRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_rwr_set_primary_epochRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 primary_epoch = 3;
inline bool xtreemfs_rwr_set_primary_epochRequest::has_primary_epoch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_has_primary_epoch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_rwr_set_primary_epochRequest::clear_has_primary_epoch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_rwr_set_primary_epochRequest::clear_primary_epoch() {
  primary_epoch_ = 0u;
  clear_has_primary_epoch();
}
inline ::google::protobuf::uint32 xtreemfs_rwr_set_primary_epochRequest::primary_epoch() const {
  return primary_epoch_;
}
inline void xtreemfs_rwr_set_primary_epochRequest::set_primary_epoch(::google::protobuf::uint32 value) {
  set_has_primary_epoch();
  primary_epoch_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_rwr_statusRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_rwr_statusRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_statusRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_statusRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_statusRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_rwr_statusRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_statusRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_statusRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_statusRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_rwr_statusRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_statusRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_statusRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_statusRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_rwr_statusRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_rwr_statusRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_statusRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_statusRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_statusRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_rwr_statusRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_statusRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 max_local_obj_version = 3;
inline bool xtreemfs_rwr_statusRequest::has_max_local_obj_version() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_rwr_statusRequest::set_has_max_local_obj_version() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_rwr_statusRequest::clear_has_max_local_obj_version() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_rwr_statusRequest::clear_max_local_obj_version() {
  max_local_obj_version_ = GOOGLE_ULONGLONG(0);
  clear_has_max_local_obj_version();
}
inline ::google::protobuf::uint64 xtreemfs_rwr_statusRequest::max_local_obj_version() const {
  return max_local_obj_version_;
}
inline void xtreemfs_rwr_statusRequest::set_max_local_obj_version(::google::protobuf::uint64 value) {
  set_has_max_local_obj_version();
  max_local_obj_version_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_rwr_truncateRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_rwr_truncateRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_truncateRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_truncateRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_truncateRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_rwr_truncateRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_truncateRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_truncateRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_truncateRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_rwr_truncateRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_truncateRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_truncateRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_truncateRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_rwr_truncateRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_rwr_truncateRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_truncateRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_truncateRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_truncateRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_rwr_truncateRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_truncateRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 new_file_size = 3;
inline bool xtreemfs_rwr_truncateRequest::has_new_file_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_rwr_truncateRequest::set_has_new_file_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_rwr_truncateRequest::clear_has_new_file_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_rwr_truncateRequest::clear_new_file_size() {
  new_file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_new_file_size();
}
inline ::google::protobuf::uint64 xtreemfs_rwr_truncateRequest::new_file_size() const {
  return new_file_size_;
}
inline void xtreemfs_rwr_truncateRequest::set_new_file_size(::google::protobuf::uint64 value) {
  set_has_new_file_size();
  new_file_size_ = value;
}

// required fixed64 object_version = 4;
inline bool xtreemfs_rwr_truncateRequest::has_object_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_rwr_truncateRequest::set_has_object_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_rwr_truncateRequest::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_rwr_truncateRequest::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 xtreemfs_rwr_truncateRequest::object_version() const {
  return object_version_;
}
inline void xtreemfs_rwr_truncateRequest::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_rwr_updateRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_rwr_updateRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_updateRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_updateRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_updateRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_rwr_updateRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_updateRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_updateRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_updateRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_rwr_updateRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_updateRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_updateRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_updateRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_rwr_updateRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_rwr_updateRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_updateRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_updateRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_updateRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_rwr_updateRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_updateRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 new_file_size = 3;
inline bool xtreemfs_rwr_updateRequest::has_new_file_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_rwr_updateRequest::set_has_new_file_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_rwr_updateRequest::clear_has_new_file_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_rwr_updateRequest::clear_new_file_size() {
  new_file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_new_file_size();
}
inline ::google::protobuf::uint64 xtreemfs_rwr_updateRequest::new_file_size() const {
  return new_file_size_;
}
inline void xtreemfs_rwr_updateRequest::set_new_file_size(::google::protobuf::uint64 value) {
  set_has_new_file_size();
  new_file_size_ = value;
}

// required fixed64 object_number = 7;
inline bool xtreemfs_rwr_updateRequest::has_object_number() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_rwr_updateRequest::set_has_object_number() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_rwr_updateRequest::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_rwr_updateRequest::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 xtreemfs_rwr_updateRequest::object_number() const {
  return object_number_;
}
inline void xtreemfs_rwr_updateRequest::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 4;
inline bool xtreemfs_rwr_updateRequest::has_object_version() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void xtreemfs_rwr_updateRequest::set_has_object_version() {
  _has_bits_[0] |= 0x00000010u;
}
inline void xtreemfs_rwr_updateRequest::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void xtreemfs_rwr_updateRequest::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 xtreemfs_rwr_updateRequest::object_version() const {
  return object_version_;
}
inline void xtreemfs_rwr_updateRequest::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// required fixed32 offset = 5;
inline bool xtreemfs_rwr_updateRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void xtreemfs_rwr_updateRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000020u;
}
inline void xtreemfs_rwr_updateRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void xtreemfs_rwr_updateRequest::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 xtreemfs_rwr_updateRequest::offset() const {
  return offset_;
}
inline void xtreemfs_rwr_updateRequest::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// required .xtreemfs.pbrpc.ObjectData obj = 6;
inline bool xtreemfs_rwr_updateRequest::has_obj() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void xtreemfs_rwr_updateRequest::set_has_obj() {
  _has_bits_[0] |= 0x00000040u;
}
inline void xtreemfs_rwr_updateRequest::clear_has_obj() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void xtreemfs_rwr_updateRequest::clear_obj() {
  if (obj_ != NULL) obj_->::xtreemfs::pbrpc::ObjectData::Clear();
  clear_has_obj();
}
inline const ::xtreemfs::pbrpc::ObjectData& xtreemfs_rwr_updateRequest::obj() const {
  return obj_ != NULL ? *obj_ : *default_instance_->obj_;
}
inline ::xtreemfs::pbrpc::ObjectData* xtreemfs_rwr_updateRequest::mutable_obj() {
  set_has_obj();
  if (obj_ == NULL) obj_ = new ::xtreemfs::pbrpc::ObjectData;
  return obj_;
}
inline ::xtreemfs::pbrpc::ObjectData* xtreemfs_rwr_updateRequest::release_obj() {
  clear_has_obj();
  ::xtreemfs::pbrpc::ObjectData* temp = obj_;
  obj_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_updateRequest::set_allocated_obj(::xtreemfs::pbrpc::ObjectData* obj) {
  delete obj_;
  obj_ = obj;
  if (obj) {
    set_has_obj();
  } else {
    clear_has_obj();
  }
}

// -------------------------------------------------------------------

// xtreemfs_internal_get_gmaxRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_internal_get_gmaxRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_internal_get_gmaxRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_internal_get_gmaxRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_internal_get_gmaxRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_internal_get_gmaxRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_internal_get_gmaxRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_internal_get_gmaxRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_internal_get_gmaxRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_internal_get_gmaxRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_internal_get_gmaxRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_internal_get_gmaxRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_internal_get_gmaxRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_internal_get_gmaxRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_internal_get_gmaxRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_internal_get_gmaxRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_internal_get_gmaxRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_internal_get_gmaxRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_internal_get_gmaxRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_internal_get_gmaxRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_internal_get_file_sizeRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_internal_get_file_sizeRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_internal_get_file_sizeRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_internal_get_file_sizeRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_internal_get_file_sizeRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_internal_get_file_sizeRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_internal_get_file_sizeRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_internal_get_file_sizeRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_internal_get_file_sizeRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_internal_get_file_sizeRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_internal_get_file_sizeRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_internal_get_file_sizeRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_internal_get_file_sizeRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_internal_get_file_sizeRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_internal_get_file_sizeRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_internal_get_file_sizeRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_internal_get_file_sizeRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_internal_get_file_sizeRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_internal_get_file_sizeRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_internal_get_file_sizeRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_internal_get_file_sizeResponse

// required fixed64 file_size = 1;
inline bool xtreemfs_internal_get_file_sizeResponse::has_file_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_internal_get_file_sizeResponse::set_has_file_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_internal_get_file_sizeResponse::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_internal_get_file_sizeResponse::clear_file_size() {
  file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::uint64 xtreemfs_internal_get_file_sizeResponse::file_size() const {
  return file_size_;
}
inline void xtreemfs_internal_get_file_sizeResponse::set_file_size(::google::protobuf::uint64 value) {
  set_has_file_size();
  file_size_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_internal_read_localRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_internal_read_localRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_internal_read_localRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_internal_read_localRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_internal_read_localRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_internal_read_localRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_internal_read_localRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_internal_read_localRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_internal_read_localRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_internal_read_localRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_internal_read_localRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_internal_read_localRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_internal_read_localRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_internal_read_localRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_internal_read_localRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_internal_read_localRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_internal_read_localRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_internal_read_localRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_internal_read_localRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_internal_read_localRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 object_number = 3;
inline bool xtreemfs_internal_read_localRequest::has_object_number() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_internal_read_localRequest::set_has_object_number() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_internal_read_localRequest::clear_has_object_number() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_internal_read_localRequest::clear_object_number() {
  object_number_ = GOOGLE_ULONGLONG(0);
  clear_has_object_number();
}
inline ::google::protobuf::uint64 xtreemfs_internal_read_localRequest::object_number() const {
  return object_number_;
}
inline void xtreemfs_internal_read_localRequest::set_object_number(::google::protobuf::uint64 value) {
  set_has_object_number();
  object_number_ = value;
}

// required fixed64 object_version = 4;
inline bool xtreemfs_internal_read_localRequest::has_object_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_internal_read_localRequest::set_has_object_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_internal_read_localRequest::clear_has_object_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_internal_read_localRequest::clear_object_version() {
  object_version_ = GOOGLE_ULONGLONG(0);
  clear_has_object_version();
}
inline ::google::protobuf::uint64 xtreemfs_internal_read_localRequest::object_version() const {
  return object_version_;
}
inline void xtreemfs_internal_read_localRequest::set_object_version(::google::protobuf::uint64 value) {
  set_has_object_version();
  object_version_ = value;
}

// required fixed32 offset = 5;
inline bool xtreemfs_internal_read_localRequest::has_offset() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void xtreemfs_internal_read_localRequest::set_has_offset() {
  _has_bits_[0] |= 0x00000010u;
}
inline void xtreemfs_internal_read_localRequest::clear_has_offset() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void xtreemfs_internal_read_localRequest::clear_offset() {
  offset_ = 0u;
  clear_has_offset();
}
inline ::google::protobuf::uint32 xtreemfs_internal_read_localRequest::offset() const {
  return offset_;
}
inline void xtreemfs_internal_read_localRequest::set_offset(::google::protobuf::uint32 value) {
  set_has_offset();
  offset_ = value;
}

// required fixed32 length = 6;
inline bool xtreemfs_internal_read_localRequest::has_length() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void xtreemfs_internal_read_localRequest::set_has_length() {
  _has_bits_[0] |= 0x00000020u;
}
inline void xtreemfs_internal_read_localRequest::clear_has_length() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void xtreemfs_internal_read_localRequest::clear_length() {
  length_ = 0u;
  clear_has_length();
}
inline ::google::protobuf::uint32 xtreemfs_internal_read_localRequest::length() const {
  return length_;
}
inline void xtreemfs_internal_read_localRequest::set_length(::google::protobuf::uint32 value) {
  set_has_length();
  length_ = value;
}

// required bool attach_object_list = 7;
inline bool xtreemfs_internal_read_localRequest::has_attach_object_list() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void xtreemfs_internal_read_localRequest::set_has_attach_object_list() {
  _has_bits_[0] |= 0x00000040u;
}
inline void xtreemfs_internal_read_localRequest::clear_has_attach_object_list() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void xtreemfs_internal_read_localRequest::clear_attach_object_list() {
  attach_object_list_ = false;
  clear_has_attach_object_list();
}
inline bool xtreemfs_internal_read_localRequest::attach_object_list() const {
  return attach_object_list_;
}
inline void xtreemfs_internal_read_localRequest::set_attach_object_list(bool value) {
  set_has_attach_object_list();
  attach_object_list_ = value;
}

// repeated .xtreemfs.pbrpc.ObjectList required_objects = 8;
inline int xtreemfs_internal_read_localRequest::required_objects_size() const {
  return required_objects_.size();
}
inline void xtreemfs_internal_read_localRequest::clear_required_objects() {
  required_objects_.Clear();
}
inline const ::xtreemfs::pbrpc::ObjectList& xtreemfs_internal_read_localRequest::required_objects(int index) const {
  return required_objects_.Get(index);
}
inline ::xtreemfs::pbrpc::ObjectList* xtreemfs_internal_read_localRequest::mutable_required_objects(int index) {
  return required_objects_.Mutable(index);
}
inline ::xtreemfs::pbrpc::ObjectList* xtreemfs_internal_read_localRequest::add_required_objects() {
  return required_objects_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList >&
xtreemfs_internal_read_localRequest::required_objects() const {
  return required_objects_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::ObjectList >*
xtreemfs_internal_read_localRequest::mutable_required_objects() {
  return &required_objects_;
}

// -------------------------------------------------------------------

// xtreemfs_internal_get_object_setRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_internal_get_object_setRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_internal_get_object_setRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_internal_get_object_setRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_internal_get_object_setRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_internal_get_object_setRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_internal_get_object_setRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_internal_get_object_setRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_internal_get_object_setRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_internal_get_object_setRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_internal_get_object_setRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_internal_get_object_setRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_internal_get_object_setRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_internal_get_object_setRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_internal_get_object_setRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_internal_get_object_setRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_internal_get_object_setRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_internal_get_object_setRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_internal_get_object_setRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_internal_get_object_setRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_internal_get_fileid_listResponse

// repeated string file_ids = 1;
inline int xtreemfs_internal_get_fileid_listResponse::file_ids_size() const {
  return file_ids_.size();
}
inline void xtreemfs_internal_get_fileid_listResponse::clear_file_ids() {
  file_ids_.Clear();
}
inline const ::std::string& xtreemfs_internal_get_fileid_listResponse::file_ids(int index) const {
  return file_ids_.Get(index);
}
inline ::std::string* xtreemfs_internal_get_fileid_listResponse::mutable_file_ids(int index) {
  return file_ids_.Mutable(index);
}
inline void xtreemfs_internal_get_fileid_listResponse::set_file_ids(int index, const ::std::string& value) {
  file_ids_.Mutable(index)->assign(value);
}
inline void xtreemfs_internal_get_fileid_listResponse::set_file_ids(int index, const char* value) {
  file_ids_.Mutable(index)->assign(value);
}
inline void xtreemfs_internal_get_fileid_listResponse::set_file_ids(int index, const char* value, size_t size) {
  file_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_internal_get_fileid_listResponse::add_file_ids() {
  return file_ids_.Add();
}
inline void xtreemfs_internal_get_fileid_listResponse::add_file_ids(const ::std::string& value) {
  file_ids_.Add()->assign(value);
}
inline void xtreemfs_internal_get_fileid_listResponse::add_file_ids(const char* value) {
  file_ids_.Add()->assign(value);
}
inline void xtreemfs_internal_get_fileid_listResponse::add_file_ids(const char* value, size_t size) {
  file_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
xtreemfs_internal_get_fileid_listResponse::file_ids() const {
  return file_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
xtreemfs_internal_get_fileid_listResponse::mutable_file_ids() {
  return &file_ids_;
}

// -------------------------------------------------------------------

// lockRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool lockRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void lockRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void lockRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void lockRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& lockRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* lockRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* lockRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void lockRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required .xtreemfs.pbrpc.Lock lock_request = 2;
inline bool lockRequest::has_lock_request() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void lockRequest::set_has_lock_request() {
  _has_bits_[0] |= 0x00000002u;
}
inline void lockRequest::clear_has_lock_request() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void lockRequest::clear_lock_request() {
  if (lock_request_ != NULL) lock_request_->::xtreemfs::pbrpc::Lock::Clear();
  clear_has_lock_request();
}
inline const ::xtreemfs::pbrpc::Lock& lockRequest::lock_request() const {
  return lock_request_ != NULL ? *lock_request_ : *default_instance_->lock_request_;
}
inline ::xtreemfs::pbrpc::Lock* lockRequest::mutable_lock_request() {
  set_has_lock_request();
  if (lock_request_ == NULL) lock_request_ = new ::xtreemfs::pbrpc::Lock;
  return lock_request_;
}
inline ::xtreemfs::pbrpc::Lock* lockRequest::release_lock_request() {
  clear_has_lock_request();
  ::xtreemfs::pbrpc::Lock* temp = lock_request_;
  lock_request_ = NULL;
  return temp;
}
inline void lockRequest::set_allocated_lock_request(::xtreemfs::pbrpc::Lock* lock_request) {
  delete lock_request_;
  lock_request_ = lock_request;
  if (lock_request) {
    set_has_lock_request();
  } else {
    clear_has_lock_request();
  }
}

// -------------------------------------------------------------------

// xtreemfs_pingMesssage

// required .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 1;
inline bool xtreemfs_pingMesssage::has_coordinates() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_pingMesssage::set_has_coordinates() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_pingMesssage::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_pingMesssage::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::xtreemfs::pbrpc::VivaldiCoordinates::Clear();
  clear_has_coordinates();
}
inline const ::xtreemfs::pbrpc::VivaldiCoordinates& xtreemfs_pingMesssage::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_pingMesssage::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == NULL) coordinates_ = new ::xtreemfs::pbrpc::VivaldiCoordinates;
  return coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_pingMesssage::release_coordinates() {
  clear_has_coordinates();
  ::xtreemfs::pbrpc::VivaldiCoordinates* temp = coordinates_;
  coordinates_ = NULL;
  return temp;
}
inline void xtreemfs_pingMesssage::set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates) {
  delete coordinates_;
  coordinates_ = coordinates;
  if (coordinates) {
    set_has_coordinates();
  } else {
    clear_has_coordinates();
  }
}

// required bool request_response = 2;
inline bool xtreemfs_pingMesssage::has_request_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_pingMesssage::set_has_request_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_pingMesssage::clear_has_request_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_pingMesssage::clear_request_response() {
  request_response_ = false;
  clear_has_request_response();
}
inline bool xtreemfs_pingMesssage::request_response() const {
  return request_response_;
}
inline void xtreemfs_pingMesssage::set_request_response(bool value) {
  set_has_request_response();
  request_response_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_rwr_auth_stateRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_rwr_auth_stateRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_auth_stateRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_auth_stateRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_auth_stateRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_rwr_auth_stateRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_auth_stateRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_auth_stateRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_auth_stateRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_rwr_auth_stateRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_auth_stateRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_auth_stateRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_auth_stateRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_rwr_auth_stateRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_rwr_auth_stateRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_auth_stateRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_auth_stateRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_auth_stateRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_rwr_auth_stateRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_auth_stateRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .xtreemfs.pbrpc.AuthoritativeReplicaState state = 3;
inline bool xtreemfs_rwr_auth_stateRequest::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_rwr_auth_stateRequest::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_rwr_auth_stateRequest::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_rwr_auth_stateRequest::clear_state() {
  if (state_ != NULL) state_->::xtreemfs::pbrpc::AuthoritativeReplicaState::Clear();
  clear_has_state();
}
inline const ::xtreemfs::pbrpc::AuthoritativeReplicaState& xtreemfs_rwr_auth_stateRequest::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::xtreemfs::pbrpc::AuthoritativeReplicaState* xtreemfs_rwr_auth_stateRequest::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::xtreemfs::pbrpc::AuthoritativeReplicaState;
  return state_;
}
inline ::xtreemfs::pbrpc::AuthoritativeReplicaState* xtreemfs_rwr_auth_stateRequest::release_state() {
  clear_has_state();
  ::xtreemfs::pbrpc::AuthoritativeReplicaState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_auth_stateRequest::set_allocated_state(::xtreemfs::pbrpc::AuthoritativeReplicaState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// -------------------------------------------------------------------

// xtreemfs_rwr_reset_completeRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_rwr_reset_completeRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_reset_completeRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_reset_completeRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_reset_completeRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_rwr_reset_completeRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_reset_completeRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_reset_completeRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_reset_completeRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_rwr_reset_completeRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_reset_completeRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_reset_completeRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_reset_completeRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_rwr_reset_completeRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_rwr_reset_completeRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_reset_completeRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_reset_completeRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_reset_completeRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_rwr_reset_completeRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_reset_completeRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 primary_epoch = 3;
inline bool xtreemfs_rwr_reset_completeRequest::has_primary_epoch() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_rwr_reset_completeRequest::set_has_primary_epoch() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_rwr_reset_completeRequest::clear_has_primary_epoch() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_rwr_reset_completeRequest::clear_primary_epoch() {
  primary_epoch_ = 0u;
  clear_has_primary_epoch();
}
inline ::google::protobuf::uint32 xtreemfs_rwr_reset_completeRequest::primary_epoch() const {
  return primary_epoch_;
}
inline void xtreemfs_rwr_reset_completeRequest::set_primary_epoch(::google::protobuf::uint32 value) {
  set_has_primary_epoch();
  primary_epoch_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_xloc_set_invalidateRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_xloc_set_invalidateRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_xloc_set_invalidateRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_xloc_set_invalidateRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_xloc_set_invalidateRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_xloc_set_invalidateRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_xloc_set_invalidateRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_xloc_set_invalidateRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_xloc_set_invalidateRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_xloc_set_invalidateRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_xloc_set_invalidateRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_xloc_set_invalidateRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_xloc_set_invalidateRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_xloc_set_invalidateRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_xloc_set_invalidateRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_xloc_set_invalidateRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_xloc_set_invalidateRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_xloc_set_invalidateRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_xloc_set_invalidateRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_xloc_set_invalidateRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_xloc_set_invalidateResponse

// required .xtreemfs.pbrpc.LeaseState lease_state = 1;
inline bool xtreemfs_xloc_set_invalidateResponse::has_lease_state() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_xloc_set_invalidateResponse::set_has_lease_state() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_xloc_set_invalidateResponse::clear_has_lease_state() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_xloc_set_invalidateResponse::clear_lease_state() {
  lease_state_ = 0;
  clear_has_lease_state();
}
inline ::xtreemfs::pbrpc::LeaseState xtreemfs_xloc_set_invalidateResponse::lease_state() const {
  return static_cast< ::xtreemfs::pbrpc::LeaseState >(lease_state_);
}
inline void xtreemfs_xloc_set_invalidateResponse::set_lease_state(::xtreemfs::pbrpc::LeaseState value) {
  assert(::xtreemfs::pbrpc::LeaseState_IsValid(value));
  set_has_lease_state();
  lease_state_ = value;
}

// optional .xtreemfs.pbrpc.ReplicaStatus replica_status = 2;
inline bool xtreemfs_xloc_set_invalidateResponse::has_replica_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_xloc_set_invalidateResponse::set_has_replica_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_xloc_set_invalidateResponse::clear_has_replica_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_xloc_set_invalidateResponse::clear_replica_status() {
  if (replica_status_ != NULL) replica_status_->::xtreemfs::pbrpc::ReplicaStatus::Clear();
  clear_has_replica_status();
}
inline const ::xtreemfs::pbrpc::ReplicaStatus& xtreemfs_xloc_set_invalidateResponse::replica_status() const {
  return replica_status_ != NULL ? *replica_status_ : *default_instance_->replica_status_;
}
inline ::xtreemfs::pbrpc::ReplicaStatus* xtreemfs_xloc_set_invalidateResponse::mutable_replica_status() {
  set_has_replica_status();
  if (replica_status_ == NULL) replica_status_ = new ::xtreemfs::pbrpc::ReplicaStatus;
  return replica_status_;
}
inline ::xtreemfs::pbrpc::ReplicaStatus* xtreemfs_xloc_set_invalidateResponse::release_replica_status() {
  clear_has_replica_status();
  ::xtreemfs::pbrpc::ReplicaStatus* temp = replica_status_;
  replica_status_ = NULL;
  return temp;
}
inline void xtreemfs_xloc_set_invalidateResponse::set_allocated_replica_status(::xtreemfs::pbrpc::ReplicaStatus* replica_status) {
  delete replica_status_;
  replica_status_ = replica_status;
  if (replica_status) {
    set_has_replica_status();
  } else {
    clear_has_replica_status();
  }
}

// -------------------------------------------------------------------

// xtreemfs_rwr_reset_statusRequest

// required .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool xtreemfs_rwr_reset_statusRequest::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_reset_statusRequest::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_reset_statusRequest::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_reset_statusRequest::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& xtreemfs_rwr_reset_statusRequest::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_reset_statusRequest::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* xtreemfs_rwr_reset_statusRequest::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_reset_statusRequest::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// required string file_id = 2;
inline bool xtreemfs_rwr_reset_statusRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_reset_statusRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_reset_statusRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_reset_statusRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_rwr_reset_statusRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_rwr_reset_statusRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_reset_statusRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_rwr_reset_statusRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rwr_reset_statusRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_rwr_reset_statusRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rwr_reset_statusRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .xtreemfs.pbrpc.AuthoritativeReplicaState state = 3;
inline bool xtreemfs_rwr_reset_statusRequest::has_state() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_rwr_reset_statusRequest::set_has_state() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_rwr_reset_statusRequest::clear_has_state() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_rwr_reset_statusRequest::clear_state() {
  if (state_ != NULL) state_->::xtreemfs::pbrpc::AuthoritativeReplicaState::Clear();
  clear_has_state();
}
inline const ::xtreemfs::pbrpc::AuthoritativeReplicaState& xtreemfs_rwr_reset_statusRequest::state() const {
  return state_ != NULL ? *state_ : *default_instance_->state_;
}
inline ::xtreemfs::pbrpc::AuthoritativeReplicaState* xtreemfs_rwr_reset_statusRequest::mutable_state() {
  set_has_state();
  if (state_ == NULL) state_ = new ::xtreemfs::pbrpc::AuthoritativeReplicaState;
  return state_;
}
inline ::xtreemfs::pbrpc::AuthoritativeReplicaState* xtreemfs_rwr_reset_statusRequest::release_state() {
  clear_has_state();
  ::xtreemfs::pbrpc::AuthoritativeReplicaState* temp = state_;
  state_ = NULL;
  return temp;
}
inline void xtreemfs_rwr_reset_statusRequest::set_allocated_state(::xtreemfs::pbrpc::AuthoritativeReplicaState* state) {
  delete state_;
  state_ = state;
  if (state) {
    set_has_state();
  } else {
    clear_has_state();
  }
}

// -------------------------------------------------------------------

// xtreemfs_rwr_reset_statusResponse

// required bool running = 1;
inline bool xtreemfs_rwr_reset_statusResponse::has_running() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rwr_reset_statusResponse::set_has_running() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rwr_reset_statusResponse::clear_has_running() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rwr_reset_statusResponse::clear_running() {
  running_ = false;
  clear_has_running();
}
inline bool xtreemfs_rwr_reset_statusResponse::running() const {
  return running_;
}
inline void xtreemfs_rwr_reset_statusResponse::set_running(bool value) {
  set_has_running();
  running_ = value;
}

// required bool complete = 2;
inline bool xtreemfs_rwr_reset_statusResponse::has_complete() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_rwr_reset_statusResponse::set_has_complete() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_rwr_reset_statusResponse::clear_has_complete() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_rwr_reset_statusResponse::clear_complete() {
  complete_ = false;
  clear_has_complete();
}
inline bool xtreemfs_rwr_reset_statusResponse::complete() const {
  return complete_;
}
inline void xtreemfs_rwr_reset_statusResponse::set_complete(bool value) {
  set_has_complete();
  complete_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::OSDHealthResult>() {
  return ::xtreemfs::pbrpc::OSDHealthResult_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xtreemfs_2fOSD_2eproto__INCLUDED
