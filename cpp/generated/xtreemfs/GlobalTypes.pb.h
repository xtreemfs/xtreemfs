// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/GlobalTypes.proto

#ifndef PROTOBUF_xtreemfs_2fGlobalTypes_2eproto__INCLUDED
#define PROTOBUF_xtreemfs_2fGlobalTypes_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "include/PBRPC.pb.h"
#include "include/Common.pb.h"
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

class NewFileSize;
class StripingPolicy;
class Replica;
class Replicas;
class XCap;
class XLocSet;
class FileCredentials;
class FileCredentialsSet;
class VivaldiCoordinates;
class OSDFinalizeVouchersResponse;
class OSDWriteResponse;
class KeyValuePair;

enum AccessControlPolicyType {
  ACCESS_CONTROL_POLICY_NULL = 1,
  ACCESS_CONTROL_POLICY_POSIX = 2,
  ACCESS_CONTROL_POLICY_VOLUME = 3
};
bool AccessControlPolicyType_IsValid(int value);
const AccessControlPolicyType AccessControlPolicyType_MIN = ACCESS_CONTROL_POLICY_NULL;
const AccessControlPolicyType AccessControlPolicyType_MAX = ACCESS_CONTROL_POLICY_VOLUME;
const int AccessControlPolicyType_ARRAYSIZE = AccessControlPolicyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccessControlPolicyType_descriptor();
inline const ::std::string& AccessControlPolicyType_Name(AccessControlPolicyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccessControlPolicyType_descriptor(), value);
}
inline bool AccessControlPolicyType_Parse(
    const ::std::string& name, AccessControlPolicyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccessControlPolicyType>(
    AccessControlPolicyType_descriptor(), name, value);
}
enum OSDSelectionPolicyType {
  OSD_SELECTION_POLICY_FILTER_DEFAULT = 1000,
  OSD_SELECTION_POLICY_FILTER_FQDN = 1001,
  OSD_SELECTION_POLICY_FILTER_UUID = 1002,
  OSD_SELECTION_POLICY_GROUP_DCMAP = 2000,
  OSD_SELECTION_POLICY_GROUP_FQDN = 2001,
  OSD_SELECTION_POLICY_SORT_DCMAP = 3000,
  OSD_SELECTION_POLICY_SORT_FQDN = 3001,
  OSD_SELECTION_POLICY_SORT_RANDOM = 3002,
  OSD_SELECTION_POLICY_SORT_VIVALDI = 3003,
  OSD_SELECTION_POLICY_SORT_HOST_ROUND_ROBIN = 3004,
  OSD_SELECTION_POLICY_SORT_UUID = 3998,
  OSD_SELECTION_POLICY_SORT_REVERSE = 3999
};
bool OSDSelectionPolicyType_IsValid(int value);
const OSDSelectionPolicyType OSDSelectionPolicyType_MIN = OSD_SELECTION_POLICY_FILTER_DEFAULT;
const OSDSelectionPolicyType OSDSelectionPolicyType_MAX = OSD_SELECTION_POLICY_SORT_REVERSE;
const int OSDSelectionPolicyType_ARRAYSIZE = OSDSelectionPolicyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* OSDSelectionPolicyType_descriptor();
inline const ::std::string& OSDSelectionPolicyType_Name(OSDSelectionPolicyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    OSDSelectionPolicyType_descriptor(), value);
}
inline bool OSDSelectionPolicyType_Parse(
    const ::std::string& name, OSDSelectionPolicyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<OSDSelectionPolicyType>(
    OSDSelectionPolicyType_descriptor(), name, value);
}
enum ReplicaSelectionPolicyType {
  REPLICA_SELECTION_POLICY_SIMPLE = 1
};
bool ReplicaSelectionPolicyType_IsValid(int value);
const ReplicaSelectionPolicyType ReplicaSelectionPolicyType_MIN = REPLICA_SELECTION_POLICY_SIMPLE;
const ReplicaSelectionPolicyType ReplicaSelectionPolicyType_MAX = REPLICA_SELECTION_POLICY_SIMPLE;
const int ReplicaSelectionPolicyType_ARRAYSIZE = ReplicaSelectionPolicyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ReplicaSelectionPolicyType_descriptor();
inline const ::std::string& ReplicaSelectionPolicyType_Name(ReplicaSelectionPolicyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ReplicaSelectionPolicyType_descriptor(), value);
}
inline bool ReplicaSelectionPolicyType_Parse(
    const ::std::string& name, ReplicaSelectionPolicyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ReplicaSelectionPolicyType>(
    ReplicaSelectionPolicyType_descriptor(), name, value);
}
enum SnapConfig {
  SNAP_CONFIG_SNAPS_DISABLED = 0,
  SNAP_CONFIG_ACCESS_CURRENT = 1,
  SNAP_CONFIG_ACCESS_SNAP = 2
};
bool SnapConfig_IsValid(int value);
const SnapConfig SnapConfig_MIN = SNAP_CONFIG_SNAPS_DISABLED;
const SnapConfig SnapConfig_MAX = SNAP_CONFIG_ACCESS_SNAP;
const int SnapConfig_ARRAYSIZE = SnapConfig_MAX + 1;

const ::google::protobuf::EnumDescriptor* SnapConfig_descriptor();
inline const ::std::string& SnapConfig_Name(SnapConfig value) {
  return ::google::protobuf::internal::NameOfEnum(
    SnapConfig_descriptor(), value);
}
inline bool SnapConfig_Parse(
    const ::std::string& name, SnapConfig* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SnapConfig>(
    SnapConfig_descriptor(), name, value);
}
enum StripingPolicyType {
  STRIPING_POLICY_RAID0 = 0,
  STRIPING_POLICY_ERASURECODE = 1
};
bool StripingPolicyType_IsValid(int value);
const StripingPolicyType StripingPolicyType_MIN = STRIPING_POLICY_RAID0;
const StripingPolicyType StripingPolicyType_MAX = STRIPING_POLICY_ERASURECODE;
const int StripingPolicyType_ARRAYSIZE = StripingPolicyType_MAX + 1;

const ::google::protobuf::EnumDescriptor* StripingPolicyType_descriptor();
inline const ::std::string& StripingPolicyType_Name(StripingPolicyType value) {
  return ::google::protobuf::internal::NameOfEnum(
    StripingPolicyType_descriptor(), value);
}
inline bool StripingPolicyType_Parse(
    const ::std::string& name, StripingPolicyType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StripingPolicyType>(
    StripingPolicyType_descriptor(), name, value);
}
enum LeaseState {
  NONE = 0,
  PRIMARY = 1,
  BACKUP = 2,
  IDLE = 3
};
bool LeaseState_IsValid(int value);
const LeaseState LeaseState_MIN = NONE;
const LeaseState LeaseState_MAX = IDLE;
const int LeaseState_ARRAYSIZE = LeaseState_MAX + 1;

const ::google::protobuf::EnumDescriptor* LeaseState_descriptor();
inline const ::std::string& LeaseState_Name(LeaseState value) {
  return ::google::protobuf::internal::NameOfEnum(
    LeaseState_descriptor(), value);
}
inline bool LeaseState_Parse(
    const ::std::string& name, LeaseState* value) {
  return ::google::protobuf::internal::ParseNamedEnum<LeaseState>(
    LeaseState_descriptor(), name, value);
}
enum PORTS {
  DIR_HTTP_PORT_DEFAULT = 30638,
  DIR_PBRPC_PORT_DEFAULT = 32638,
  MRC_HTTP_PORT_DEFAULT = 30636,
  MRC_PBRPC_PORT_DEFAULT = 32636,
  OSD_HTTP_PORT_DEFAULT = 30640,
  OSD_PBRPC_PORT_DEFAULT = 32640
};
bool PORTS_IsValid(int value);
const PORTS PORTS_MIN = MRC_HTTP_PORT_DEFAULT;
const PORTS PORTS_MAX = OSD_PBRPC_PORT_DEFAULT;
const int PORTS_ARRAYSIZE = PORTS_MAX + 1;

const ::google::protobuf::EnumDescriptor* PORTS_descriptor();
inline const ::std::string& PORTS_Name(PORTS value) {
  return ::google::protobuf::internal::NameOfEnum(
    PORTS_descriptor(), value);
}
inline bool PORTS_Parse(
    const ::std::string& name, PORTS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<PORTS>(
    PORTS_descriptor(), name, value);
}
enum CONSTANTS {
  XCAP_RENEW_INTERVAL_IN_MIN = 1
};
bool CONSTANTS_IsValid(int value);
const CONSTANTS CONSTANTS_MIN = XCAP_RENEW_INTERVAL_IN_MIN;
const CONSTANTS CONSTANTS_MAX = XCAP_RENEW_INTERVAL_IN_MIN;
const int CONSTANTS_ARRAYSIZE = CONSTANTS_MAX + 1;

const ::google::protobuf::EnumDescriptor* CONSTANTS_descriptor();
inline const ::std::string& CONSTANTS_Name(CONSTANTS value) {
  return ::google::protobuf::internal::NameOfEnum(
    CONSTANTS_descriptor(), value);
}
inline bool CONSTANTS_Parse(
    const ::std::string& name, CONSTANTS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<CONSTANTS>(
    CONSTANTS_descriptor(), name, value);
}
enum SYSTEM_V_FCNTL {
  SYSTEM_V_FCNTL_H_O_RDONLY = 0,
  SYSTEM_V_FCNTL_H_O_WRONLY = 1,
  SYSTEM_V_FCNTL_H_O_RDWR = 2,
  SYSTEM_V_FCNTL_H_O_APPEND = 8,
  SYSTEM_V_FCNTL_H_O_CREAT = 256,
  SYSTEM_V_FCNTL_H_O_TRUNC = 512,
  SYSTEM_V_FCNTL_H_O_EXCL = 1024,
  SYSTEM_V_FCNTL_H_O_SYNC = 16,
  SYSTEM_V_FCNTL_H_S_IFREG = 32768,
  SYSTEM_V_FCNTL_H_S_IFDIR = 16384,
  SYSTEM_V_FCNTL_H_S_IFLNK = 40960,
  SYSTEM_V_FCNTL_H_S_IFIFO = 4096
};
bool SYSTEM_V_FCNTL_IsValid(int value);
const SYSTEM_V_FCNTL SYSTEM_V_FCNTL_MIN = SYSTEM_V_FCNTL_H_O_RDONLY;
const SYSTEM_V_FCNTL SYSTEM_V_FCNTL_MAX = SYSTEM_V_FCNTL_H_S_IFLNK;
const int SYSTEM_V_FCNTL_ARRAYSIZE = SYSTEM_V_FCNTL_MAX + 1;

const ::google::protobuf::EnumDescriptor* SYSTEM_V_FCNTL_descriptor();
inline const ::std::string& SYSTEM_V_FCNTL_Name(SYSTEM_V_FCNTL value) {
  return ::google::protobuf::internal::NameOfEnum(
    SYSTEM_V_FCNTL_descriptor(), value);
}
inline bool SYSTEM_V_FCNTL_Parse(
    const ::std::string& name, SYSTEM_V_FCNTL* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SYSTEM_V_FCNTL>(
    SYSTEM_V_FCNTL_descriptor(), name, value);
}
enum REPL_FLAG {
  REPL_FLAG_FULL_REPLICA = 1,
  REPL_FLAG_IS_COMPLETE = 2,
  REPL_FLAG_STRATEGY_RANDOM = 4,
  REPL_FLAG_STRATEGY_RAREST_FIRST = 8,
  REPL_FLAG_STRATEGY_SEQUENTIAL = 16,
  REPL_FLAG_STRATEGY_SEQUENTIAL_PREFETCHING = 32
};
bool REPL_FLAG_IsValid(int value);
const REPL_FLAG REPL_FLAG_MIN = REPL_FLAG_FULL_REPLICA;
const REPL_FLAG REPL_FLAG_MAX = REPL_FLAG_STRATEGY_SEQUENTIAL_PREFETCHING;
const int REPL_FLAG_ARRAYSIZE = REPL_FLAG_MAX + 1;

const ::google::protobuf::EnumDescriptor* REPL_FLAG_descriptor();
inline const ::std::string& REPL_FLAG_Name(REPL_FLAG value) {
  return ::google::protobuf::internal::NameOfEnum(
    REPL_FLAG_descriptor(), value);
}
inline bool REPL_FLAG_Parse(
    const ::std::string& name, REPL_FLAG* value) {
  return ::google::protobuf::internal::ParseNamedEnum<REPL_FLAG>(
    REPL_FLAG_descriptor(), name, value);
}
enum SERVICES {
  DIR = 1,
  MRC = 2,
  OSD = 3
};
bool SERVICES_IsValid(int value);
const SERVICES SERVICES_MIN = DIR;
const SERVICES SERVICES_MAX = OSD;
const int SERVICES_ARRAYSIZE = SERVICES_MAX + 1;

const ::google::protobuf::EnumDescriptor* SERVICES_descriptor();
inline const ::std::string& SERVICES_Name(SERVICES value) {
  return ::google::protobuf::internal::NameOfEnum(
    SERVICES_descriptor(), value);
}
inline bool SERVICES_Parse(
    const ::std::string& name, SERVICES* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SERVICES>(
    SERVICES_descriptor(), name, value);
}
// ===================================================================

class NewFileSize : public ::google::protobuf::Message {
 public:
  NewFileSize();
  virtual ~NewFileSize();

  NewFileSize(const NewFileSize& from);

  inline NewFileSize& operator=(const NewFileSize& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NewFileSize& default_instance();

  void Swap(NewFileSize* other);

  // implements Message ----------------------------------------------

  NewFileSize* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NewFileSize& from);
  void MergeFrom(const NewFileSize& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 size_in_bytes = 1;
  inline bool has_size_in_bytes() const;
  inline void clear_size_in_bytes();
  static const int kSizeInBytesFieldNumber = 1;
  inline ::google::protobuf::uint64 size_in_bytes() const;
  inline void set_size_in_bytes(::google::protobuf::uint64 value);

  // required fixed32 truncate_epoch = 2;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 2;
  inline ::google::protobuf::uint32 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.NewFileSize)
 private:
  inline void set_has_size_in_bytes();
  inline void clear_has_size_in_bytes();
  inline void set_has_truncate_epoch();
  inline void clear_has_truncate_epoch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 size_in_bytes_;
  ::google::protobuf::uint32 truncate_epoch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static NewFileSize* default_instance_;
};
// -------------------------------------------------------------------

class StripingPolicy : public ::google::protobuf::Message {
 public:
  StripingPolicy();
  virtual ~StripingPolicy();

  StripingPolicy(const StripingPolicy& from);

  inline StripingPolicy& operator=(const StripingPolicy& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StripingPolicy& default_instance();

  void Swap(StripingPolicy* other);

  // implements Message ----------------------------------------------

  StripingPolicy* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StripingPolicy& from);
  void MergeFrom(const StripingPolicy& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.StripingPolicyType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::xtreemfs::pbrpc::StripingPolicyType type() const;
  inline void set_type(::xtreemfs::pbrpc::StripingPolicyType value);

  // required fixed32 stripe_size = 2;
  inline bool has_stripe_size() const;
  inline void clear_stripe_size();
  static const int kStripeSizeFieldNumber = 2;
  inline ::google::protobuf::uint32 stripe_size() const;
  inline void set_stripe_size(::google::protobuf::uint32 value);

  // required fixed32 width = 3;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 3;
  inline ::google::protobuf::uint32 width() const;
  inline void set_width(::google::protobuf::uint32 value);

  // optional fixed32 parity_width = 4;
  inline bool has_parity_width() const;
  inline void clear_parity_width();
  static const int kParityWidthFieldNumber = 4;
  inline ::google::protobuf::uint32 parity_width() const;
  inline void set_parity_width(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.StripingPolicy)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_stripe_size();
  inline void clear_has_stripe_size();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_parity_width();
  inline void clear_has_parity_width();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::uint32 stripe_size_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::uint32 parity_width_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static StripingPolicy* default_instance_;
};
// -------------------------------------------------------------------

class Replica : public ::google::protobuf::Message {
 public:
  Replica();
  virtual ~Replica();

  Replica(const Replica& from);

  inline Replica& operator=(const Replica& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Replica& default_instance();

  void Swap(Replica* other);

  // implements Message ----------------------------------------------

  Replica* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Replica& from);
  void MergeFrom(const Replica& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string osd_uuids = 1;
  inline int osd_uuids_size() const;
  inline void clear_osd_uuids();
  static const int kOsdUuidsFieldNumber = 1;
  inline const ::std::string& osd_uuids(int index) const;
  inline ::std::string* mutable_osd_uuids(int index);
  inline void set_osd_uuids(int index, const ::std::string& value);
  inline void set_osd_uuids(int index, const char* value);
  inline void set_osd_uuids(int index, const char* value, size_t size);
  inline ::std::string* add_osd_uuids();
  inline void add_osd_uuids(const ::std::string& value);
  inline void add_osd_uuids(const char* value);
  inline void add_osd_uuids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& osd_uuids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_osd_uuids();

  // required fixed32 replication_flags = 2;
  inline bool has_replication_flags() const;
  inline void clear_replication_flags();
  static const int kReplicationFlagsFieldNumber = 2;
  inline ::google::protobuf::uint32 replication_flags() const;
  inline void set_replication_flags(::google::protobuf::uint32 value);

  // required .xtreemfs.pbrpc.StripingPolicy striping_policy = 3;
  inline bool has_striping_policy() const;
  inline void clear_striping_policy();
  static const int kStripingPolicyFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::StripingPolicy& striping_policy() const;
  inline ::xtreemfs::pbrpc::StripingPolicy* mutable_striping_policy();
  inline ::xtreemfs::pbrpc::StripingPolicy* release_striping_policy();
  inline void set_allocated_striping_policy(::xtreemfs::pbrpc::StripingPolicy* striping_policy);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Replica)
 private:
  inline void set_has_replication_flags();
  inline void clear_has_replication_flags();
  inline void set_has_striping_policy();
  inline void clear_has_striping_policy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> osd_uuids_;
  ::xtreemfs::pbrpc::StripingPolicy* striping_policy_;
  ::google::protobuf::uint32 replication_flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static Replica* default_instance_;
};
// -------------------------------------------------------------------

class Replicas : public ::google::protobuf::Message {
 public:
  Replicas();
  virtual ~Replicas();

  Replicas(const Replicas& from);

  inline Replicas& operator=(const Replicas& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Replicas& default_instance();

  void Swap(Replicas* other);

  // implements Message ----------------------------------------------

  Replicas* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Replicas& from);
  void MergeFrom(const Replicas& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.Replica replicas = 1;
  inline int replicas_size() const;
  inline void clear_replicas();
  static const int kReplicasFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Replica& replicas(int index) const;
  inline ::xtreemfs::pbrpc::Replica* mutable_replicas(int index);
  inline ::xtreemfs::pbrpc::Replica* add_replicas();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica >&
      replicas() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica >*
      mutable_replicas();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Replicas)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica > replicas_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static Replicas* default_instance_;
};
// -------------------------------------------------------------------

class XCap : public ::google::protobuf::Message {
 public:
  XCap();
  virtual ~XCap();

  XCap(const XCap& from);

  inline XCap& operator=(const XCap& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XCap& default_instance();

  void Swap(XCap* other);

  // implements Message ----------------------------------------------

  XCap* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XCap& from);
  void MergeFrom(const XCap& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 access_mode = 1;
  inline bool has_access_mode() const;
  inline void clear_access_mode();
  static const int kAccessModeFieldNumber = 1;
  inline ::google::protobuf::uint32 access_mode() const;
  inline void set_access_mode(::google::protobuf::uint32 value);

  // required string client_identity = 2;
  inline bool has_client_identity() const;
  inline void clear_client_identity();
  static const int kClientIdentityFieldNumber = 2;
  inline const ::std::string& client_identity() const;
  inline void set_client_identity(const ::std::string& value);
  inline void set_client_identity(const char* value);
  inline void set_client_identity(const char* value, size_t size);
  inline ::std::string* mutable_client_identity();
  inline ::std::string* release_client_identity();
  inline void set_allocated_client_identity(::std::string* client_identity);

  // required fixed64 expire_time_s = 3;
  inline bool has_expire_time_s() const;
  inline void clear_expire_time_s();
  static const int kExpireTimeSFieldNumber = 3;
  inline ::google::protobuf::uint64 expire_time_s() const;
  inline void set_expire_time_s(::google::protobuf::uint64 value);

  // required fixed32 expire_timeout_s = 4;
  inline bool has_expire_timeout_s() const;
  inline void clear_expire_timeout_s();
  static const int kExpireTimeoutSFieldNumber = 4;
  inline ::google::protobuf::uint32 expire_timeout_s() const;
  inline void set_expire_timeout_s(::google::protobuf::uint32 value);

  // required string file_id = 5;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 5;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required bool replicate_on_close = 6;
  inline bool has_replicate_on_close() const;
  inline void clear_replicate_on_close();
  static const int kReplicateOnCloseFieldNumber = 6;
  inline bool replicate_on_close() const;
  inline void set_replicate_on_close(bool value);

  // required string server_signature = 7;
  inline bool has_server_signature() const;
  inline void clear_server_signature();
  static const int kServerSignatureFieldNumber = 7;
  inline const ::std::string& server_signature() const;
  inline void set_server_signature(const ::std::string& value);
  inline void set_server_signature(const char* value);
  inline void set_server_signature(const char* value, size_t size);
  inline ::std::string* mutable_server_signature();
  inline ::std::string* release_server_signature();
  inline void set_allocated_server_signature(::std::string* server_signature);

  // required fixed32 truncate_epoch = 8;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 8;
  inline ::google::protobuf::uint32 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint32 value);

  // required .xtreemfs.pbrpc.SnapConfig snap_config = 9;
  inline bool has_snap_config() const;
  inline void clear_snap_config();
  static const int kSnapConfigFieldNumber = 9;
  inline ::xtreemfs::pbrpc::SnapConfig snap_config() const;
  inline void set_snap_config(::xtreemfs::pbrpc::SnapConfig value);

  // required fixed64 snap_timestamp = 10;
  inline bool has_snap_timestamp() const;
  inline void clear_snap_timestamp();
  static const int kSnapTimestampFieldNumber = 10;
  inline ::google::protobuf::uint64 snap_timestamp() const;
  inline void set_snap_timestamp(::google::protobuf::uint64 value);

  // optional fixed64 voucher_size = 11 [default = 0];
  inline bool has_voucher_size() const;
  inline void clear_voucher_size();
  static const int kVoucherSizeFieldNumber = 11;
  inline ::google::protobuf::uint64 voucher_size() const;
  inline void set_voucher_size(::google::protobuf::uint64 value);

  // optional fixed64 expire_time_ms = 12 [default = 0];
  inline bool has_expire_time_ms() const;
  inline void clear_expire_time_ms();
  static const int kExpireTimeMsFieldNumber = 12;
  inline ::google::protobuf::uint64 expire_time_ms() const;
  inline void set_expire_time_ms(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.XCap)
 private:
  inline void set_has_access_mode();
  inline void clear_has_access_mode();
  inline void set_has_client_identity();
  inline void clear_has_client_identity();
  inline void set_has_expire_time_s();
  inline void clear_has_expire_time_s();
  inline void set_has_expire_timeout_s();
  inline void clear_has_expire_timeout_s();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_replicate_on_close();
  inline void clear_has_replicate_on_close();
  inline void set_has_server_signature();
  inline void clear_has_server_signature();
  inline void set_has_truncate_epoch();
  inline void clear_has_truncate_epoch();
  inline void set_has_snap_config();
  inline void clear_has_snap_config();
  inline void set_has_snap_timestamp();
  inline void clear_has_snap_timestamp();
  inline void set_has_voucher_size();
  inline void clear_has_voucher_size();
  inline void set_has_expire_time_ms();
  inline void clear_has_expire_time_ms();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* client_identity_;
  ::google::protobuf::uint32 access_mode_;
  ::google::protobuf::uint32 expire_timeout_s_;
  ::google::protobuf::uint64 expire_time_s_;
  ::std::string* file_id_;
  ::std::string* server_signature_;
  bool replicate_on_close_;
  ::google::protobuf::uint32 truncate_epoch_;
  ::google::protobuf::uint64 snap_timestamp_;
  ::google::protobuf::uint64 voucher_size_;
  ::google::protobuf::uint64 expire_time_ms_;
  int snap_config_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(12 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static XCap* default_instance_;
};
// -------------------------------------------------------------------

class XLocSet : public ::google::protobuf::Message {
 public:
  XLocSet();
  virtual ~XLocSet();

  XLocSet(const XLocSet& from);

  inline XLocSet& operator=(const XLocSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XLocSet& default_instance();

  void Swap(XLocSet* other);

  // implements Message ----------------------------------------------

  XLocSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XLocSet& from);
  void MergeFrom(const XLocSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 read_only_file_size = 1;
  inline bool has_read_only_file_size() const;
  inline void clear_read_only_file_size();
  static const int kReadOnlyFileSizeFieldNumber = 1;
  inline ::google::protobuf::uint64 read_only_file_size() const;
  inline void set_read_only_file_size(::google::protobuf::uint64 value);

  // repeated .xtreemfs.pbrpc.Replica replicas = 2;
  inline int replicas_size() const;
  inline void clear_replicas();
  static const int kReplicasFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::Replica& replicas(int index) const;
  inline ::xtreemfs::pbrpc::Replica* mutable_replicas(int index);
  inline ::xtreemfs::pbrpc::Replica* add_replicas();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica >&
      replicas() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica >*
      mutable_replicas();

  // required string replica_update_policy = 3;
  inline bool has_replica_update_policy() const;
  inline void clear_replica_update_policy();
  static const int kReplicaUpdatePolicyFieldNumber = 3;
  inline const ::std::string& replica_update_policy() const;
  inline void set_replica_update_policy(const ::std::string& value);
  inline void set_replica_update_policy(const char* value);
  inline void set_replica_update_policy(const char* value, size_t size);
  inline ::std::string* mutable_replica_update_policy();
  inline ::std::string* release_replica_update_policy();
  inline void set_allocated_replica_update_policy(::std::string* replica_update_policy);

  // required fixed32 version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.XLocSet)
 private:
  inline void set_has_read_only_file_size();
  inline void clear_has_read_only_file_size();
  inline void set_has_replica_update_policy();
  inline void clear_has_replica_update_policy();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 read_only_file_size_;
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica > replicas_;
  ::std::string* replica_update_policy_;
  ::google::protobuf::uint32 version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static XLocSet* default_instance_;
};
// -------------------------------------------------------------------

class FileCredentials : public ::google::protobuf::Message {
 public:
  FileCredentials();
  virtual ~FileCredentials();

  FileCredentials(const FileCredentials& from);

  inline FileCredentials& operator=(const FileCredentials& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileCredentials& default_instance();

  void Swap(FileCredentials* other);

  // implements Message ----------------------------------------------

  FileCredentials* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileCredentials& from);
  void MergeFrom(const FileCredentials& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.XCap xcap = 1;
  inline bool has_xcap() const;
  inline void clear_xcap();
  static const int kXcapFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::XCap& xcap() const;
  inline ::xtreemfs::pbrpc::XCap* mutable_xcap();
  inline ::xtreemfs::pbrpc::XCap* release_xcap();
  inline void set_allocated_xcap(::xtreemfs::pbrpc::XCap* xcap);

  // required .xtreemfs.pbrpc.XLocSet xlocs = 2;
  inline bool has_xlocs() const;
  inline void clear_xlocs();
  static const int kXlocsFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::XLocSet& xlocs() const;
  inline ::xtreemfs::pbrpc::XLocSet* mutable_xlocs();
  inline ::xtreemfs::pbrpc::XLocSet* release_xlocs();
  inline void set_allocated_xlocs(::xtreemfs::pbrpc::XLocSet* xlocs);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.FileCredentials)
 private:
  inline void set_has_xcap();
  inline void clear_has_xcap();
  inline void set_has_xlocs();
  inline void clear_has_xlocs();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::XCap* xcap_;
  ::xtreemfs::pbrpc::XLocSet* xlocs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static FileCredentials* default_instance_;
};
// -------------------------------------------------------------------

class FileCredentialsSet : public ::google::protobuf::Message {
 public:
  FileCredentialsSet();
  virtual ~FileCredentialsSet();

  FileCredentialsSet(const FileCredentialsSet& from);

  inline FileCredentialsSet& operator=(const FileCredentialsSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const FileCredentialsSet& default_instance();

  void Swap(FileCredentialsSet* other);

  // implements Message ----------------------------------------------

  FileCredentialsSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const FileCredentialsSet& from);
  void MergeFrom(const FileCredentialsSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  inline bool has_file_credentials() const;
  inline void clear_file_credentials();
  static const int kFileCredentialsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& file_credentials() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_file_credentials();
  inline ::xtreemfs::pbrpc::FileCredentials* release_file_credentials();
  inline void set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.FileCredentialsSet)
 private:
  inline void set_has_file_credentials();
  inline void clear_has_file_credentials();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* file_credentials_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static FileCredentialsSet* default_instance_;
};
// -------------------------------------------------------------------

class VivaldiCoordinates : public ::google::protobuf::Message {
 public:
  VivaldiCoordinates();
  virtual ~VivaldiCoordinates();

  VivaldiCoordinates(const VivaldiCoordinates& from);

  inline VivaldiCoordinates& operator=(const VivaldiCoordinates& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VivaldiCoordinates& default_instance();

  void Swap(VivaldiCoordinates* other);

  // implements Message ----------------------------------------------

  VivaldiCoordinates* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VivaldiCoordinates& from);
  void MergeFrom(const VivaldiCoordinates& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required double x_coordinate = 1;
  inline bool has_x_coordinate() const;
  inline void clear_x_coordinate();
  static const int kXCoordinateFieldNumber = 1;
  inline double x_coordinate() const;
  inline void set_x_coordinate(double value);

  // required double y_coordinate = 2;
  inline bool has_y_coordinate() const;
  inline void clear_y_coordinate();
  static const int kYCoordinateFieldNumber = 2;
  inline double y_coordinate() const;
  inline void set_y_coordinate(double value);

  // required double local_error = 3;
  inline bool has_local_error() const;
  inline void clear_local_error();
  static const int kLocalErrorFieldNumber = 3;
  inline double local_error() const;
  inline void set_local_error(double value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.VivaldiCoordinates)
 private:
  inline void set_has_x_coordinate();
  inline void clear_has_x_coordinate();
  inline void set_has_y_coordinate();
  inline void clear_has_y_coordinate();
  inline void set_has_local_error();
  inline void clear_has_local_error();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  double x_coordinate_;
  double y_coordinate_;
  double local_error_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static VivaldiCoordinates* default_instance_;
};
// -------------------------------------------------------------------

class OSDFinalizeVouchersResponse : public ::google::protobuf::Message {
 public:
  OSDFinalizeVouchersResponse();
  virtual ~OSDFinalizeVouchersResponse();

  OSDFinalizeVouchersResponse(const OSDFinalizeVouchersResponse& from);

  inline OSDFinalizeVouchersResponse& operator=(const OSDFinalizeVouchersResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OSDFinalizeVouchersResponse& default_instance();

  void Swap(OSDFinalizeVouchersResponse* other);

  // implements Message ----------------------------------------------

  OSDFinalizeVouchersResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OSDFinalizeVouchersResponse& from);
  void MergeFrom(const OSDFinalizeVouchersResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string osd_uuid = 1;
  inline bool has_osd_uuid() const;
  inline void clear_osd_uuid();
  static const int kOsdUuidFieldNumber = 1;
  inline const ::std::string& osd_uuid() const;
  inline void set_osd_uuid(const ::std::string& value);
  inline void set_osd_uuid(const char* value);
  inline void set_osd_uuid(const char* value, size_t size);
  inline ::std::string* mutable_osd_uuid();
  inline ::std::string* release_osd_uuid();
  inline void set_allocated_osd_uuid(::std::string* osd_uuid);

  // required string server_signature = 2;
  inline bool has_server_signature() const;
  inline void clear_server_signature();
  static const int kServerSignatureFieldNumber = 2;
  inline const ::std::string& server_signature() const;
  inline void set_server_signature(const ::std::string& value);
  inline void set_server_signature(const char* value);
  inline void set_server_signature(const char* value, size_t size);
  inline ::std::string* mutable_server_signature();
  inline ::std::string* release_server_signature();
  inline void set_allocated_server_signature(::std::string* server_signature);

  // required fixed64 size_in_bytes = 3;
  inline bool has_size_in_bytes() const;
  inline void clear_size_in_bytes();
  static const int kSizeInBytesFieldNumber = 3;
  inline ::google::protobuf::uint64 size_in_bytes() const;
  inline void set_size_in_bytes(::google::protobuf::uint64 value);

  // required fixed64 truncate_epoch = 4;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 4;
  inline ::google::protobuf::uint64 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.OSDFinalizeVouchersResponse)
 private:
  inline void set_has_osd_uuid();
  inline void clear_has_osd_uuid();
  inline void set_has_server_signature();
  inline void clear_has_server_signature();
  inline void set_has_size_in_bytes();
  inline void clear_has_size_in_bytes();
  inline void set_has_truncate_epoch();
  inline void clear_has_truncate_epoch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* osd_uuid_;
  ::std::string* server_signature_;
  ::google::protobuf::uint64 size_in_bytes_;
  ::google::protobuf::uint64 truncate_epoch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static OSDFinalizeVouchersResponse* default_instance_;
};
// -------------------------------------------------------------------

class OSDWriteResponse : public ::google::protobuf::Message {
 public:
  OSDWriteResponse();
  virtual ~OSDWriteResponse();

  OSDWriteResponse(const OSDWriteResponse& from);

  inline OSDWriteResponse& operator=(const OSDWriteResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OSDWriteResponse& default_instance();

  void Swap(OSDWriteResponse* other);

  // implements Message ----------------------------------------------

  OSDWriteResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OSDWriteResponse& from);
  void MergeFrom(const OSDWriteResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional fixed64 size_in_bytes = 1;
  inline bool has_size_in_bytes() const;
  inline void clear_size_in_bytes();
  static const int kSizeInBytesFieldNumber = 1;
  inline ::google::protobuf::uint64 size_in_bytes() const;
  inline void set_size_in_bytes(::google::protobuf::uint64 value);

  // optional fixed32 truncate_epoch = 2;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 2;
  inline ::google::protobuf::uint32 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.OSDWriteResponse)
 private:
  inline void set_has_size_in_bytes();
  inline void clear_has_size_in_bytes();
  inline void set_has_truncate_epoch();
  inline void clear_has_truncate_epoch();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 size_in_bytes_;
  ::google::protobuf::uint32 truncate_epoch_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static OSDWriteResponse* default_instance_;
};
// -------------------------------------------------------------------

class KeyValuePair : public ::google::protobuf::Message {
 public:
  KeyValuePair();
  virtual ~KeyValuePair();

  KeyValuePair(const KeyValuePair& from);

  inline KeyValuePair& operator=(const KeyValuePair& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const KeyValuePair& default_instance();

  void Swap(KeyValuePair* other);

  // implements Message ----------------------------------------------

  KeyValuePair* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const KeyValuePair& from);
  void MergeFrom(const KeyValuePair& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string key = 1;
  inline bool has_key() const;
  inline void clear_key();
  static const int kKeyFieldNumber = 1;
  inline const ::std::string& key() const;
  inline void set_key(const ::std::string& value);
  inline void set_key(const char* value);
  inline void set_key(const char* value, size_t size);
  inline ::std::string* mutable_key();
  inline ::std::string* release_key();
  inline void set_allocated_key(::std::string* key);

  // required string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.KeyValuePair)
 private:
  inline void set_has_key();
  inline void clear_has_key();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* key_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto();

  void InitAsDefaultInstance();
  static KeyValuePair* default_instance_;
};
// ===================================================================


// ===================================================================

// NewFileSize

// required fixed64 size_in_bytes = 1;
inline bool NewFileSize::has_size_in_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NewFileSize::set_has_size_in_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NewFileSize::clear_has_size_in_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NewFileSize::clear_size_in_bytes() {
  size_in_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_size_in_bytes();
}
inline ::google::protobuf::uint64 NewFileSize::size_in_bytes() const {
  return size_in_bytes_;
}
inline void NewFileSize::set_size_in_bytes(::google::protobuf::uint64 value) {
  set_has_size_in_bytes();
  size_in_bytes_ = value;
}

// required fixed32 truncate_epoch = 2;
inline bool NewFileSize::has_truncate_epoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NewFileSize::set_has_truncate_epoch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NewFileSize::clear_has_truncate_epoch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NewFileSize::clear_truncate_epoch() {
  truncate_epoch_ = 0u;
  clear_has_truncate_epoch();
}
inline ::google::protobuf::uint32 NewFileSize::truncate_epoch() const {
  return truncate_epoch_;
}
inline void NewFileSize::set_truncate_epoch(::google::protobuf::uint32 value) {
  set_has_truncate_epoch();
  truncate_epoch_ = value;
}

// -------------------------------------------------------------------

// StripingPolicy

// required .xtreemfs.pbrpc.StripingPolicyType type = 1;
inline bool StripingPolicy::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StripingPolicy::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StripingPolicy::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StripingPolicy::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::xtreemfs::pbrpc::StripingPolicyType StripingPolicy::type() const {
  return static_cast< ::xtreemfs::pbrpc::StripingPolicyType >(type_);
}
inline void StripingPolicy::set_type(::xtreemfs::pbrpc::StripingPolicyType value) {
  assert(::xtreemfs::pbrpc::StripingPolicyType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required fixed32 stripe_size = 2;
inline bool StripingPolicy::has_stripe_size() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StripingPolicy::set_has_stripe_size() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StripingPolicy::clear_has_stripe_size() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StripingPolicy::clear_stripe_size() {
  stripe_size_ = 0u;
  clear_has_stripe_size();
}
inline ::google::protobuf::uint32 StripingPolicy::stripe_size() const {
  return stripe_size_;
}
inline void StripingPolicy::set_stripe_size(::google::protobuf::uint32 value) {
  set_has_stripe_size();
  stripe_size_ = value;
}

// required fixed32 width = 3;
inline bool StripingPolicy::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StripingPolicy::set_has_width() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StripingPolicy::clear_has_width() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StripingPolicy::clear_width() {
  width_ = 0u;
  clear_has_width();
}
inline ::google::protobuf::uint32 StripingPolicy::width() const {
  return width_;
}
inline void StripingPolicy::set_width(::google::protobuf::uint32 value) {
  set_has_width();
  width_ = value;
}

// optional fixed32 parity_width = 4;
inline bool StripingPolicy::has_parity_width() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StripingPolicy::set_has_parity_width() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StripingPolicy::clear_has_parity_width() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StripingPolicy::clear_parity_width() {
  parity_width_ = 0u;
  clear_has_parity_width();
}
inline ::google::protobuf::uint32 StripingPolicy::parity_width() const {
  return parity_width_;
}
inline void StripingPolicy::set_parity_width(::google::protobuf::uint32 value) {
  set_has_parity_width();
  parity_width_ = value;
}

// -------------------------------------------------------------------

// Replica

// repeated string osd_uuids = 1;
inline int Replica::osd_uuids_size() const {
  return osd_uuids_.size();
}
inline void Replica::clear_osd_uuids() {
  osd_uuids_.Clear();
}
inline const ::std::string& Replica::osd_uuids(int index) const {
  return osd_uuids_.Get(index);
}
inline ::std::string* Replica::mutable_osd_uuids(int index) {
  return osd_uuids_.Mutable(index);
}
inline void Replica::set_osd_uuids(int index, const ::std::string& value) {
  osd_uuids_.Mutable(index)->assign(value);
}
inline void Replica::set_osd_uuids(int index, const char* value) {
  osd_uuids_.Mutable(index)->assign(value);
}
inline void Replica::set_osd_uuids(int index, const char* value, size_t size) {
  osd_uuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Replica::add_osd_uuids() {
  return osd_uuids_.Add();
}
inline void Replica::add_osd_uuids(const ::std::string& value) {
  osd_uuids_.Add()->assign(value);
}
inline void Replica::add_osd_uuids(const char* value) {
  osd_uuids_.Add()->assign(value);
}
inline void Replica::add_osd_uuids(const char* value, size_t size) {
  osd_uuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Replica::osd_uuids() const {
  return osd_uuids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Replica::mutable_osd_uuids() {
  return &osd_uuids_;
}

// required fixed32 replication_flags = 2;
inline bool Replica::has_replication_flags() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Replica::set_has_replication_flags() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Replica::clear_has_replication_flags() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Replica::clear_replication_flags() {
  replication_flags_ = 0u;
  clear_has_replication_flags();
}
inline ::google::protobuf::uint32 Replica::replication_flags() const {
  return replication_flags_;
}
inline void Replica::set_replication_flags(::google::protobuf::uint32 value) {
  set_has_replication_flags();
  replication_flags_ = value;
}

// required .xtreemfs.pbrpc.StripingPolicy striping_policy = 3;
inline bool Replica::has_striping_policy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Replica::set_has_striping_policy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Replica::clear_has_striping_policy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Replica::clear_striping_policy() {
  if (striping_policy_ != NULL) striping_policy_->::xtreemfs::pbrpc::StripingPolicy::Clear();
  clear_has_striping_policy();
}
inline const ::xtreemfs::pbrpc::StripingPolicy& Replica::striping_policy() const {
  return striping_policy_ != NULL ? *striping_policy_ : *default_instance_->striping_policy_;
}
inline ::xtreemfs::pbrpc::StripingPolicy* Replica::mutable_striping_policy() {
  set_has_striping_policy();
  if (striping_policy_ == NULL) striping_policy_ = new ::xtreemfs::pbrpc::StripingPolicy;
  return striping_policy_;
}
inline ::xtreemfs::pbrpc::StripingPolicy* Replica::release_striping_policy() {
  clear_has_striping_policy();
  ::xtreemfs::pbrpc::StripingPolicy* temp = striping_policy_;
  striping_policy_ = NULL;
  return temp;
}
inline void Replica::set_allocated_striping_policy(::xtreemfs::pbrpc::StripingPolicy* striping_policy) {
  delete striping_policy_;
  striping_policy_ = striping_policy;
  if (striping_policy) {
    set_has_striping_policy();
  } else {
    clear_has_striping_policy();
  }
}

// -------------------------------------------------------------------

// Replicas

// repeated .xtreemfs.pbrpc.Replica replicas = 1;
inline int Replicas::replicas_size() const {
  return replicas_.size();
}
inline void Replicas::clear_replicas() {
  replicas_.Clear();
}
inline const ::xtreemfs::pbrpc::Replica& Replicas::replicas(int index) const {
  return replicas_.Get(index);
}
inline ::xtreemfs::pbrpc::Replica* Replicas::mutable_replicas(int index) {
  return replicas_.Mutable(index);
}
inline ::xtreemfs::pbrpc::Replica* Replicas::add_replicas() {
  return replicas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica >&
Replicas::replicas() const {
  return replicas_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica >*
Replicas::mutable_replicas() {
  return &replicas_;
}

// -------------------------------------------------------------------

// XCap

// required fixed32 access_mode = 1;
inline bool XCap::has_access_mode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XCap::set_has_access_mode() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XCap::clear_has_access_mode() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XCap::clear_access_mode() {
  access_mode_ = 0u;
  clear_has_access_mode();
}
inline ::google::protobuf::uint32 XCap::access_mode() const {
  return access_mode_;
}
inline void XCap::set_access_mode(::google::protobuf::uint32 value) {
  set_has_access_mode();
  access_mode_ = value;
}

// required string client_identity = 2;
inline bool XCap::has_client_identity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XCap::set_has_client_identity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XCap::clear_has_client_identity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XCap::clear_client_identity() {
  if (client_identity_ != &::google::protobuf::internal::kEmptyString) {
    client_identity_->clear();
  }
  clear_has_client_identity();
}
inline const ::std::string& XCap::client_identity() const {
  return *client_identity_;
}
inline void XCap::set_client_identity(const ::std::string& value) {
  set_has_client_identity();
  if (client_identity_ == &::google::protobuf::internal::kEmptyString) {
    client_identity_ = new ::std::string;
  }
  client_identity_->assign(value);
}
inline void XCap::set_client_identity(const char* value) {
  set_has_client_identity();
  if (client_identity_ == &::google::protobuf::internal::kEmptyString) {
    client_identity_ = new ::std::string;
  }
  client_identity_->assign(value);
}
inline void XCap::set_client_identity(const char* value, size_t size) {
  set_has_client_identity();
  if (client_identity_ == &::google::protobuf::internal::kEmptyString) {
    client_identity_ = new ::std::string;
  }
  client_identity_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XCap::mutable_client_identity() {
  set_has_client_identity();
  if (client_identity_ == &::google::protobuf::internal::kEmptyString) {
    client_identity_ = new ::std::string;
  }
  return client_identity_;
}
inline ::std::string* XCap::release_client_identity() {
  clear_has_client_identity();
  if (client_identity_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = client_identity_;
    client_identity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XCap::set_allocated_client_identity(::std::string* client_identity) {
  if (client_identity_ != &::google::protobuf::internal::kEmptyString) {
    delete client_identity_;
  }
  if (client_identity) {
    set_has_client_identity();
    client_identity_ = client_identity;
  } else {
    clear_has_client_identity();
    client_identity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 expire_time_s = 3;
inline bool XCap::has_expire_time_s() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XCap::set_has_expire_time_s() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XCap::clear_has_expire_time_s() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XCap::clear_expire_time_s() {
  expire_time_s_ = GOOGLE_ULONGLONG(0);
  clear_has_expire_time_s();
}
inline ::google::protobuf::uint64 XCap::expire_time_s() const {
  return expire_time_s_;
}
inline void XCap::set_expire_time_s(::google::protobuf::uint64 value) {
  set_has_expire_time_s();
  expire_time_s_ = value;
}

// required fixed32 expire_timeout_s = 4;
inline bool XCap::has_expire_timeout_s() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XCap::set_has_expire_timeout_s() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XCap::clear_has_expire_timeout_s() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XCap::clear_expire_timeout_s() {
  expire_timeout_s_ = 0u;
  clear_has_expire_timeout_s();
}
inline ::google::protobuf::uint32 XCap::expire_timeout_s() const {
  return expire_timeout_s_;
}
inline void XCap::set_expire_timeout_s(::google::protobuf::uint32 value) {
  set_has_expire_timeout_s();
  expire_timeout_s_ = value;
}

// required string file_id = 5;
inline bool XCap::has_file_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void XCap::set_has_file_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void XCap::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void XCap::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& XCap::file_id() const {
  return *file_id_;
}
inline void XCap::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void XCap::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void XCap::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XCap::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* XCap::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XCap::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool replicate_on_close = 6;
inline bool XCap::has_replicate_on_close() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void XCap::set_has_replicate_on_close() {
  _has_bits_[0] |= 0x00000020u;
}
inline void XCap::clear_has_replicate_on_close() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void XCap::clear_replicate_on_close() {
  replicate_on_close_ = false;
  clear_has_replicate_on_close();
}
inline bool XCap::replicate_on_close() const {
  return replicate_on_close_;
}
inline void XCap::set_replicate_on_close(bool value) {
  set_has_replicate_on_close();
  replicate_on_close_ = value;
}

// required string server_signature = 7;
inline bool XCap::has_server_signature() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void XCap::set_has_server_signature() {
  _has_bits_[0] |= 0x00000040u;
}
inline void XCap::clear_has_server_signature() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void XCap::clear_server_signature() {
  if (server_signature_ != &::google::protobuf::internal::kEmptyString) {
    server_signature_->clear();
  }
  clear_has_server_signature();
}
inline const ::std::string& XCap::server_signature() const {
  return *server_signature_;
}
inline void XCap::set_server_signature(const ::std::string& value) {
  set_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    server_signature_ = new ::std::string;
  }
  server_signature_->assign(value);
}
inline void XCap::set_server_signature(const char* value) {
  set_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    server_signature_ = new ::std::string;
  }
  server_signature_->assign(value);
}
inline void XCap::set_server_signature(const char* value, size_t size) {
  set_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    server_signature_ = new ::std::string;
  }
  server_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XCap::mutable_server_signature() {
  set_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    server_signature_ = new ::std::string;
  }
  return server_signature_;
}
inline ::std::string* XCap::release_server_signature() {
  clear_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_signature_;
    server_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XCap::set_allocated_server_signature(::std::string* server_signature) {
  if (server_signature_ != &::google::protobuf::internal::kEmptyString) {
    delete server_signature_;
  }
  if (server_signature) {
    set_has_server_signature();
    server_signature_ = server_signature;
  } else {
    clear_has_server_signature();
    server_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 truncate_epoch = 8;
inline bool XCap::has_truncate_epoch() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void XCap::set_has_truncate_epoch() {
  _has_bits_[0] |= 0x00000080u;
}
inline void XCap::clear_has_truncate_epoch() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void XCap::clear_truncate_epoch() {
  truncate_epoch_ = 0u;
  clear_has_truncate_epoch();
}
inline ::google::protobuf::uint32 XCap::truncate_epoch() const {
  return truncate_epoch_;
}
inline void XCap::set_truncate_epoch(::google::protobuf::uint32 value) {
  set_has_truncate_epoch();
  truncate_epoch_ = value;
}

// required .xtreemfs.pbrpc.SnapConfig snap_config = 9;
inline bool XCap::has_snap_config() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void XCap::set_has_snap_config() {
  _has_bits_[0] |= 0x00000100u;
}
inline void XCap::clear_has_snap_config() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void XCap::clear_snap_config() {
  snap_config_ = 0;
  clear_has_snap_config();
}
inline ::xtreemfs::pbrpc::SnapConfig XCap::snap_config() const {
  return static_cast< ::xtreemfs::pbrpc::SnapConfig >(snap_config_);
}
inline void XCap::set_snap_config(::xtreemfs::pbrpc::SnapConfig value) {
  assert(::xtreemfs::pbrpc::SnapConfig_IsValid(value));
  set_has_snap_config();
  snap_config_ = value;
}

// required fixed64 snap_timestamp = 10;
inline bool XCap::has_snap_timestamp() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void XCap::set_has_snap_timestamp() {
  _has_bits_[0] |= 0x00000200u;
}
inline void XCap::clear_has_snap_timestamp() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void XCap::clear_snap_timestamp() {
  snap_timestamp_ = GOOGLE_ULONGLONG(0);
  clear_has_snap_timestamp();
}
inline ::google::protobuf::uint64 XCap::snap_timestamp() const {
  return snap_timestamp_;
}
inline void XCap::set_snap_timestamp(::google::protobuf::uint64 value) {
  set_has_snap_timestamp();
  snap_timestamp_ = value;
}

// optional fixed64 voucher_size = 11 [default = 0];
inline bool XCap::has_voucher_size() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void XCap::set_has_voucher_size() {
  _has_bits_[0] |= 0x00000400u;
}
inline void XCap::clear_has_voucher_size() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void XCap::clear_voucher_size() {
  voucher_size_ = GOOGLE_ULONGLONG(0);
  clear_has_voucher_size();
}
inline ::google::protobuf::uint64 XCap::voucher_size() const {
  return voucher_size_;
}
inline void XCap::set_voucher_size(::google::protobuf::uint64 value) {
  set_has_voucher_size();
  voucher_size_ = value;
}

// optional fixed64 expire_time_ms = 12 [default = 0];
inline bool XCap::has_expire_time_ms() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void XCap::set_has_expire_time_ms() {
  _has_bits_[0] |= 0x00000800u;
}
inline void XCap::clear_has_expire_time_ms() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void XCap::clear_expire_time_ms() {
  expire_time_ms_ = GOOGLE_ULONGLONG(0);
  clear_has_expire_time_ms();
}
inline ::google::protobuf::uint64 XCap::expire_time_ms() const {
  return expire_time_ms_;
}
inline void XCap::set_expire_time_ms(::google::protobuf::uint64 value) {
  set_has_expire_time_ms();
  expire_time_ms_ = value;
}

// -------------------------------------------------------------------

// XLocSet

// required fixed64 read_only_file_size = 1;
inline bool XLocSet::has_read_only_file_size() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XLocSet::set_has_read_only_file_size() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XLocSet::clear_has_read_only_file_size() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XLocSet::clear_read_only_file_size() {
  read_only_file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_read_only_file_size();
}
inline ::google::protobuf::uint64 XLocSet::read_only_file_size() const {
  return read_only_file_size_;
}
inline void XLocSet::set_read_only_file_size(::google::protobuf::uint64 value) {
  set_has_read_only_file_size();
  read_only_file_size_ = value;
}

// repeated .xtreemfs.pbrpc.Replica replicas = 2;
inline int XLocSet::replicas_size() const {
  return replicas_.size();
}
inline void XLocSet::clear_replicas() {
  replicas_.Clear();
}
inline const ::xtreemfs::pbrpc::Replica& XLocSet::replicas(int index) const {
  return replicas_.Get(index);
}
inline ::xtreemfs::pbrpc::Replica* XLocSet::mutable_replicas(int index) {
  return replicas_.Mutable(index);
}
inline ::xtreemfs::pbrpc::Replica* XLocSet::add_replicas() {
  return replicas_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica >&
XLocSet::replicas() const {
  return replicas_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Replica >*
XLocSet::mutable_replicas() {
  return &replicas_;
}

// required string replica_update_policy = 3;
inline bool XLocSet::has_replica_update_policy() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XLocSet::set_has_replica_update_policy() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XLocSet::clear_has_replica_update_policy() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XLocSet::clear_replica_update_policy() {
  if (replica_update_policy_ != &::google::protobuf::internal::kEmptyString) {
    replica_update_policy_->clear();
  }
  clear_has_replica_update_policy();
}
inline const ::std::string& XLocSet::replica_update_policy() const {
  return *replica_update_policy_;
}
inline void XLocSet::set_replica_update_policy(const ::std::string& value) {
  set_has_replica_update_policy();
  if (replica_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    replica_update_policy_ = new ::std::string;
  }
  replica_update_policy_->assign(value);
}
inline void XLocSet::set_replica_update_policy(const char* value) {
  set_has_replica_update_policy();
  if (replica_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    replica_update_policy_ = new ::std::string;
  }
  replica_update_policy_->assign(value);
}
inline void XLocSet::set_replica_update_policy(const char* value, size_t size) {
  set_has_replica_update_policy();
  if (replica_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    replica_update_policy_ = new ::std::string;
  }
  replica_update_policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XLocSet::mutable_replica_update_policy() {
  set_has_replica_update_policy();
  if (replica_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    replica_update_policy_ = new ::std::string;
  }
  return replica_update_policy_;
}
inline ::std::string* XLocSet::release_replica_update_policy() {
  clear_has_replica_update_policy();
  if (replica_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = replica_update_policy_;
    replica_update_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XLocSet::set_allocated_replica_update_policy(::std::string* replica_update_policy) {
  if (replica_update_policy_ != &::google::protobuf::internal::kEmptyString) {
    delete replica_update_policy_;
  }
  if (replica_update_policy) {
    set_has_replica_update_policy();
    replica_update_policy_ = replica_update_policy;
  } else {
    clear_has_replica_update_policy();
    replica_update_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 version = 4;
inline bool XLocSet::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void XLocSet::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void XLocSet::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void XLocSet::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 XLocSet::version() const {
  return version_;
}
inline void XLocSet::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
}

// -------------------------------------------------------------------

// FileCredentials

// required .xtreemfs.pbrpc.XCap xcap = 1;
inline bool FileCredentials::has_xcap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileCredentials::set_has_xcap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileCredentials::clear_has_xcap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileCredentials::clear_xcap() {
  if (xcap_ != NULL) xcap_->::xtreemfs::pbrpc::XCap::Clear();
  clear_has_xcap();
}
inline const ::xtreemfs::pbrpc::XCap& FileCredentials::xcap() const {
  return xcap_ != NULL ? *xcap_ : *default_instance_->xcap_;
}
inline ::xtreemfs::pbrpc::XCap* FileCredentials::mutable_xcap() {
  set_has_xcap();
  if (xcap_ == NULL) xcap_ = new ::xtreemfs::pbrpc::XCap;
  return xcap_;
}
inline ::xtreemfs::pbrpc::XCap* FileCredentials::release_xcap() {
  clear_has_xcap();
  ::xtreemfs::pbrpc::XCap* temp = xcap_;
  xcap_ = NULL;
  return temp;
}
inline void FileCredentials::set_allocated_xcap(::xtreemfs::pbrpc::XCap* xcap) {
  delete xcap_;
  xcap_ = xcap;
  if (xcap) {
    set_has_xcap();
  } else {
    clear_has_xcap();
  }
}

// required .xtreemfs.pbrpc.XLocSet xlocs = 2;
inline bool FileCredentials::has_xlocs() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FileCredentials::set_has_xlocs() {
  _has_bits_[0] |= 0x00000002u;
}
inline void FileCredentials::clear_has_xlocs() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void FileCredentials::clear_xlocs() {
  if (xlocs_ != NULL) xlocs_->::xtreemfs::pbrpc::XLocSet::Clear();
  clear_has_xlocs();
}
inline const ::xtreemfs::pbrpc::XLocSet& FileCredentials::xlocs() const {
  return xlocs_ != NULL ? *xlocs_ : *default_instance_->xlocs_;
}
inline ::xtreemfs::pbrpc::XLocSet* FileCredentials::mutable_xlocs() {
  set_has_xlocs();
  if (xlocs_ == NULL) xlocs_ = new ::xtreemfs::pbrpc::XLocSet;
  return xlocs_;
}
inline ::xtreemfs::pbrpc::XLocSet* FileCredentials::release_xlocs() {
  clear_has_xlocs();
  ::xtreemfs::pbrpc::XLocSet* temp = xlocs_;
  xlocs_ = NULL;
  return temp;
}
inline void FileCredentials::set_allocated_xlocs(::xtreemfs::pbrpc::XLocSet* xlocs) {
  delete xlocs_;
  xlocs_ = xlocs;
  if (xlocs) {
    set_has_xlocs();
  } else {
    clear_has_xlocs();
  }
}

// -------------------------------------------------------------------

// FileCredentialsSet

// optional .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
inline bool FileCredentialsSet::has_file_credentials() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FileCredentialsSet::set_has_file_credentials() {
  _has_bits_[0] |= 0x00000001u;
}
inline void FileCredentialsSet::clear_has_file_credentials() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void FileCredentialsSet::clear_file_credentials() {
  if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_file_credentials();
}
inline const ::xtreemfs::pbrpc::FileCredentials& FileCredentialsSet::file_credentials() const {
  return file_credentials_ != NULL ? *file_credentials_ : *default_instance_->file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* FileCredentialsSet::mutable_file_credentials() {
  set_has_file_credentials();
  if (file_credentials_ == NULL) file_credentials_ = new ::xtreemfs::pbrpc::FileCredentials;
  return file_credentials_;
}
inline ::xtreemfs::pbrpc::FileCredentials* FileCredentialsSet::release_file_credentials() {
  clear_has_file_credentials();
  ::xtreemfs::pbrpc::FileCredentials* temp = file_credentials_;
  file_credentials_ = NULL;
  return temp;
}
inline void FileCredentialsSet::set_allocated_file_credentials(::xtreemfs::pbrpc::FileCredentials* file_credentials) {
  delete file_credentials_;
  file_credentials_ = file_credentials;
  if (file_credentials) {
    set_has_file_credentials();
  } else {
    clear_has_file_credentials();
  }
}

// -------------------------------------------------------------------

// VivaldiCoordinates

// required double x_coordinate = 1;
inline bool VivaldiCoordinates::has_x_coordinate() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void VivaldiCoordinates::set_has_x_coordinate() {
  _has_bits_[0] |= 0x00000001u;
}
inline void VivaldiCoordinates::clear_has_x_coordinate() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void VivaldiCoordinates::clear_x_coordinate() {
  x_coordinate_ = 0;
  clear_has_x_coordinate();
}
inline double VivaldiCoordinates::x_coordinate() const {
  return x_coordinate_;
}
inline void VivaldiCoordinates::set_x_coordinate(double value) {
  set_has_x_coordinate();
  x_coordinate_ = value;
}

// required double y_coordinate = 2;
inline bool VivaldiCoordinates::has_y_coordinate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void VivaldiCoordinates::set_has_y_coordinate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void VivaldiCoordinates::clear_has_y_coordinate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void VivaldiCoordinates::clear_y_coordinate() {
  y_coordinate_ = 0;
  clear_has_y_coordinate();
}
inline double VivaldiCoordinates::y_coordinate() const {
  return y_coordinate_;
}
inline void VivaldiCoordinates::set_y_coordinate(double value) {
  set_has_y_coordinate();
  y_coordinate_ = value;
}

// required double local_error = 3;
inline bool VivaldiCoordinates::has_local_error() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void VivaldiCoordinates::set_has_local_error() {
  _has_bits_[0] |= 0x00000004u;
}
inline void VivaldiCoordinates::clear_has_local_error() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void VivaldiCoordinates::clear_local_error() {
  local_error_ = 0;
  clear_has_local_error();
}
inline double VivaldiCoordinates::local_error() const {
  return local_error_;
}
inline void VivaldiCoordinates::set_local_error(double value) {
  set_has_local_error();
  local_error_ = value;
}

// -------------------------------------------------------------------

// OSDFinalizeVouchersResponse

// required string osd_uuid = 1;
inline bool OSDFinalizeVouchersResponse::has_osd_uuid() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OSDFinalizeVouchersResponse::set_has_osd_uuid() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OSDFinalizeVouchersResponse::clear_has_osd_uuid() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OSDFinalizeVouchersResponse::clear_osd_uuid() {
  if (osd_uuid_ != &::google::protobuf::internal::kEmptyString) {
    osd_uuid_->clear();
  }
  clear_has_osd_uuid();
}
inline const ::std::string& OSDFinalizeVouchersResponse::osd_uuid() const {
  return *osd_uuid_;
}
inline void OSDFinalizeVouchersResponse::set_osd_uuid(const ::std::string& value) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void OSDFinalizeVouchersResponse::set_osd_uuid(const char* value) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void OSDFinalizeVouchersResponse::set_osd_uuid(const char* value, size_t size) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OSDFinalizeVouchersResponse::mutable_osd_uuid() {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  return osd_uuid_;
}
inline ::std::string* OSDFinalizeVouchersResponse::release_osd_uuid() {
  clear_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osd_uuid_;
    osd_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OSDFinalizeVouchersResponse::set_allocated_osd_uuid(::std::string* osd_uuid) {
  if (osd_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete osd_uuid_;
  }
  if (osd_uuid) {
    set_has_osd_uuid();
    osd_uuid_ = osd_uuid;
  } else {
    clear_has_osd_uuid();
    osd_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string server_signature = 2;
inline bool OSDFinalizeVouchersResponse::has_server_signature() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OSDFinalizeVouchersResponse::set_has_server_signature() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OSDFinalizeVouchersResponse::clear_has_server_signature() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OSDFinalizeVouchersResponse::clear_server_signature() {
  if (server_signature_ != &::google::protobuf::internal::kEmptyString) {
    server_signature_->clear();
  }
  clear_has_server_signature();
}
inline const ::std::string& OSDFinalizeVouchersResponse::server_signature() const {
  return *server_signature_;
}
inline void OSDFinalizeVouchersResponse::set_server_signature(const ::std::string& value) {
  set_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    server_signature_ = new ::std::string;
  }
  server_signature_->assign(value);
}
inline void OSDFinalizeVouchersResponse::set_server_signature(const char* value) {
  set_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    server_signature_ = new ::std::string;
  }
  server_signature_->assign(value);
}
inline void OSDFinalizeVouchersResponse::set_server_signature(const char* value, size_t size) {
  set_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    server_signature_ = new ::std::string;
  }
  server_signature_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* OSDFinalizeVouchersResponse::mutable_server_signature() {
  set_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    server_signature_ = new ::std::string;
  }
  return server_signature_;
}
inline ::std::string* OSDFinalizeVouchersResponse::release_server_signature() {
  clear_has_server_signature();
  if (server_signature_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = server_signature_;
    server_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void OSDFinalizeVouchersResponse::set_allocated_server_signature(::std::string* server_signature) {
  if (server_signature_ != &::google::protobuf::internal::kEmptyString) {
    delete server_signature_;
  }
  if (server_signature) {
    set_has_server_signature();
    server_signature_ = server_signature;
  } else {
    clear_has_server_signature();
    server_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 size_in_bytes = 3;
inline bool OSDFinalizeVouchersResponse::has_size_in_bytes() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void OSDFinalizeVouchersResponse::set_has_size_in_bytes() {
  _has_bits_[0] |= 0x00000004u;
}
inline void OSDFinalizeVouchersResponse::clear_has_size_in_bytes() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void OSDFinalizeVouchersResponse::clear_size_in_bytes() {
  size_in_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_size_in_bytes();
}
inline ::google::protobuf::uint64 OSDFinalizeVouchersResponse::size_in_bytes() const {
  return size_in_bytes_;
}
inline void OSDFinalizeVouchersResponse::set_size_in_bytes(::google::protobuf::uint64 value) {
  set_has_size_in_bytes();
  size_in_bytes_ = value;
}

// required fixed64 truncate_epoch = 4;
inline bool OSDFinalizeVouchersResponse::has_truncate_epoch() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void OSDFinalizeVouchersResponse::set_has_truncate_epoch() {
  _has_bits_[0] |= 0x00000008u;
}
inline void OSDFinalizeVouchersResponse::clear_has_truncate_epoch() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void OSDFinalizeVouchersResponse::clear_truncate_epoch() {
  truncate_epoch_ = GOOGLE_ULONGLONG(0);
  clear_has_truncate_epoch();
}
inline ::google::protobuf::uint64 OSDFinalizeVouchersResponse::truncate_epoch() const {
  return truncate_epoch_;
}
inline void OSDFinalizeVouchersResponse::set_truncate_epoch(::google::protobuf::uint64 value) {
  set_has_truncate_epoch();
  truncate_epoch_ = value;
}

// -------------------------------------------------------------------

// OSDWriteResponse

// optional fixed64 size_in_bytes = 1;
inline bool OSDWriteResponse::has_size_in_bytes() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void OSDWriteResponse::set_has_size_in_bytes() {
  _has_bits_[0] |= 0x00000001u;
}
inline void OSDWriteResponse::clear_has_size_in_bytes() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void OSDWriteResponse::clear_size_in_bytes() {
  size_in_bytes_ = GOOGLE_ULONGLONG(0);
  clear_has_size_in_bytes();
}
inline ::google::protobuf::uint64 OSDWriteResponse::size_in_bytes() const {
  return size_in_bytes_;
}
inline void OSDWriteResponse::set_size_in_bytes(::google::protobuf::uint64 value) {
  set_has_size_in_bytes();
  size_in_bytes_ = value;
}

// optional fixed32 truncate_epoch = 2;
inline bool OSDWriteResponse::has_truncate_epoch() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void OSDWriteResponse::set_has_truncate_epoch() {
  _has_bits_[0] |= 0x00000002u;
}
inline void OSDWriteResponse::clear_has_truncate_epoch() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void OSDWriteResponse::clear_truncate_epoch() {
  truncate_epoch_ = 0u;
  clear_has_truncate_epoch();
}
inline ::google::protobuf::uint32 OSDWriteResponse::truncate_epoch() const {
  return truncate_epoch_;
}
inline void OSDWriteResponse::set_truncate_epoch(::google::protobuf::uint32 value) {
  set_has_truncate_epoch();
  truncate_epoch_ = value;
}

// -------------------------------------------------------------------

// KeyValuePair

// required string key = 1;
inline bool KeyValuePair::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void KeyValuePair::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void KeyValuePair::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void KeyValuePair::clear_key() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    key_->clear();
  }
  clear_has_key();
}
inline const ::std::string& KeyValuePair::key() const {
  return *key_;
}
inline void KeyValuePair::set_key(const ::std::string& value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValuePair::set_key(const char* value) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(value);
}
inline void KeyValuePair::set_key(const char* value, size_t size) {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  key_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValuePair::mutable_key() {
  set_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    key_ = new ::std::string;
  }
  return key_;
}
inline ::std::string* KeyValuePair::release_key() {
  clear_has_key();
  if (key_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = key_;
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyValuePair::set_allocated_key(::std::string* key) {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (key) {
    set_has_key();
    key_ = key;
  } else {
    clear_has_key();
    key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 2;
inline bool KeyValuePair::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void KeyValuePair::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void KeyValuePair::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void KeyValuePair::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& KeyValuePair::value() const {
  return *value_;
}
inline void KeyValuePair::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void KeyValuePair::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void KeyValuePair::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* KeyValuePair::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* KeyValuePair::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void KeyValuePair::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::AccessControlPolicyType>() {
  return ::xtreemfs::pbrpc::AccessControlPolicyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::OSDSelectionPolicyType>() {
  return ::xtreemfs::pbrpc::OSDSelectionPolicyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::ReplicaSelectionPolicyType>() {
  return ::xtreemfs::pbrpc::ReplicaSelectionPolicyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::SnapConfig>() {
  return ::xtreemfs::pbrpc::SnapConfig_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::StripingPolicyType>() {
  return ::xtreemfs::pbrpc::StripingPolicyType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::LeaseState>() {
  return ::xtreemfs::pbrpc::LeaseState_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::PORTS>() {
  return ::xtreemfs::pbrpc::PORTS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::CONSTANTS>() {
  return ::xtreemfs::pbrpc::CONSTANTS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::SYSTEM_V_FCNTL>() {
  return ::xtreemfs::pbrpc::SYSTEM_V_FCNTL_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::REPL_FLAG>() {
  return ::xtreemfs::pbrpc::REPL_FLAG_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::SERVICES>() {
  return ::xtreemfs::pbrpc::SERVICES_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xtreemfs_2fGlobalTypes_2eproto__INCLUDED
