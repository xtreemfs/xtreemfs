// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/MRC.proto

#ifndef PROTOBUF_xtreemfs_2fMRC_2eproto__INCLUDED
#define PROTOBUF_xtreemfs_2fMRC_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "include/PBRPC.pb.h"
#include "include/Common.pb.h"
#include "xtreemfs/GlobalTypes.pb.h"
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

class Stat;
class DirectoryEntry;
class DirectoryEntries;
class XAttr;
class Volume;
class Volumes;
class StatVFS;
class fsetattrRequest;
class getattrRequest;
class getattrResponse;
class getxattrRequest;
class getxattrResponse;
class linkRequest;
class listxattrRequest;
class listxattrResponse;
class mkdirRequest;
class openRequest;
class openResponse;
class readdirRequest;
class readlinkRequest;
class readlinkResponse;
class removexattrRequest;
class renameRequest;
class renameResponse;
class rmdirRequest;
class setattrRequest;
class setxattrRequest;
class statvfsRequest;
class symlinkRequest;
class unlinkRequest;
class unlinkResponse;
class accessRequest;
class xtreemfs_check_file_existsRequest;
class xtreemfs_check_file_existsResponse;
class xtreemfs_dump_restore_databaseRequest;
class xtreemfs_get_suitable_osdsRequest;
class xtreemfs_get_suitable_osdsResponse;
class timestampResponse;
class stringMessage;
class xtreemfs_listdirRequest;
class xtreemfs_listdirResponse;
class xtreemfs_replica_addRequest;
class xtreemfs_replica_addResponse;
class xtreemfs_replica_listRequest;
class xtreemfs_get_xlocsetRequest;
class xtreemfs_replica_removeRequest;
class xtreemfs_replica_removeResponse;
class xtreemfs_restore_fileRequest;
class xtreemfs_rmvolRequest;
class xtreemfs_update_file_sizeRequest;
class xtreemfs_set_replica_update_policyRequest;
class xtreemfs_set_replica_update_policyResponse;
class xtreemfs_set_read_only_xattrRequest;
class xtreemfs_set_read_only_xattrResponse;
class xtreemfs_get_file_credentialsRequest;
class xtreemfs_reselect_osdsRequest;
class xtreemfs_reselect_osdsResponse;

enum xtreemfs_check_file_existsResponse_FILE_STATE {
  xtreemfs_check_file_existsResponse_FILE_STATE_DELETED = 0,
  xtreemfs_check_file_existsResponse_FILE_STATE_REGISTERED = 1,
  xtreemfs_check_file_existsResponse_FILE_STATE_ABANDONED = 2
};
bool xtreemfs_check_file_existsResponse_FILE_STATE_IsValid(int value);
const xtreemfs_check_file_existsResponse_FILE_STATE xtreemfs_check_file_existsResponse_FILE_STATE_FILE_STATE_MIN = xtreemfs_check_file_existsResponse_FILE_STATE_DELETED;
const xtreemfs_check_file_existsResponse_FILE_STATE xtreemfs_check_file_existsResponse_FILE_STATE_FILE_STATE_MAX = xtreemfs_check_file_existsResponse_FILE_STATE_ABANDONED;
const int xtreemfs_check_file_existsResponse_FILE_STATE_FILE_STATE_ARRAYSIZE = xtreemfs_check_file_existsResponse_FILE_STATE_FILE_STATE_MAX + 1;

const ::google::protobuf::EnumDescriptor* xtreemfs_check_file_existsResponse_FILE_STATE_descriptor();
inline const ::std::string& xtreemfs_check_file_existsResponse_FILE_STATE_Name(xtreemfs_check_file_existsResponse_FILE_STATE value) {
  return ::google::protobuf::internal::NameOfEnum(
    xtreemfs_check_file_existsResponse_FILE_STATE_descriptor(), value);
}
inline bool xtreemfs_check_file_existsResponse_FILE_STATE_Parse(
    const ::std::string& name, xtreemfs_check_file_existsResponse_FILE_STATE* value) {
  return ::google::protobuf::internal::ParseNamedEnum<xtreemfs_check_file_existsResponse_FILE_STATE>(
    xtreemfs_check_file_existsResponse_FILE_STATE_descriptor(), name, value);
}
enum Setattrs {
  SETATTR_MODE = 1,
  SETATTR_UID = 2,
  SETATTR_GID = 4,
  SETATTR_SIZE = 8,
  SETATTR_ATIME = 16,
  SETATTR_MTIME = 32,
  SETATTR_CTIME = 64,
  SETATTR_ATTRIBUTES = 128
};
bool Setattrs_IsValid(int value);
const Setattrs Setattrs_MIN = SETATTR_MODE;
const Setattrs Setattrs_MAX = SETATTR_ATTRIBUTES;
const int Setattrs_ARRAYSIZE = Setattrs_MAX + 1;

const ::google::protobuf::EnumDescriptor* Setattrs_descriptor();
inline const ::std::string& Setattrs_Name(Setattrs value) {
  return ::google::protobuf::internal::NameOfEnum(
    Setattrs_descriptor(), value);
}
inline bool Setattrs_Parse(
    const ::std::string& name, Setattrs* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Setattrs>(
    Setattrs_descriptor(), name, value);
}
enum XATTR_FLAGS {
  XATTR_FLAGS_CREATE = 1,
  XATTR_FLAGS_REPLACE = 2
};
bool XATTR_FLAGS_IsValid(int value);
const XATTR_FLAGS XATTR_FLAGS_MIN = XATTR_FLAGS_CREATE;
const XATTR_FLAGS XATTR_FLAGS_MAX = XATTR_FLAGS_REPLACE;
const int XATTR_FLAGS_ARRAYSIZE = XATTR_FLAGS_MAX + 1;

const ::google::protobuf::EnumDescriptor* XATTR_FLAGS_descriptor();
inline const ::std::string& XATTR_FLAGS_Name(XATTR_FLAGS value) {
  return ::google::protobuf::internal::NameOfEnum(
    XATTR_FLAGS_descriptor(), value);
}
inline bool XATTR_FLAGS_Parse(
    const ::std::string& name, XATTR_FLAGS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<XATTR_FLAGS>(
    XATTR_FLAGS_descriptor(), name, value);
}
enum ACCESS_FLAGS {
  ACCESS_FLAGS_F_OK = 0,
  ACCESS_FLAGS_X_OK = 1,
  ACCESS_FLAGS_W_OK = 2,
  ACCESS_FLAGS_R_OK = 4
};
bool ACCESS_FLAGS_IsValid(int value);
const ACCESS_FLAGS ACCESS_FLAGS_MIN = ACCESS_FLAGS_F_OK;
const ACCESS_FLAGS ACCESS_FLAGS_MAX = ACCESS_FLAGS_R_OK;
const int ACCESS_FLAGS_ARRAYSIZE = ACCESS_FLAGS_MAX + 1;

const ::google::protobuf::EnumDescriptor* ACCESS_FLAGS_descriptor();
inline const ::std::string& ACCESS_FLAGS_Name(ACCESS_FLAGS value) {
  return ::google::protobuf::internal::NameOfEnum(
    ACCESS_FLAGS_descriptor(), value);
}
inline bool ACCESS_FLAGS_Parse(
    const ::std::string& name, ACCESS_FLAGS* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ACCESS_FLAGS>(
    ACCESS_FLAGS_descriptor(), name, value);
}
// ===================================================================

class Stat : public ::google::protobuf::Message {
 public:
  Stat();
  virtual ~Stat();

  Stat(const Stat& from);

  inline Stat& operator=(const Stat& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stat& default_instance();

  void Swap(Stat* other);

  // implements Message ----------------------------------------------

  Stat* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stat& from);
  void MergeFrom(const Stat& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed64 dev = 1;
  inline bool has_dev() const;
  inline void clear_dev();
  static const int kDevFieldNumber = 1;
  inline ::google::protobuf::uint64 dev() const;
  inline void set_dev(::google::protobuf::uint64 value);

  // required fixed64 ino = 2;
  inline bool has_ino() const;
  inline void clear_ino();
  static const int kInoFieldNumber = 2;
  inline ::google::protobuf::uint64 ino() const;
  inline void set_ino(::google::protobuf::uint64 value);

  // required fixed32 mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // required fixed32 nlink = 4;
  inline bool has_nlink() const;
  inline void clear_nlink();
  static const int kNlinkFieldNumber = 4;
  inline ::google::protobuf::uint32 nlink() const;
  inline void set_nlink(::google::protobuf::uint32 value);

  // required string user_id = 5;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 5;
  inline const ::std::string& user_id() const;
  inline void set_user_id(const ::std::string& value);
  inline void set_user_id(const char* value);
  inline void set_user_id(const char* value, size_t size);
  inline ::std::string* mutable_user_id();
  inline ::std::string* release_user_id();
  inline void set_allocated_user_id(::std::string* user_id);

  // required string group_id = 6;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 6;
  inline const ::std::string& group_id() const;
  inline void set_group_id(const ::std::string& value);
  inline void set_group_id(const char* value);
  inline void set_group_id(const char* value, size_t size);
  inline ::std::string* mutable_group_id();
  inline ::std::string* release_group_id();
  inline void set_allocated_group_id(::std::string* group_id);

  // required fixed64 size = 7;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 7;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // required fixed64 atime_ns = 8;
  inline bool has_atime_ns() const;
  inline void clear_atime_ns();
  static const int kAtimeNsFieldNumber = 8;
  inline ::google::protobuf::uint64 atime_ns() const;
  inline void set_atime_ns(::google::protobuf::uint64 value);

  // required fixed64 mtime_ns = 9;
  inline bool has_mtime_ns() const;
  inline void clear_mtime_ns();
  static const int kMtimeNsFieldNumber = 9;
  inline ::google::protobuf::uint64 mtime_ns() const;
  inline void set_mtime_ns(::google::protobuf::uint64 value);

  // required fixed64 ctime_ns = 10;
  inline bool has_ctime_ns() const;
  inline void clear_ctime_ns();
  static const int kCtimeNsFieldNumber = 10;
  inline ::google::protobuf::uint64 ctime_ns() const;
  inline void set_ctime_ns(::google::protobuf::uint64 value);

  // required fixed32 blksize = 11;
  inline bool has_blksize() const;
  inline void clear_blksize();
  static const int kBlksizeFieldNumber = 11;
  inline ::google::protobuf::uint32 blksize() const;
  inline void set_blksize(::google::protobuf::uint32 value);

  // optional fixed64 etag = 12;
  inline bool has_etag() const;
  inline void clear_etag();
  static const int kEtagFieldNumber = 12;
  inline ::google::protobuf::uint64 etag() const;
  inline void set_etag(::google::protobuf::uint64 value);

  // required fixed32 truncate_epoch = 13;
  inline bool has_truncate_epoch() const;
  inline void clear_truncate_epoch();
  static const int kTruncateEpochFieldNumber = 13;
  inline ::google::protobuf::uint32 truncate_epoch() const;
  inline void set_truncate_epoch(::google::protobuf::uint32 value);

  // optional fixed32 attributes = 14;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 14;
  inline ::google::protobuf::uint32 attributes() const;
  inline void set_attributes(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Stat)
 private:
  inline void set_has_dev();
  inline void clear_has_dev();
  inline void set_has_ino();
  inline void clear_has_ino();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_nlink();
  inline void clear_has_nlink();
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_atime_ns();
  inline void clear_has_atime_ns();
  inline void set_has_mtime_ns();
  inline void clear_has_mtime_ns();
  inline void set_has_ctime_ns();
  inline void clear_has_ctime_ns();
  inline void set_has_blksize();
  inline void clear_has_blksize();
  inline void set_has_etag();
  inline void clear_has_etag();
  inline void set_has_truncate_epoch();
  inline void clear_has_truncate_epoch();
  inline void set_has_attributes();
  inline void clear_has_attributes();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 dev_;
  ::google::protobuf::uint64 ino_;
  ::google::protobuf::uint32 mode_;
  ::google::protobuf::uint32 nlink_;
  ::std::string* user_id_;
  ::std::string* group_id_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint64 atime_ns_;
  ::google::protobuf::uint64 mtime_ns_;
  ::google::protobuf::uint64 ctime_ns_;
  ::google::protobuf::uint64 etag_;
  ::google::protobuf::uint32 blksize_;
  ::google::protobuf::uint32 truncate_epoch_;
  ::google::protobuf::uint32 attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static Stat* default_instance_;
};
// -------------------------------------------------------------------

class DirectoryEntry : public ::google::protobuf::Message {
 public:
  DirectoryEntry();
  virtual ~DirectoryEntry();

  DirectoryEntry(const DirectoryEntry& from);

  inline DirectoryEntry& operator=(const DirectoryEntry& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectoryEntry& default_instance();

  void Swap(DirectoryEntry* other);

  // implements Message ----------------------------------------------

  DirectoryEntry* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirectoryEntry& from);
  void MergeFrom(const DirectoryEntry& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional .xtreemfs.pbrpc.Stat stbuf = 2;
  inline bool has_stbuf() const;
  inline void clear_stbuf();
  static const int kStbufFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::Stat& stbuf() const;
  inline ::xtreemfs::pbrpc::Stat* mutable_stbuf();
  inline ::xtreemfs::pbrpc::Stat* release_stbuf();
  inline void set_allocated_stbuf(::xtreemfs::pbrpc::Stat* stbuf);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.DirectoryEntry)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_stbuf();
  inline void clear_has_stbuf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::xtreemfs::pbrpc::Stat* stbuf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static DirectoryEntry* default_instance_;
};
// -------------------------------------------------------------------

class DirectoryEntries : public ::google::protobuf::Message {
 public:
  DirectoryEntries();
  virtual ~DirectoryEntries();

  DirectoryEntries(const DirectoryEntries& from);

  inline DirectoryEntries& operator=(const DirectoryEntries& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DirectoryEntries& default_instance();

  void Swap(DirectoryEntries* other);

  // implements Message ----------------------------------------------

  DirectoryEntries* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const DirectoryEntries& from);
  void MergeFrom(const DirectoryEntries& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.DirectoryEntry entries = 1;
  inline int entries_size() const;
  inline void clear_entries();
  static const int kEntriesFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::DirectoryEntry& entries(int index) const;
  inline ::xtreemfs::pbrpc::DirectoryEntry* mutable_entries(int index);
  inline ::xtreemfs::pbrpc::DirectoryEntry* add_entries();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry >&
      entries() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry >*
      mutable_entries();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.DirectoryEntries)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry > entries_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static DirectoryEntries* default_instance_;
};
// -------------------------------------------------------------------

class XAttr : public ::google::protobuf::Message {
 public:
  XAttr();
  virtual ~XAttr();

  XAttr(const XAttr& from);

  inline XAttr& operator=(const XAttr& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const XAttr& default_instance();

  void Swap(XAttr* other);

  // implements Message ----------------------------------------------

  XAttr* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const XAttr& from);
  void MergeFrom(const XAttr& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bytes value_bytes_string = 3;
  inline bool has_value_bytes_string() const;
  inline void clear_value_bytes_string();
  static const int kValueBytesStringFieldNumber = 3;
  inline const ::std::string& value_bytes_string() const;
  inline void set_value_bytes_string(const ::std::string& value);
  inline void set_value_bytes_string(const char* value);
  inline void set_value_bytes_string(const void* value, size_t size);
  inline ::std::string* mutable_value_bytes_string();
  inline ::std::string* release_value_bytes_string();
  inline void set_allocated_value_bytes_string(::std::string* value_bytes_string);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.XAttr)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_value_bytes_string();
  inline void clear_has_value_bytes_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* value_;
  ::std::string* value_bytes_string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static XAttr* default_instance_;
};
// -------------------------------------------------------------------

class Volume : public ::google::protobuf::Message {
 public:
  Volume();
  virtual ~Volume();

  Volume(const Volume& from);

  inline Volume& operator=(const Volume& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Volume& default_instance();

  void Swap(Volume* other);

  // implements Message ----------------------------------------------

  Volume* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volume& from);
  void MergeFrom(const Volume& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.AccessControlPolicyType access_control_policy = 1;
  inline bool has_access_control_policy() const;
  inline void clear_access_control_policy();
  static const int kAccessControlPolicyFieldNumber = 1;
  inline ::xtreemfs::pbrpc::AccessControlPolicyType access_control_policy() const;
  inline void set_access_control_policy(::xtreemfs::pbrpc::AccessControlPolicyType value);

  // required .xtreemfs.pbrpc.StripingPolicy default_striping_policy = 2;
  inline bool has_default_striping_policy() const;
  inline void clear_default_striping_policy();
  static const int kDefaultStripingPolicyFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::StripingPolicy& default_striping_policy() const;
  inline ::xtreemfs::pbrpc::StripingPolicy* mutable_default_striping_policy();
  inline ::xtreemfs::pbrpc::StripingPolicy* release_default_striping_policy();
  inline void set_allocated_default_striping_policy(::xtreemfs::pbrpc::StripingPolicy* default_striping_policy);

  // required string id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline const ::std::string& id() const;
  inline void set_id(const ::std::string& value);
  inline void set_id(const char* value);
  inline void set_id(const char* value, size_t size);
  inline ::std::string* mutable_id();
  inline ::std::string* release_id();
  inline void set_allocated_id(::std::string* id);

  // required fixed32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // required string name = 5;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 5;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string owner_group_id = 6;
  inline bool has_owner_group_id() const;
  inline void clear_owner_group_id();
  static const int kOwnerGroupIdFieldNumber = 6;
  inline const ::std::string& owner_group_id() const;
  inline void set_owner_group_id(const ::std::string& value);
  inline void set_owner_group_id(const char* value);
  inline void set_owner_group_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_group_id();
  inline ::std::string* release_owner_group_id();
  inline void set_allocated_owner_group_id(::std::string* owner_group_id);

  // required string owner_user_id = 7;
  inline bool has_owner_user_id() const;
  inline void clear_owner_user_id();
  static const int kOwnerUserIdFieldNumber = 7;
  inline const ::std::string& owner_user_id() const;
  inline void set_owner_user_id(const ::std::string& value);
  inline void set_owner_user_id(const char* value);
  inline void set_owner_user_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_user_id();
  inline ::std::string* release_owner_user_id();
  inline void set_allocated_owner_user_id(::std::string* owner_user_id);

  // repeated .xtreemfs.pbrpc.KeyValuePair attrs = 8;
  inline int attrs_size() const;
  inline void clear_attrs();
  static const int kAttrsFieldNumber = 8;
  inline const ::xtreemfs::pbrpc::KeyValuePair& attrs(int index) const;
  inline ::xtreemfs::pbrpc::KeyValuePair* mutable_attrs(int index);
  inline ::xtreemfs::pbrpc::KeyValuePair* add_attrs();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >&
      attrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >*
      mutable_attrs();

  // optional fixed64 quota = 9;
  inline bool has_quota() const;
  inline void clear_quota();
  static const int kQuotaFieldNumber = 9;
  inline ::google::protobuf::uint64 quota() const;
  inline void set_quota(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Volume)
 private:
  inline void set_has_access_control_policy();
  inline void clear_has_access_control_policy();
  inline void set_has_default_striping_policy();
  inline void clear_has_default_striping_policy();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_owner_group_id();
  inline void clear_has_owner_group_id();
  inline void set_has_owner_user_id();
  inline void clear_has_owner_user_id();
  inline void set_has_quota();
  inline void clear_has_quota();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::StripingPolicy* default_striping_policy_;
  int access_control_policy_;
  ::google::protobuf::uint32 mode_;
  ::std::string* id_;
  ::std::string* name_;
  ::std::string* owner_group_id_;
  ::std::string* owner_user_id_;
  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair > attrs_;
  ::google::protobuf::uint64 quota_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static Volume* default_instance_;
};
// -------------------------------------------------------------------

class Volumes : public ::google::protobuf::Message {
 public:
  Volumes();
  virtual ~Volumes();

  Volumes(const Volumes& from);

  inline Volumes& operator=(const Volumes& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Volumes& default_instance();

  void Swap(Volumes* other);

  // implements Message ----------------------------------------------

  Volumes* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Volumes& from);
  void MergeFrom(const Volumes& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.Volume volumes = 1;
  inline int volumes_size() const;
  inline void clear_volumes();
  static const int kVolumesFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Volume& volumes(int index) const;
  inline ::xtreemfs::pbrpc::Volume* mutable_volumes(int index);
  inline ::xtreemfs::pbrpc::Volume* add_volumes();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume >&
      volumes() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume >*
      mutable_volumes();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Volumes)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume > volumes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static Volumes* default_instance_;
};
// -------------------------------------------------------------------

class StatVFS : public ::google::protobuf::Message {
 public:
  StatVFS();
  virtual ~StatVFS();

  StatVFS(const StatVFS& from);

  inline StatVFS& operator=(const StatVFS& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatVFS& default_instance();

  void Swap(StatVFS* other);

  // implements Message ----------------------------------------------

  StatVFS* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const StatVFS& from);
  void MergeFrom(const StatVFS& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 bsize = 1;
  inline bool has_bsize() const;
  inline void clear_bsize();
  static const int kBsizeFieldNumber = 1;
  inline ::google::protobuf::uint32 bsize() const;
  inline void set_bsize(::google::protobuf::uint32 value);

  // required fixed64 bavail = 2;
  inline bool has_bavail() const;
  inline void clear_bavail();
  static const int kBavailFieldNumber = 2;
  inline ::google::protobuf::uint64 bavail() const;
  inline void set_bavail(::google::protobuf::uint64 value);

  // optional fixed64 bfree = 13;
  inline bool has_bfree() const;
  inline void clear_bfree();
  static const int kBfreeFieldNumber = 13;
  inline ::google::protobuf::uint64 bfree() const;
  inline void set_bfree(::google::protobuf::uint64 value);

  // required fixed64 blocks = 3;
  inline bool has_blocks() const;
  inline void clear_blocks();
  static const int kBlocksFieldNumber = 3;
  inline ::google::protobuf::uint64 blocks() const;
  inline void set_blocks(::google::protobuf::uint64 value);

  // required string fsid = 4;
  inline bool has_fsid() const;
  inline void clear_fsid();
  static const int kFsidFieldNumber = 4;
  inline const ::std::string& fsid() const;
  inline void set_fsid(const ::std::string& value);
  inline void set_fsid(const char* value);
  inline void set_fsid(const char* value, size_t size);
  inline ::std::string* mutable_fsid();
  inline ::std::string* release_fsid();
  inline void set_allocated_fsid(::std::string* fsid);

  // required fixed32 namemax = 5;
  inline bool has_namemax() const;
  inline void clear_namemax();
  static const int kNamemaxFieldNumber = 5;
  inline ::google::protobuf::uint32 namemax() const;
  inline void set_namemax(::google::protobuf::uint32 value);

  // required .xtreemfs.pbrpc.AccessControlPolicyType access_control_policy = 6;
  inline bool has_access_control_policy() const;
  inline void clear_access_control_policy();
  static const int kAccessControlPolicyFieldNumber = 6;
  inline ::xtreemfs::pbrpc::AccessControlPolicyType access_control_policy() const;
  inline void set_access_control_policy(::xtreemfs::pbrpc::AccessControlPolicyType value);

  // required .xtreemfs.pbrpc.StripingPolicy default_striping_policy = 7;
  inline bool has_default_striping_policy() const;
  inline void clear_default_striping_policy();
  static const int kDefaultStripingPolicyFieldNumber = 7;
  inline const ::xtreemfs::pbrpc::StripingPolicy& default_striping_policy() const;
  inline ::xtreemfs::pbrpc::StripingPolicy* mutable_default_striping_policy();
  inline ::xtreemfs::pbrpc::StripingPolicy* release_default_striping_policy();
  inline void set_allocated_default_striping_policy(::xtreemfs::pbrpc::StripingPolicy* default_striping_policy);

  // required fixed64 etag = 8;
  inline bool has_etag() const;
  inline void clear_etag();
  static const int kEtagFieldNumber = 8;
  inline ::google::protobuf::uint64 etag() const;
  inline void set_etag(::google::protobuf::uint64 value);

  // required fixed32 mode = 9;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 9;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // required string name = 10;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 10;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string owner_group_id = 11;
  inline bool has_owner_group_id() const;
  inline void clear_owner_group_id();
  static const int kOwnerGroupIdFieldNumber = 11;
  inline const ::std::string& owner_group_id() const;
  inline void set_owner_group_id(const ::std::string& value);
  inline void set_owner_group_id(const char* value);
  inline void set_owner_group_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_group_id();
  inline ::std::string* release_owner_group_id();
  inline void set_allocated_owner_group_id(::std::string* owner_group_id);

  // required string owner_user_id = 12;
  inline bool has_owner_user_id() const;
  inline void clear_owner_user_id();
  static const int kOwnerUserIdFieldNumber = 12;
  inline const ::std::string& owner_user_id() const;
  inline void set_owner_user_id(const ::std::string& value);
  inline void set_owner_user_id(const char* value);
  inline void set_owner_user_id(const char* value, size_t size);
  inline ::std::string* mutable_owner_user_id();
  inline ::std::string* release_owner_user_id();
  inline void set_allocated_owner_user_id(::std::string* owner_user_id);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.StatVFS)
 private:
  inline void set_has_bsize();
  inline void clear_has_bsize();
  inline void set_has_bavail();
  inline void clear_has_bavail();
  inline void set_has_bfree();
  inline void clear_has_bfree();
  inline void set_has_blocks();
  inline void clear_has_blocks();
  inline void set_has_fsid();
  inline void clear_has_fsid();
  inline void set_has_namemax();
  inline void clear_has_namemax();
  inline void set_has_access_control_policy();
  inline void clear_has_access_control_policy();
  inline void set_has_default_striping_policy();
  inline void clear_has_default_striping_policy();
  inline void set_has_etag();
  inline void clear_has_etag();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_owner_group_id();
  inline void clear_has_owner_group_id();
  inline void set_has_owner_user_id();
  inline void clear_has_owner_user_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint64 bavail_;
  ::google::protobuf::uint64 bfree_;
  ::google::protobuf::uint32 bsize_;
  ::google::protobuf::uint32 namemax_;
  ::google::protobuf::uint64 blocks_;
  ::std::string* fsid_;
  ::xtreemfs::pbrpc::StripingPolicy* default_striping_policy_;
  int access_control_policy_;
  ::google::protobuf::uint32 mode_;
  ::google::protobuf::uint64 etag_;
  ::std::string* name_;
  ::std::string* owner_group_id_;
  ::std::string* owner_user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static StatVFS* default_instance_;
};
// -------------------------------------------------------------------

class fsetattrRequest : public ::google::protobuf::Message {
 public:
  fsetattrRequest();
  virtual ~fsetattrRequest();

  fsetattrRequest(const fsetattrRequest& from);

  inline fsetattrRequest& operator=(const fsetattrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const fsetattrRequest& default_instance();

  void Swap(fsetattrRequest* other);

  // implements Message ----------------------------------------------

  fsetattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const fsetattrRequest& from);
  void MergeFrom(const fsetattrRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.Stat stbuf = 1;
  inline bool has_stbuf() const;
  inline void clear_stbuf();
  static const int kStbufFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Stat& stbuf() const;
  inline ::xtreemfs::pbrpc::Stat* mutable_stbuf();
  inline ::xtreemfs::pbrpc::Stat* release_stbuf();
  inline void set_allocated_stbuf(::xtreemfs::pbrpc::Stat* stbuf);

  // required fixed32 to_set = 2;
  inline bool has_to_set() const;
  inline void clear_to_set();
  static const int kToSetFieldNumber = 2;
  inline ::google::protobuf::uint32 to_set() const;
  inline void set_to_set(::google::protobuf::uint32 value);

  // required .xtreemfs.pbrpc.XCap cap = 3;
  inline bool has_cap() const;
  inline void clear_cap();
  static const int kCapFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::XCap& cap() const;
  inline ::xtreemfs::pbrpc::XCap* mutable_cap();
  inline ::xtreemfs::pbrpc::XCap* release_cap();
  inline void set_allocated_cap(::xtreemfs::pbrpc::XCap* cap);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.fsetattrRequest)
 private:
  inline void set_has_stbuf();
  inline void clear_has_stbuf();
  inline void set_has_to_set();
  inline void clear_has_to_set();
  inline void set_has_cap();
  inline void clear_has_cap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::Stat* stbuf_;
  ::xtreemfs::pbrpc::XCap* cap_;
  ::google::protobuf::uint32 to_set_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static fsetattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class getattrRequest : public ::google::protobuf::Message {
 public:
  getattrRequest();
  virtual ~getattrRequest();

  getattrRequest(const getattrRequest& from);

  inline getattrRequest& operator=(const getattrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getattrRequest& default_instance();

  void Swap(getattrRequest* other);

  // implements Message ----------------------------------------------

  getattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getattrRequest& from);
  void MergeFrom(const getattrRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required fixed64 known_etag = 3;
  inline bool has_known_etag() const;
  inline void clear_known_etag();
  static const int kKnownEtagFieldNumber = 3;
  inline ::google::protobuf::uint64 known_etag() const;
  inline void set_known_etag(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.getattrRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_known_etag();
  inline void clear_has_known_etag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::google::protobuf::uint64 known_etag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static getattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class getattrResponse : public ::google::protobuf::Message {
 public:
  getattrResponse();
  virtual ~getattrResponse();

  getattrResponse(const getattrResponse& from);

  inline getattrResponse& operator=(const getattrResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getattrResponse& default_instance();

  void Swap(getattrResponse* other);

  // implements Message ----------------------------------------------

  getattrResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getattrResponse& from);
  void MergeFrom(const getattrResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .xtreemfs.pbrpc.Stat stbuf = 1;
  inline bool has_stbuf() const;
  inline void clear_stbuf();
  static const int kStbufFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::Stat& stbuf() const;
  inline ::xtreemfs::pbrpc::Stat* mutable_stbuf();
  inline ::xtreemfs::pbrpc::Stat* release_stbuf();
  inline void set_allocated_stbuf(::xtreemfs::pbrpc::Stat* stbuf);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.getattrResponse)
 private:
  inline void set_has_stbuf();
  inline void clear_has_stbuf();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::Stat* stbuf_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static getattrResponse* default_instance_;
};
// -------------------------------------------------------------------

class getxattrRequest : public ::google::protobuf::Message {
 public:
  getxattrRequest();
  virtual ~getxattrRequest();

  getxattrRequest(const getxattrRequest& from);

  inline getxattrRequest& operator=(const getxattrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getxattrRequest& default_instance();

  void Swap(getxattrRequest* other);

  // implements Message ----------------------------------------------

  getxattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getxattrRequest& from);
  void MergeFrom(const getxattrRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.getxattrRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static getxattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class getxattrResponse : public ::google::protobuf::Message {
 public:
  getxattrResponse();
  virtual ~getxattrResponse();

  getxattrResponse(const getxattrResponse& from);

  inline getxattrResponse& operator=(const getxattrResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const getxattrResponse& default_instance();

  void Swap(getxattrResponse* other);

  // implements Message ----------------------------------------------

  getxattrResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const getxattrResponse& from);
  void MergeFrom(const getxattrResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bytes value_bytes_string = 2;
  inline bool has_value_bytes_string() const;
  inline void clear_value_bytes_string();
  static const int kValueBytesStringFieldNumber = 2;
  inline const ::std::string& value_bytes_string() const;
  inline void set_value_bytes_string(const ::std::string& value);
  inline void set_value_bytes_string(const char* value);
  inline void set_value_bytes_string(const void* value, size_t size);
  inline ::std::string* mutable_value_bytes_string();
  inline ::std::string* release_value_bytes_string();
  inline void set_allocated_value_bytes_string(::std::string* value_bytes_string);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.getxattrResponse)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_value_bytes_string();
  inline void clear_has_value_bytes_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* value_;
  ::std::string* value_bytes_string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static getxattrResponse* default_instance_;
};
// -------------------------------------------------------------------

class linkRequest : public ::google::protobuf::Message {
 public:
  linkRequest();
  virtual ~linkRequest();

  linkRequest(const linkRequest& from);

  inline linkRequest& operator=(const linkRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const linkRequest& default_instance();

  void Swap(linkRequest* other);

  // implements Message ----------------------------------------------

  linkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const linkRequest& from);
  void MergeFrom(const linkRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string target_path = 2;
  inline bool has_target_path() const;
  inline void clear_target_path();
  static const int kTargetPathFieldNumber = 2;
  inline const ::std::string& target_path() const;
  inline void set_target_path(const ::std::string& value);
  inline void set_target_path(const char* value);
  inline void set_target_path(const char* value, size_t size);
  inline ::std::string* mutable_target_path();
  inline ::std::string* release_target_path();
  inline void set_allocated_target_path(::std::string* target_path);

  // required string link_path = 3;
  inline bool has_link_path() const;
  inline void clear_link_path();
  static const int kLinkPathFieldNumber = 3;
  inline const ::std::string& link_path() const;
  inline void set_link_path(const ::std::string& value);
  inline void set_link_path(const char* value);
  inline void set_link_path(const char* value, size_t size);
  inline ::std::string* mutable_link_path();
  inline ::std::string* release_link_path();
  inline void set_allocated_link_path(::std::string* link_path);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.linkRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_target_path();
  inline void clear_has_target_path();
  inline void set_has_link_path();
  inline void clear_has_link_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* target_path_;
  ::std::string* link_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static linkRequest* default_instance_;
};
// -------------------------------------------------------------------

class listxattrRequest : public ::google::protobuf::Message {
 public:
  listxattrRequest();
  virtual ~listxattrRequest();

  listxattrRequest(const listxattrRequest& from);

  inline listxattrRequest& operator=(const listxattrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const listxattrRequest& default_instance();

  void Swap(listxattrRequest* other);

  // implements Message ----------------------------------------------

  listxattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const listxattrRequest& from);
  void MergeFrom(const listxattrRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required bool names_only = 3;
  inline bool has_names_only() const;
  inline void clear_names_only();
  static const int kNamesOnlyFieldNumber = 3;
  inline bool names_only() const;
  inline void set_names_only(bool value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.listxattrRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_names_only();
  inline void clear_has_names_only();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  bool names_only_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static listxattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class listxattrResponse : public ::google::protobuf::Message {
 public:
  listxattrResponse();
  virtual ~listxattrResponse();

  listxattrResponse(const listxattrResponse& from);

  inline listxattrResponse& operator=(const listxattrResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const listxattrResponse& default_instance();

  void Swap(listxattrResponse* other);

  // implements Message ----------------------------------------------

  listxattrResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const listxattrResponse& from);
  void MergeFrom(const listxattrResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .xtreemfs.pbrpc.XAttr xattrs = 1;
  inline int xattrs_size() const;
  inline void clear_xattrs();
  static const int kXattrsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::XAttr& xattrs(int index) const;
  inline ::xtreemfs::pbrpc::XAttr* mutable_xattrs(int index);
  inline ::xtreemfs::pbrpc::XAttr* add_xattrs();
  inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr >&
      xattrs() const;
  inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr >*
      mutable_xattrs();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.listxattrResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr > xattrs_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static listxattrResponse* default_instance_;
};
// -------------------------------------------------------------------

class mkdirRequest : public ::google::protobuf::Message {
 public:
  mkdirRequest();
  virtual ~mkdirRequest();

  mkdirRequest(const mkdirRequest& from);

  inline mkdirRequest& operator=(const mkdirRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const mkdirRequest& default_instance();

  void Swap(mkdirRequest* other);

  // implements Message ----------------------------------------------

  mkdirRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const mkdirRequest& from);
  void MergeFrom(const mkdirRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required fixed32 mode = 3;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 3;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.mkdirRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_mode();
  inline void clear_has_mode();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::google::protobuf::uint32 mode_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static mkdirRequest* default_instance_;
};
// -------------------------------------------------------------------

class openRequest : public ::google::protobuf::Message {
 public:
  openRequest();
  virtual ~openRequest();

  openRequest(const openRequest& from);

  inline openRequest& operator=(const openRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const openRequest& default_instance();

  void Swap(openRequest* other);

  // implements Message ----------------------------------------------

  openRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const openRequest& from);
  void MergeFrom(const openRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required fixed32 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // required fixed32 mode = 4;
  inline bool has_mode() const;
  inline void clear_mode();
  static const int kModeFieldNumber = 4;
  inline ::google::protobuf::uint32 mode() const;
  inline void set_mode(::google::protobuf::uint32 value);

  // required fixed32 attributes = 5;
  inline bool has_attributes() const;
  inline void clear_attributes();
  static const int kAttributesFieldNumber = 5;
  inline ::google::protobuf::uint32 attributes() const;
  inline void set_attributes(::google::protobuf::uint32 value);

  // optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 6;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 6;
  inline const ::xtreemfs::pbrpc::VivaldiCoordinates& coordinates() const;
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* mutable_coordinates();
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* release_coordinates();
  inline void set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.openRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_flags();
  inline void clear_has_flags();
  inline void set_has_mode();
  inline void clear_has_mode();
  inline void set_has_attributes();
  inline void clear_has_attributes();
  inline void set_has_coordinates();
  inline void clear_has_coordinates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::google::protobuf::uint32 flags_;
  ::google::protobuf::uint32 mode_;
  ::xtreemfs::pbrpc::VivaldiCoordinates* coordinates_;
  ::google::protobuf::uint32 attributes_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static openRequest* default_instance_;
};
// -------------------------------------------------------------------

class openResponse : public ::google::protobuf::Message {
 public:
  openResponse();
  virtual ~openResponse();

  openResponse(const openResponse& from);

  inline openResponse& operator=(const openResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const openResponse& default_instance();

  void Swap(openResponse* other);

  // implements Message ----------------------------------------------

  openResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const openResponse& from);
  void MergeFrom(const openResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.FileCredentials creds = 1;
  inline bool has_creds() const;
  inline void clear_creds();
  static const int kCredsFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::FileCredentials& creds() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_creds();
  inline ::xtreemfs::pbrpc::FileCredentials* release_creds();
  inline void set_allocated_creds(::xtreemfs::pbrpc::FileCredentials* creds);

  // required fixed32 timestamp_s = 2;
  inline bool has_timestamp_s() const;
  inline void clear_timestamp_s();
  static const int kTimestampSFieldNumber = 2;
  inline ::google::protobuf::uint32 timestamp_s() const;
  inline void set_timestamp_s(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.openResponse)
 private:
  inline void set_has_creds();
  inline void clear_has_creds();
  inline void set_has_timestamp_s();
  inline void clear_has_timestamp_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* creds_;
  ::google::protobuf::uint32 timestamp_s_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static openResponse* default_instance_;
};
// -------------------------------------------------------------------

class readdirRequest : public ::google::protobuf::Message {
 public:
  readdirRequest();
  virtual ~readdirRequest();

  readdirRequest(const readdirRequest& from);

  inline readdirRequest& operator=(const readdirRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const readdirRequest& default_instance();

  void Swap(readdirRequest* other);

  // implements Message ----------------------------------------------

  readdirRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const readdirRequest& from);
  void MergeFrom(const readdirRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required fixed64 known_etag = 3;
  inline bool has_known_etag() const;
  inline void clear_known_etag();
  static const int kKnownEtagFieldNumber = 3;
  inline ::google::protobuf::uint64 known_etag() const;
  inline void set_known_etag(::google::protobuf::uint64 value);

  // required fixed32 limit_directory_entries_count = 4;
  inline bool has_limit_directory_entries_count() const;
  inline void clear_limit_directory_entries_count();
  static const int kLimitDirectoryEntriesCountFieldNumber = 4;
  inline ::google::protobuf::uint32 limit_directory_entries_count() const;
  inline void set_limit_directory_entries_count(::google::protobuf::uint32 value);

  // required bool names_only = 5;
  inline bool has_names_only() const;
  inline void clear_names_only();
  static const int kNamesOnlyFieldNumber = 5;
  inline bool names_only() const;
  inline void set_names_only(bool value);

  // required fixed64 seen_directory_entries_count = 6;
  inline bool has_seen_directory_entries_count() const;
  inline void clear_seen_directory_entries_count();
  static const int kSeenDirectoryEntriesCountFieldNumber = 6;
  inline ::google::protobuf::uint64 seen_directory_entries_count() const;
  inline void set_seen_directory_entries_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.readdirRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_known_etag();
  inline void clear_has_known_etag();
  inline void set_has_limit_directory_entries_count();
  inline void clear_has_limit_directory_entries_count();
  inline void set_has_names_only();
  inline void clear_has_names_only();
  inline void set_has_seen_directory_entries_count();
  inline void clear_has_seen_directory_entries_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::google::protobuf::uint64 known_etag_;
  ::google::protobuf::uint32 limit_directory_entries_count_;
  bool names_only_;
  ::google::protobuf::uint64 seen_directory_entries_count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static readdirRequest* default_instance_;
};
// -------------------------------------------------------------------

class readlinkRequest : public ::google::protobuf::Message {
 public:
  readlinkRequest();
  virtual ~readlinkRequest();

  readlinkRequest(const readlinkRequest& from);

  inline readlinkRequest& operator=(const readlinkRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const readlinkRequest& default_instance();

  void Swap(readlinkRequest* other);

  // implements Message ----------------------------------------------

  readlinkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const readlinkRequest& from);
  void MergeFrom(const readlinkRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.readlinkRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static readlinkRequest* default_instance_;
};
// -------------------------------------------------------------------

class readlinkResponse : public ::google::protobuf::Message {
 public:
  readlinkResponse();
  virtual ~readlinkResponse();

  readlinkResponse(const readlinkResponse& from);

  inline readlinkResponse& operator=(const readlinkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const readlinkResponse& default_instance();

  void Swap(readlinkResponse* other);

  // implements Message ----------------------------------------------

  readlinkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const readlinkResponse& from);
  void MergeFrom(const readlinkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string link_target_path = 1;
  inline int link_target_path_size() const;
  inline void clear_link_target_path();
  static const int kLinkTargetPathFieldNumber = 1;
  inline const ::std::string& link_target_path(int index) const;
  inline ::std::string* mutable_link_target_path(int index);
  inline void set_link_target_path(int index, const ::std::string& value);
  inline void set_link_target_path(int index, const char* value);
  inline void set_link_target_path(int index, const char* value, size_t size);
  inline ::std::string* add_link_target_path();
  inline void add_link_target_path(const ::std::string& value);
  inline void add_link_target_path(const char* value);
  inline void add_link_target_path(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& link_target_path() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_link_target_path();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.readlinkResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> link_target_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static readlinkResponse* default_instance_;
};
// -------------------------------------------------------------------

class removexattrRequest : public ::google::protobuf::Message {
 public:
  removexattrRequest();
  virtual ~removexattrRequest();

  removexattrRequest(const removexattrRequest& from);

  inline removexattrRequest& operator=(const removexattrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const removexattrRequest& default_instance();

  void Swap(removexattrRequest* other);

  // implements Message ----------------------------------------------

  removexattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const removexattrRequest& from);
  void MergeFrom(const removexattrRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.removexattrRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::std::string* name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static removexattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class renameRequest : public ::google::protobuf::Message {
 public:
  renameRequest();
  virtual ~renameRequest();

  renameRequest(const renameRequest& from);

  inline renameRequest& operator=(const renameRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const renameRequest& default_instance();

  void Swap(renameRequest* other);

  // implements Message ----------------------------------------------

  renameRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const renameRequest& from);
  void MergeFrom(const renameRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string source_path = 2;
  inline bool has_source_path() const;
  inline void clear_source_path();
  static const int kSourcePathFieldNumber = 2;
  inline const ::std::string& source_path() const;
  inline void set_source_path(const ::std::string& value);
  inline void set_source_path(const char* value);
  inline void set_source_path(const char* value, size_t size);
  inline ::std::string* mutable_source_path();
  inline ::std::string* release_source_path();
  inline void set_allocated_source_path(::std::string* source_path);

  // required string target_path = 3;
  inline bool has_target_path() const;
  inline void clear_target_path();
  static const int kTargetPathFieldNumber = 3;
  inline const ::std::string& target_path() const;
  inline void set_target_path(const ::std::string& value);
  inline void set_target_path(const char* value);
  inline void set_target_path(const char* value, size_t size);
  inline ::std::string* mutable_target_path();
  inline ::std::string* release_target_path();
  inline void set_allocated_target_path(::std::string* target_path);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.renameRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_source_path();
  inline void clear_has_source_path();
  inline void set_has_target_path();
  inline void clear_has_target_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* source_path_;
  ::std::string* target_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static renameRequest* default_instance_;
};
// -------------------------------------------------------------------

class renameResponse : public ::google::protobuf::Message {
 public:
  renameResponse();
  virtual ~renameResponse();

  renameResponse(const renameResponse& from);

  inline renameResponse& operator=(const renameResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const renameResponse& default_instance();

  void Swap(renameResponse* other);

  // implements Message ----------------------------------------------

  renameResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const renameResponse& from);
  void MergeFrom(const renameResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 timestamp_s = 1;
  inline bool has_timestamp_s() const;
  inline void clear_timestamp_s();
  static const int kTimestampSFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp_s() const;
  inline void set_timestamp_s(::google::protobuf::uint32 value);

  // optional .xtreemfs.pbrpc.FileCredentials creds = 2;
  inline bool has_creds() const;
  inline void clear_creds();
  static const int kCredsFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::FileCredentials& creds() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_creds();
  inline ::xtreemfs::pbrpc::FileCredentials* release_creds();
  inline void set_allocated_creds(::xtreemfs::pbrpc::FileCredentials* creds);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.renameResponse)
 private:
  inline void set_has_timestamp_s();
  inline void clear_has_timestamp_s();
  inline void set_has_creds();
  inline void clear_has_creds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* creds_;
  ::google::protobuf::uint32 timestamp_s_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static renameResponse* default_instance_;
};
// -------------------------------------------------------------------

class rmdirRequest : public ::google::protobuf::Message {
 public:
  rmdirRequest();
  virtual ~rmdirRequest();

  rmdirRequest(const rmdirRequest& from);

  inline rmdirRequest& operator=(const rmdirRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const rmdirRequest& default_instance();

  void Swap(rmdirRequest* other);

  // implements Message ----------------------------------------------

  rmdirRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const rmdirRequest& from);
  void MergeFrom(const rmdirRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.rmdirRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static rmdirRequest* default_instance_;
};
// -------------------------------------------------------------------

class setattrRequest : public ::google::protobuf::Message {
 public:
  setattrRequest();
  virtual ~setattrRequest();

  setattrRequest(const setattrRequest& from);

  inline setattrRequest& operator=(const setattrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const setattrRequest& default_instance();

  void Swap(setattrRequest* other);

  // implements Message ----------------------------------------------

  setattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const setattrRequest& from);
  void MergeFrom(const setattrRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required .xtreemfs.pbrpc.Stat stbuf = 3;
  inline bool has_stbuf() const;
  inline void clear_stbuf();
  static const int kStbufFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::Stat& stbuf() const;
  inline ::xtreemfs::pbrpc::Stat* mutable_stbuf();
  inline ::xtreemfs::pbrpc::Stat* release_stbuf();
  inline void set_allocated_stbuf(::xtreemfs::pbrpc::Stat* stbuf);

  // required fixed32 to_set = 4;
  inline bool has_to_set() const;
  inline void clear_to_set();
  static const int kToSetFieldNumber = 4;
  inline ::google::protobuf::uint32 to_set() const;
  inline void set_to_set(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.setattrRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_stbuf();
  inline void clear_has_stbuf();
  inline void set_has_to_set();
  inline void clear_has_to_set();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::xtreemfs::pbrpc::Stat* stbuf_;
  ::google::protobuf::uint32 to_set_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static setattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class setxattrRequest : public ::google::protobuf::Message {
 public:
  setxattrRequest();
  virtual ~setxattrRequest();

  setxattrRequest(const setxattrRequest& from);

  inline setxattrRequest& operator=(const setxattrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const setxattrRequest& default_instance();

  void Swap(setxattrRequest* other);

  // implements Message ----------------------------------------------

  setxattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const setxattrRequest& from);
  void MergeFrom(const setxattrRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string value = 4;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 4;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // optional bytes value_bytes_string = 6;
  inline bool has_value_bytes_string() const;
  inline void clear_value_bytes_string();
  static const int kValueBytesStringFieldNumber = 6;
  inline const ::std::string& value_bytes_string() const;
  inline void set_value_bytes_string(const ::std::string& value);
  inline void set_value_bytes_string(const char* value);
  inline void set_value_bytes_string(const void* value, size_t size);
  inline ::std::string* mutable_value_bytes_string();
  inline ::std::string* release_value_bytes_string();
  inline void set_allocated_value_bytes_string(::std::string* value_bytes_string);

  // required fixed32 flags = 5;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 5;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.setxattrRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_value_bytes_string();
  inline void clear_has_value_bytes_string();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::std::string* name_;
  ::std::string* value_;
  ::std::string* value_bytes_string_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static setxattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class statvfsRequest : public ::google::protobuf::Message {
 public:
  statvfsRequest();
  virtual ~statvfsRequest();

  statvfsRequest(const statvfsRequest& from);

  inline statvfsRequest& operator=(const statvfsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const statvfsRequest& default_instance();

  void Swap(statvfsRequest* other);

  // implements Message ----------------------------------------------

  statvfsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const statvfsRequest& from);
  void MergeFrom(const statvfsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required fixed64 known_etag = 5;
  inline bool has_known_etag() const;
  inline void clear_known_etag();
  static const int kKnownEtagFieldNumber = 5;
  inline ::google::protobuf::uint64 known_etag() const;
  inline void set_known_etag(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.statvfsRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_known_etag();
  inline void clear_has_known_etag();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::google::protobuf::uint64 known_etag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static statvfsRequest* default_instance_;
};
// -------------------------------------------------------------------

class symlinkRequest : public ::google::protobuf::Message {
 public:
  symlinkRequest();
  virtual ~symlinkRequest();

  symlinkRequest(const symlinkRequest& from);

  inline symlinkRequest& operator=(const symlinkRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const symlinkRequest& default_instance();

  void Swap(symlinkRequest* other);

  // implements Message ----------------------------------------------

  symlinkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const symlinkRequest& from);
  void MergeFrom(const symlinkRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string target_path = 2;
  inline bool has_target_path() const;
  inline void clear_target_path();
  static const int kTargetPathFieldNumber = 2;
  inline const ::std::string& target_path() const;
  inline void set_target_path(const ::std::string& value);
  inline void set_target_path(const char* value);
  inline void set_target_path(const char* value, size_t size);
  inline ::std::string* mutable_target_path();
  inline ::std::string* release_target_path();
  inline void set_allocated_target_path(::std::string* target_path);

  // required string link_path = 3;
  inline bool has_link_path() const;
  inline void clear_link_path();
  static const int kLinkPathFieldNumber = 3;
  inline const ::std::string& link_path() const;
  inline void set_link_path(const ::std::string& value);
  inline void set_link_path(const char* value);
  inline void set_link_path(const char* value, size_t size);
  inline ::std::string* mutable_link_path();
  inline ::std::string* release_link_path();
  inline void set_allocated_link_path(::std::string* link_path);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.symlinkRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_target_path();
  inline void clear_has_target_path();
  inline void set_has_link_path();
  inline void clear_has_link_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* target_path_;
  ::std::string* link_path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static symlinkRequest* default_instance_;
};
// -------------------------------------------------------------------

class unlinkRequest : public ::google::protobuf::Message {
 public:
  unlinkRequest();
  virtual ~unlinkRequest();

  unlinkRequest(const unlinkRequest& from);

  inline unlinkRequest& operator=(const unlinkRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const unlinkRequest& default_instance();

  void Swap(unlinkRequest* other);

  // implements Message ----------------------------------------------

  unlinkRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unlinkRequest& from);
  void MergeFrom(const unlinkRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.unlinkRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static unlinkRequest* default_instance_;
};
// -------------------------------------------------------------------

class unlinkResponse : public ::google::protobuf::Message {
 public:
  unlinkResponse();
  virtual ~unlinkResponse();

  unlinkResponse(const unlinkResponse& from);

  inline unlinkResponse& operator=(const unlinkResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const unlinkResponse& default_instance();

  void Swap(unlinkResponse* other);

  // implements Message ----------------------------------------------

  unlinkResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const unlinkResponse& from);
  void MergeFrom(const unlinkResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 timestamp_s = 1;
  inline bool has_timestamp_s() const;
  inline void clear_timestamp_s();
  static const int kTimestampSFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp_s() const;
  inline void set_timestamp_s(::google::protobuf::uint32 value);

  // optional .xtreemfs.pbrpc.FileCredentials creds = 2;
  inline bool has_creds() const;
  inline void clear_creds();
  static const int kCredsFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::FileCredentials& creds() const;
  inline ::xtreemfs::pbrpc::FileCredentials* mutable_creds();
  inline ::xtreemfs::pbrpc::FileCredentials* release_creds();
  inline void set_allocated_creds(::xtreemfs::pbrpc::FileCredentials* creds);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.unlinkResponse)
 private:
  inline void set_has_timestamp_s();
  inline void clear_has_timestamp_s();
  inline void set_has_creds();
  inline void clear_has_creds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::FileCredentials* creds_;
  ::google::protobuf::uint32 timestamp_s_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static unlinkResponse* default_instance_;
};
// -------------------------------------------------------------------

class accessRequest : public ::google::protobuf::Message {
 public:
  accessRequest();
  virtual ~accessRequest();

  accessRequest(const accessRequest& from);

  inline accessRequest& operator=(const accessRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const accessRequest& default_instance();

  void Swap(accessRequest* other);

  // implements Message ----------------------------------------------

  accessRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const accessRequest& from);
  void MergeFrom(const accessRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required fixed32 flags = 3;
  inline bool has_flags() const;
  inline void clear_flags();
  static const int kFlagsFieldNumber = 3;
  inline ::google::protobuf::uint32 flags() const;
  inline void set_flags(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.accessRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_flags();
  inline void clear_has_flags();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;
  ::std::string* path_;
  ::google::protobuf::uint32 flags_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static accessRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_check_file_existsRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_check_file_existsRequest();
  virtual ~xtreemfs_check_file_existsRequest();

  xtreemfs_check_file_existsRequest(const xtreemfs_check_file_existsRequest& from);

  inline xtreemfs_check_file_existsRequest& operator=(const xtreemfs_check_file_existsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_check_file_existsRequest& default_instance();

  void Swap(xtreemfs_check_file_existsRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_check_file_existsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_check_file_existsRequest& from);
  void MergeFrom(const xtreemfs_check_file_existsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_id = 1;
  inline bool has_volume_id() const;
  inline void clear_volume_id();
  static const int kVolumeIdFieldNumber = 1;
  inline const ::std::string& volume_id() const;
  inline void set_volume_id(const ::std::string& value);
  inline void set_volume_id(const char* value);
  inline void set_volume_id(const char* value, size_t size);
  inline ::std::string* mutable_volume_id();
  inline ::std::string* release_volume_id();
  inline void set_allocated_volume_id(::std::string* volume_id);

  // repeated string file_ids = 2;
  inline int file_ids_size() const;
  inline void clear_file_ids();
  static const int kFileIdsFieldNumber = 2;
  inline const ::std::string& file_ids(int index) const;
  inline ::std::string* mutable_file_ids(int index);
  inline void set_file_ids(int index, const ::std::string& value);
  inline void set_file_ids(int index, const char* value);
  inline void set_file_ids(int index, const char* value, size_t size);
  inline ::std::string* add_file_ids();
  inline void add_file_ids(const ::std::string& value);
  inline void add_file_ids(const char* value);
  inline void add_file_ids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& file_ids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_file_ids();

  // required string osd_uuid = 3;
  inline bool has_osd_uuid() const;
  inline void clear_osd_uuid();
  static const int kOsdUuidFieldNumber = 3;
  inline const ::std::string& osd_uuid() const;
  inline void set_osd_uuid(const ::std::string& value);
  inline void set_osd_uuid(const char* value);
  inline void set_osd_uuid(const char* value, size_t size);
  inline ::std::string* mutable_osd_uuid();
  inline ::std::string* release_osd_uuid();
  inline void set_allocated_osd_uuid(::std::string* osd_uuid);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_check_file_existsRequest)
 private:
  inline void set_has_volume_id();
  inline void clear_has_volume_id();
  inline void set_has_osd_uuid();
  inline void clear_has_osd_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_id_;
  ::google::protobuf::RepeatedPtrField< ::std::string> file_ids_;
  ::std::string* osd_uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_check_file_existsRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_check_file_existsResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_check_file_existsResponse();
  virtual ~xtreemfs_check_file_existsResponse();

  xtreemfs_check_file_existsResponse(const xtreemfs_check_file_existsResponse& from);

  inline xtreemfs_check_file_existsResponse& operator=(const xtreemfs_check_file_existsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_check_file_existsResponse& default_instance();

  void Swap(xtreemfs_check_file_existsResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_check_file_existsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_check_file_existsResponse& from);
  void MergeFrom(const xtreemfs_check_file_existsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef xtreemfs_check_file_existsResponse_FILE_STATE FILE_STATE;
  static const FILE_STATE DELETED = xtreemfs_check_file_existsResponse_FILE_STATE_DELETED;
  static const FILE_STATE REGISTERED = xtreemfs_check_file_existsResponse_FILE_STATE_REGISTERED;
  static const FILE_STATE ABANDONED = xtreemfs_check_file_existsResponse_FILE_STATE_ABANDONED;
  static inline bool FILE_STATE_IsValid(int value) {
    return xtreemfs_check_file_existsResponse_FILE_STATE_IsValid(value);
  }
  static const FILE_STATE FILE_STATE_MIN =
    xtreemfs_check_file_existsResponse_FILE_STATE_FILE_STATE_MIN;
  static const FILE_STATE FILE_STATE_MAX =
    xtreemfs_check_file_existsResponse_FILE_STATE_FILE_STATE_MAX;
  static const int FILE_STATE_ARRAYSIZE =
    xtreemfs_check_file_existsResponse_FILE_STATE_FILE_STATE_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  FILE_STATE_descriptor() {
    return xtreemfs_check_file_existsResponse_FILE_STATE_descriptor();
  }
  static inline const ::std::string& FILE_STATE_Name(FILE_STATE value) {
    return xtreemfs_check_file_existsResponse_FILE_STATE_Name(value);
  }
  static inline bool FILE_STATE_Parse(const ::std::string& name,
      FILE_STATE* value) {
    return xtreemfs_check_file_existsResponse_FILE_STATE_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required bool volume_exists = 1;
  inline bool has_volume_exists() const;
  inline void clear_volume_exists();
  static const int kVolumeExistsFieldNumber = 1;
  inline bool volume_exists() const;
  inline void set_volume_exists(bool value);

  // repeated .xtreemfs.pbrpc.xtreemfs_check_file_existsResponse.FILE_STATE file_states = 2 [packed = true];
  inline int file_states_size() const;
  inline void clear_file_states();
  static const int kFileStatesFieldNumber = 2;
  inline ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE file_states(int index) const;
  inline void set_file_states(int index, ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE value);
  inline void add_file_states(::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE value);
  inline const ::google::protobuf::RepeatedField<int>& file_states() const;
  inline ::google::protobuf::RepeatedField<int>* mutable_file_states();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_check_file_existsResponse)
 private:
  inline void set_has_volume_exists();
  inline void clear_has_volume_exists();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedField<int> file_states_;
  mutable int _file_states_cached_byte_size_;
  bool volume_exists_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_check_file_existsResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_dump_restore_databaseRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_dump_restore_databaseRequest();
  virtual ~xtreemfs_dump_restore_databaseRequest();

  xtreemfs_dump_restore_databaseRequest(const xtreemfs_dump_restore_databaseRequest& from);

  inline xtreemfs_dump_restore_databaseRequest& operator=(const xtreemfs_dump_restore_databaseRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_dump_restore_databaseRequest& default_instance();

  void Swap(xtreemfs_dump_restore_databaseRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_dump_restore_databaseRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_dump_restore_databaseRequest& from);
  void MergeFrom(const xtreemfs_dump_restore_databaseRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string dump_file = 1;
  inline bool has_dump_file() const;
  inline void clear_dump_file();
  static const int kDumpFileFieldNumber = 1;
  inline const ::std::string& dump_file() const;
  inline void set_dump_file(const ::std::string& value);
  inline void set_dump_file(const char* value);
  inline void set_dump_file(const char* value, size_t size);
  inline ::std::string* mutable_dump_file();
  inline ::std::string* release_dump_file();
  inline void set_allocated_dump_file(::std::string* dump_file);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_dump_restore_databaseRequest)
 private:
  inline void set_has_dump_file();
  inline void clear_has_dump_file();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* dump_file_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_dump_restore_databaseRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_get_suitable_osdsRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_get_suitable_osdsRequest();
  virtual ~xtreemfs_get_suitable_osdsRequest();

  xtreemfs_get_suitable_osdsRequest(const xtreemfs_get_suitable_osdsRequest& from);

  inline xtreemfs_get_suitable_osdsRequest& operator=(const xtreemfs_get_suitable_osdsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_get_suitable_osdsRequest& default_instance();

  void Swap(xtreemfs_get_suitable_osdsRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_get_suitable_osdsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_get_suitable_osdsRequest& from);
  void MergeFrom(const xtreemfs_get_suitable_osdsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string volume_name = 4;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 4;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required fixed32 num_osds = 2;
  inline bool has_num_osds() const;
  inline void clear_num_osds();
  static const int kNumOsdsFieldNumber = 2;
  inline ::google::protobuf::uint32 num_osds() const;
  inline void set_num_osds(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_get_suitable_osdsRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_num_osds();
  inline void clear_has_num_osds();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::std::string* path_;
  ::std::string* volume_name_;
  ::google::protobuf::uint32 num_osds_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_get_suitable_osdsRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_get_suitable_osdsResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_get_suitable_osdsResponse();
  virtual ~xtreemfs_get_suitable_osdsResponse();

  xtreemfs_get_suitable_osdsResponse(const xtreemfs_get_suitable_osdsResponse& from);

  inline xtreemfs_get_suitable_osdsResponse& operator=(const xtreemfs_get_suitable_osdsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_get_suitable_osdsResponse& default_instance();

  void Swap(xtreemfs_get_suitable_osdsResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_get_suitable_osdsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_get_suitable_osdsResponse& from);
  void MergeFrom(const xtreemfs_get_suitable_osdsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string osd_uuids = 1;
  inline int osd_uuids_size() const;
  inline void clear_osd_uuids();
  static const int kOsdUuidsFieldNumber = 1;
  inline const ::std::string& osd_uuids(int index) const;
  inline ::std::string* mutable_osd_uuids(int index);
  inline void set_osd_uuids(int index, const ::std::string& value);
  inline void set_osd_uuids(int index, const char* value);
  inline void set_osd_uuids(int index, const char* value, size_t size);
  inline ::std::string* add_osd_uuids();
  inline void add_osd_uuids(const ::std::string& value);
  inline void add_osd_uuids(const char* value);
  inline void add_osd_uuids(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& osd_uuids() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_osd_uuids();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_get_suitable_osdsResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> osd_uuids_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_get_suitable_osdsResponse* default_instance_;
};
// -------------------------------------------------------------------

class timestampResponse : public ::google::protobuf::Message {
 public:
  timestampResponse();
  virtual ~timestampResponse();

  timestampResponse(const timestampResponse& from);

  inline timestampResponse& operator=(const timestampResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const timestampResponse& default_instance();

  void Swap(timestampResponse* other);

  // implements Message ----------------------------------------------

  timestampResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const timestampResponse& from);
  void MergeFrom(const timestampResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 timestamp_s = 1;
  inline bool has_timestamp_s() const;
  inline void clear_timestamp_s();
  static const int kTimestampSFieldNumber = 1;
  inline ::google::protobuf::uint32 timestamp_s() const;
  inline void set_timestamp_s(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.timestampResponse)
 private:
  inline void set_has_timestamp_s();
  inline void clear_has_timestamp_s();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 timestamp_s_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static timestampResponse* default_instance_;
};
// -------------------------------------------------------------------

class stringMessage : public ::google::protobuf::Message {
 public:
  stringMessage();
  virtual ~stringMessage();

  stringMessage(const stringMessage& from);

  inline stringMessage& operator=(const stringMessage& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const stringMessage& default_instance();

  void Swap(stringMessage* other);

  // implements Message ----------------------------------------------

  stringMessage* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const stringMessage& from);
  void MergeFrom(const stringMessage& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string a_string = 1;
  inline bool has_a_string() const;
  inline void clear_a_string();
  static const int kAStringFieldNumber = 1;
  inline const ::std::string& a_string() const;
  inline void set_a_string(const ::std::string& value);
  inline void set_a_string(const char* value);
  inline void set_a_string(const char* value, size_t size);
  inline ::std::string* mutable_a_string();
  inline ::std::string* release_a_string();
  inline void set_allocated_a_string(::std::string* a_string);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.stringMessage)
 private:
  inline void set_has_a_string();
  inline void clear_has_a_string();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* a_string_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static stringMessage* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_listdirRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_listdirRequest();
  virtual ~xtreemfs_listdirRequest();

  xtreemfs_listdirRequest(const xtreemfs_listdirRequest& from);

  inline xtreemfs_listdirRequest& operator=(const xtreemfs_listdirRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_listdirRequest& default_instance();

  void Swap(xtreemfs_listdirRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_listdirRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_listdirRequest& from);
  void MergeFrom(const xtreemfs_listdirRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_listdirRequest)
 private:
  inline void set_has_path();
  inline void clear_has_path();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_listdirRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_listdirResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_listdirResponse();
  virtual ~xtreemfs_listdirResponse();

  xtreemfs_listdirResponse(const xtreemfs_listdirResponse& from);

  inline xtreemfs_listdirResponse& operator=(const xtreemfs_listdirResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_listdirResponse& default_instance();

  void Swap(xtreemfs_listdirResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_listdirResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_listdirResponse& from);
  void MergeFrom(const xtreemfs_listdirResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string names = 1;
  inline int names_size() const;
  inline void clear_names();
  static const int kNamesFieldNumber = 1;
  inline const ::std::string& names(int index) const;
  inline ::std::string* mutable_names(int index);
  inline void set_names(int index, const ::std::string& value);
  inline void set_names(int index, const char* value);
  inline void set_names(int index, const char* value, size_t size);
  inline ::std::string* add_names();
  inline void add_names(const ::std::string& value);
  inline void add_names(const char* value);
  inline void add_names(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& names() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_names();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_listdirResponse)
 private:

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::std::string> names_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_listdirResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_replica_addRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_replica_addRequest();
  virtual ~xtreemfs_replica_addRequest();

  xtreemfs_replica_addRequest(const xtreemfs_replica_addRequest& from);

  inline xtreemfs_replica_addRequest& operator=(const xtreemfs_replica_addRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_replica_addRequest& default_instance();

  void Swap(xtreemfs_replica_addRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_replica_addRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_replica_addRequest& from);
  void MergeFrom(const xtreemfs_replica_addRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string volume_name = 4;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 4;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required .xtreemfs.pbrpc.Replica new_replica = 2;
  inline bool has_new_replica() const;
  inline void clear_new_replica();
  static const int kNewReplicaFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::Replica& new_replica() const;
  inline ::xtreemfs::pbrpc::Replica* mutable_new_replica();
  inline ::xtreemfs::pbrpc::Replica* release_new_replica();
  inline void set_allocated_new_replica(::xtreemfs::pbrpc::Replica* new_replica);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_replica_addRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_new_replica();
  inline void clear_has_new_replica();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::std::string* path_;
  ::std::string* volume_name_;
  ::xtreemfs::pbrpc::Replica* new_replica_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_replica_addRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_replica_addResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_replica_addResponse();
  virtual ~xtreemfs_replica_addResponse();

  xtreemfs_replica_addResponse(const xtreemfs_replica_addResponse& from);

  inline xtreemfs_replica_addResponse& operator=(const xtreemfs_replica_addResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_replica_addResponse& default_instance();

  void Swap(xtreemfs_replica_addResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_replica_addResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_replica_addResponse& from);
  void MergeFrom(const xtreemfs_replica_addResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required int32 expected_xlocset_version = 2;
  inline bool has_expected_xlocset_version() const;
  inline void clear_expected_xlocset_version();
  static const int kExpectedXlocsetVersionFieldNumber = 2;
  inline ::google::protobuf::int32 expected_xlocset_version() const;
  inline void set_expected_xlocset_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_replica_addResponse)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_expected_xlocset_version();
  inline void clear_has_expected_xlocset_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::google::protobuf::int32 expected_xlocset_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_replica_addResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_replica_listRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_replica_listRequest();
  virtual ~xtreemfs_replica_listRequest();

  xtreemfs_replica_listRequest(const xtreemfs_replica_listRequest& from);

  inline xtreemfs_replica_listRequest& operator=(const xtreemfs_replica_listRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_replica_listRequest& default_instance();

  void Swap(xtreemfs_replica_listRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_replica_listRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_replica_listRequest& from);
  void MergeFrom(const xtreemfs_replica_listRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string volume_name = 3;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 3;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_replica_listRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_volume_name();
  inline void clear_has_volume_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::std::string* path_;
  ::std::string* volume_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_replica_listRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_get_xlocsetRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_get_xlocsetRequest();
  virtual ~xtreemfs_get_xlocsetRequest();

  xtreemfs_get_xlocsetRequest(const xtreemfs_get_xlocsetRequest& from);

  inline xtreemfs_get_xlocsetRequest& operator=(const xtreemfs_get_xlocsetRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_get_xlocsetRequest& default_instance();

  void Swap(xtreemfs_get_xlocsetRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_get_xlocsetRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_get_xlocsetRequest& from);
  void MergeFrom(const xtreemfs_get_xlocsetRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // optional string path = 2;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 2;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string volume_name = 3;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 3;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // optional .xtreemfs.pbrpc.XCap xcap = 4;
  inline bool has_xcap() const;
  inline void clear_xcap();
  static const int kXcapFieldNumber = 4;
  inline const ::xtreemfs::pbrpc::XCap& xcap() const;
  inline ::xtreemfs::pbrpc::XCap* mutable_xcap();
  inline ::xtreemfs::pbrpc::XCap* release_xcap();
  inline void set_allocated_xcap(::xtreemfs::pbrpc::XCap* xcap);

  // optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 5;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 5;
  inline const ::xtreemfs::pbrpc::VivaldiCoordinates& coordinates() const;
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* mutable_coordinates();
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* release_coordinates();
  inline void set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_get_xlocsetRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_xcap();
  inline void clear_has_xcap();
  inline void set_has_coordinates();
  inline void clear_has_coordinates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::std::string* path_;
  ::std::string* volume_name_;
  ::xtreemfs::pbrpc::XCap* xcap_;
  ::xtreemfs::pbrpc::VivaldiCoordinates* coordinates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_get_xlocsetRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_replica_removeRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_replica_removeRequest();
  virtual ~xtreemfs_replica_removeRequest();

  xtreemfs_replica_removeRequest(const xtreemfs_replica_removeRequest& from);

  inline xtreemfs_replica_removeRequest& operator=(const xtreemfs_replica_removeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_replica_removeRequest& default_instance();

  void Swap(xtreemfs_replica_removeRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_replica_removeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_replica_removeRequest& from);
  void MergeFrom(const xtreemfs_replica_removeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // optional string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string volume_name = 4;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 4;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // required string osd_uuid = 2;
  inline bool has_osd_uuid() const;
  inline void clear_osd_uuid();
  static const int kOsdUuidFieldNumber = 2;
  inline const ::std::string& osd_uuid() const;
  inline void set_osd_uuid(const ::std::string& value);
  inline void set_osd_uuid(const char* value);
  inline void set_osd_uuid(const char* value, size_t size);
  inline ::std::string* mutable_osd_uuid();
  inline ::std::string* release_osd_uuid();
  inline void set_allocated_osd_uuid(::std::string* osd_uuid);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_replica_removeRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_osd_uuid();
  inline void clear_has_osd_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::std::string* path_;
  ::std::string* volume_name_;
  ::std::string* osd_uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_replica_removeRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_replica_removeResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_replica_removeResponse();
  virtual ~xtreemfs_replica_removeResponse();

  xtreemfs_replica_removeResponse(const xtreemfs_replica_removeResponse& from);

  inline xtreemfs_replica_removeResponse& operator=(const xtreemfs_replica_removeResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_replica_removeResponse& default_instance();

  void Swap(xtreemfs_replica_removeResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_replica_removeResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_replica_removeResponse& from);
  void MergeFrom(const xtreemfs_replica_removeResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required int32 expected_xlocset_version = 2;
  inline bool has_expected_xlocset_version() const;
  inline void clear_expected_xlocset_version();
  static const int kExpectedXlocsetVersionFieldNumber = 2;
  inline ::google::protobuf::int32 expected_xlocset_version() const;
  inline void set_expected_xlocset_version(::google::protobuf::int32 value);

  // required .xtreemfs.pbrpc.XLocSet unlink_xloc = 3;
  inline bool has_unlink_xloc() const;
  inline void clear_unlink_xloc();
  static const int kUnlinkXlocFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::XLocSet& unlink_xloc() const;
  inline ::xtreemfs::pbrpc::XLocSet* mutable_unlink_xloc();
  inline ::xtreemfs::pbrpc::XLocSet* release_unlink_xloc();
  inline void set_allocated_unlink_xloc(::xtreemfs::pbrpc::XLocSet* unlink_xloc);

  // required .xtreemfs.pbrpc.XCap unlink_xcap = 4;
  inline bool has_unlink_xcap() const;
  inline void clear_unlink_xcap();
  static const int kUnlinkXcapFieldNumber = 4;
  inline const ::xtreemfs::pbrpc::XCap& unlink_xcap() const;
  inline ::xtreemfs::pbrpc::XCap* mutable_unlink_xcap();
  inline ::xtreemfs::pbrpc::XCap* release_unlink_xcap();
  inline void set_allocated_unlink_xcap(::xtreemfs::pbrpc::XCap* unlink_xcap);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_replica_removeResponse)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_expected_xlocset_version();
  inline void clear_has_expected_xlocset_version();
  inline void set_has_unlink_xloc();
  inline void clear_has_unlink_xloc();
  inline void set_has_unlink_xcap();
  inline void clear_has_unlink_xcap();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::xtreemfs::pbrpc::XLocSet* unlink_xloc_;
  ::xtreemfs::pbrpc::XCap* unlink_xcap_;
  ::google::protobuf::int32 expected_xlocset_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_replica_removeResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_restore_fileRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_restore_fileRequest();
  virtual ~xtreemfs_restore_fileRequest();

  xtreemfs_restore_fileRequest(const xtreemfs_restore_fileRequest& from);

  inline xtreemfs_restore_fileRequest& operator=(const xtreemfs_restore_fileRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_restore_fileRequest& default_instance();

  void Swap(xtreemfs_restore_fileRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_restore_fileRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_restore_fileRequest& from);
  void MergeFrom(const xtreemfs_restore_fileRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_path = 1;
  inline bool has_file_path() const;
  inline void clear_file_path();
  static const int kFilePathFieldNumber = 1;
  inline const ::std::string& file_path() const;
  inline void set_file_path(const ::std::string& value);
  inline void set_file_path(const char* value);
  inline void set_file_path(const char* value, size_t size);
  inline ::std::string* mutable_file_path();
  inline ::std::string* release_file_path();
  inline void set_allocated_file_path(::std::string* file_path);

  // required string file_id = 2;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 2;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required fixed64 file_size = 3;
  inline bool has_file_size() const;
  inline void clear_file_size();
  static const int kFileSizeFieldNumber = 3;
  inline ::google::protobuf::uint64 file_size() const;
  inline void set_file_size(::google::protobuf::uint64 value);

  // required string osd_uuid = 4;
  inline bool has_osd_uuid() const;
  inline void clear_osd_uuid();
  static const int kOsdUuidFieldNumber = 4;
  inline const ::std::string& osd_uuid() const;
  inline void set_osd_uuid(const ::std::string& value);
  inline void set_osd_uuid(const char* value);
  inline void set_osd_uuid(const char* value, size_t size);
  inline ::std::string* mutable_osd_uuid();
  inline ::std::string* release_osd_uuid();
  inline void set_allocated_osd_uuid(::std::string* osd_uuid);

  // required fixed32 stripe_size = 5;
  inline bool has_stripe_size() const;
  inline void clear_stripe_size();
  static const int kStripeSizeFieldNumber = 5;
  inline ::google::protobuf::uint32 stripe_size() const;
  inline void set_stripe_size(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_restore_fileRequest)
 private:
  inline void set_has_file_path();
  inline void clear_has_file_path();
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_file_size();
  inline void clear_has_file_size();
  inline void set_has_osd_uuid();
  inline void clear_has_osd_uuid();
  inline void set_has_stripe_size();
  inline void clear_has_stripe_size();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_path_;
  ::std::string* file_id_;
  ::google::protobuf::uint64 file_size_;
  ::std::string* osd_uuid_;
  ::google::protobuf::uint32 stripe_size_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_restore_fileRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_rmvolRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_rmvolRequest();
  virtual ~xtreemfs_rmvolRequest();

  xtreemfs_rmvolRequest(const xtreemfs_rmvolRequest& from);

  inline xtreemfs_rmvolRequest& operator=(const xtreemfs_rmvolRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_rmvolRequest& default_instance();

  void Swap(xtreemfs_rmvolRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_rmvolRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_rmvolRequest& from);
  void MergeFrom(const xtreemfs_rmvolRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string volume_name = 1;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 1;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_rmvolRequest)
 private:
  inline void set_has_volume_name();
  inline void clear_has_volume_name();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* volume_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_rmvolRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_update_file_sizeRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_update_file_sizeRequest();
  virtual ~xtreemfs_update_file_sizeRequest();

  xtreemfs_update_file_sizeRequest(const xtreemfs_update_file_sizeRequest& from);

  inline xtreemfs_update_file_sizeRequest& operator=(const xtreemfs_update_file_sizeRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_update_file_sizeRequest& default_instance();

  void Swap(xtreemfs_update_file_sizeRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_update_file_sizeRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_update_file_sizeRequest& from);
  void MergeFrom(const xtreemfs_update_file_sizeRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.XCap xcap = 1;
  inline bool has_xcap() const;
  inline void clear_xcap();
  static const int kXcapFieldNumber = 1;
  inline const ::xtreemfs::pbrpc::XCap& xcap() const;
  inline ::xtreemfs::pbrpc::XCap* mutable_xcap();
  inline ::xtreemfs::pbrpc::XCap* release_xcap();
  inline void set_allocated_xcap(::xtreemfs::pbrpc::XCap* xcap);

  // required .xtreemfs.pbrpc.OSDWriteResponse osd_write_response = 2;
  inline bool has_osd_write_response() const;
  inline void clear_osd_write_response();
  static const int kOsdWriteResponseFieldNumber = 2;
  inline const ::xtreemfs::pbrpc::OSDWriteResponse& osd_write_response() const;
  inline ::xtreemfs::pbrpc::OSDWriteResponse* mutable_osd_write_response();
  inline ::xtreemfs::pbrpc::OSDWriteResponse* release_osd_write_response();
  inline void set_allocated_osd_write_response(::xtreemfs::pbrpc::OSDWriteResponse* osd_write_response);

  // optional bool close_file = 3;
  inline bool has_close_file() const;
  inline void clear_close_file();
  static const int kCloseFileFieldNumber = 3;
  inline bool close_file() const;
  inline void set_close_file(bool value);

  // optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 4;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 4;
  inline const ::xtreemfs::pbrpc::VivaldiCoordinates& coordinates() const;
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* mutable_coordinates();
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* release_coordinates();
  inline void set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_update_file_sizeRequest)
 private:
  inline void set_has_xcap();
  inline void clear_has_xcap();
  inline void set_has_osd_write_response();
  inline void clear_has_osd_write_response();
  inline void set_has_close_file();
  inline void clear_has_close_file();
  inline void set_has_coordinates();
  inline void clear_has_coordinates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::XCap* xcap_;
  ::xtreemfs::pbrpc::OSDWriteResponse* osd_write_response_;
  ::xtreemfs::pbrpc::VivaldiCoordinates* coordinates_;
  bool close_file_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_update_file_sizeRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_set_replica_update_policyRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_set_replica_update_policyRequest();
  virtual ~xtreemfs_set_replica_update_policyRequest();

  xtreemfs_set_replica_update_policyRequest(const xtreemfs_set_replica_update_policyRequest& from);

  inline xtreemfs_set_replica_update_policyRequest& operator=(const xtreemfs_set_replica_update_policyRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_set_replica_update_policyRequest& default_instance();

  void Swap(xtreemfs_set_replica_update_policyRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_set_replica_update_policyRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_set_replica_update_policyRequest& from);
  void MergeFrom(const xtreemfs_set_replica_update_policyRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required string update_policy = 2;
  inline bool has_update_policy() const;
  inline void clear_update_policy();
  static const int kUpdatePolicyFieldNumber = 2;
  inline const ::std::string& update_policy() const;
  inline void set_update_policy(const ::std::string& value);
  inline void set_update_policy(const char* value);
  inline void set_update_policy(const char* value, size_t size);
  inline ::std::string* mutable_update_policy();
  inline ::std::string* release_update_policy();
  inline void set_allocated_update_policy(::std::string* update_policy);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_set_replica_update_policyRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_update_policy();
  inline void clear_has_update_policy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::std::string* update_policy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_set_replica_update_policyRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_set_replica_update_policyResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_set_replica_update_policyResponse();
  virtual ~xtreemfs_set_replica_update_policyResponse();

  xtreemfs_set_replica_update_policyResponse(const xtreemfs_set_replica_update_policyResponse& from);

  inline xtreemfs_set_replica_update_policyResponse& operator=(const xtreemfs_set_replica_update_policyResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_set_replica_update_policyResponse& default_instance();

  void Swap(xtreemfs_set_replica_update_policyResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_set_replica_update_policyResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_set_replica_update_policyResponse& from);
  void MergeFrom(const xtreemfs_set_replica_update_policyResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string old_update_policy = 1;
  inline bool has_old_update_policy() const;
  inline void clear_old_update_policy();
  static const int kOldUpdatePolicyFieldNumber = 1;
  inline const ::std::string& old_update_policy() const;
  inline void set_old_update_policy(const ::std::string& value);
  inline void set_old_update_policy(const char* value);
  inline void set_old_update_policy(const char* value, size_t size);
  inline ::std::string* mutable_old_update_policy();
  inline ::std::string* release_old_update_policy();
  inline void set_allocated_old_update_policy(::std::string* old_update_policy);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_set_replica_update_policyResponse)
 private:
  inline void set_has_old_update_policy();
  inline void clear_has_old_update_policy();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* old_update_policy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_set_replica_update_policyResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_set_read_only_xattrRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_set_read_only_xattrRequest();
  virtual ~xtreemfs_set_read_only_xattrRequest();

  xtreemfs_set_read_only_xattrRequest(const xtreemfs_set_read_only_xattrRequest& from);

  inline xtreemfs_set_read_only_xattrRequest& operator=(const xtreemfs_set_read_only_xattrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_set_read_only_xattrRequest& default_instance();

  void Swap(xtreemfs_set_read_only_xattrRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_set_read_only_xattrRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_set_read_only_xattrRequest& from);
  void MergeFrom(const xtreemfs_set_read_only_xattrRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required bool value = 2;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 2;
  inline bool value() const;
  inline void set_value(bool value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_set_read_only_xattrRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_value();
  inline void clear_has_value();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  bool value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_set_read_only_xattrRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_set_read_only_xattrResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_set_read_only_xattrResponse();
  virtual ~xtreemfs_set_read_only_xattrResponse();

  xtreemfs_set_read_only_xattrResponse(const xtreemfs_set_read_only_xattrResponse& from);

  inline xtreemfs_set_read_only_xattrResponse& operator=(const xtreemfs_set_read_only_xattrResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_set_read_only_xattrResponse& default_instance();

  void Swap(xtreemfs_set_read_only_xattrResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_set_read_only_xattrResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_set_read_only_xattrResponse& from);
  void MergeFrom(const xtreemfs_set_read_only_xattrResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bool was_set = 1;
  inline bool has_was_set() const;
  inline void clear_was_set();
  static const int kWasSetFieldNumber = 1;
  inline bool was_set() const;
  inline void set_was_set(bool value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_set_read_only_xattrResponse)
 private:
  inline void set_has_was_set();
  inline void clear_has_was_set();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  bool was_set_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_set_read_only_xattrResponse* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_get_file_credentialsRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_get_file_credentialsRequest();
  virtual ~xtreemfs_get_file_credentialsRequest();

  xtreemfs_get_file_credentialsRequest(const xtreemfs_get_file_credentialsRequest& from);

  inline xtreemfs_get_file_credentialsRequest& operator=(const xtreemfs_get_file_credentialsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_get_file_credentialsRequest& default_instance();

  void Swap(xtreemfs_get_file_credentialsRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_get_file_credentialsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_get_file_credentialsRequest& from);
  void MergeFrom(const xtreemfs_get_file_credentialsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_get_file_credentialsRequest)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_get_file_credentialsRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_reselect_osdsRequest : public ::google::protobuf::Message {
 public:
  xtreemfs_reselect_osdsRequest();
  virtual ~xtreemfs_reselect_osdsRequest();

  xtreemfs_reselect_osdsRequest(const xtreemfs_reselect_osdsRequest& from);

  inline xtreemfs_reselect_osdsRequest& operator=(const xtreemfs_reselect_osdsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_reselect_osdsRequest& default_instance();

  void Swap(xtreemfs_reselect_osdsRequest* other);

  // implements Message ----------------------------------------------

  xtreemfs_reselect_osdsRequest* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_reselect_osdsRequest& from);
  void MergeFrom(const xtreemfs_reselect_osdsRequest& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required string volume_name = 2;
  inline bool has_volume_name() const;
  inline void clear_volume_name();
  static const int kVolumeNameFieldNumber = 2;
  inline const ::std::string& volume_name() const;
  inline void set_volume_name(const ::std::string& value);
  inline void set_volume_name(const char* value);
  inline void set_volume_name(const char* value, size_t size);
  inline ::std::string* mutable_volume_name();
  inline ::std::string* release_volume_name();
  inline void set_allocated_volume_name(::std::string* volume_name);

  // optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 3;
  inline bool has_coordinates() const;
  inline void clear_coordinates();
  static const int kCoordinatesFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::VivaldiCoordinates& coordinates() const;
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* mutable_coordinates();
  inline ::xtreemfs::pbrpc::VivaldiCoordinates* release_coordinates();
  inline void set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_reselect_osdsRequest)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_volume_name();
  inline void clear_has_volume_name();
  inline void set_has_coordinates();
  inline void clear_has_coordinates();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* path_;
  ::std::string* volume_name_;
  ::xtreemfs::pbrpc::VivaldiCoordinates* coordinates_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_reselect_osdsRequest* default_instance_;
};
// -------------------------------------------------------------------

class xtreemfs_reselect_osdsResponse : public ::google::protobuf::Message {
 public:
  xtreemfs_reselect_osdsResponse();
  virtual ~xtreemfs_reselect_osdsResponse();

  xtreemfs_reselect_osdsResponse(const xtreemfs_reselect_osdsResponse& from);

  inline xtreemfs_reselect_osdsResponse& operator=(const xtreemfs_reselect_osdsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const xtreemfs_reselect_osdsResponse& default_instance();

  void Swap(xtreemfs_reselect_osdsResponse* other);

  // implements Message ----------------------------------------------

  xtreemfs_reselect_osdsResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const xtreemfs_reselect_osdsResponse& from);
  void MergeFrom(const xtreemfs_reselect_osdsResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string file_id = 1;
  inline bool has_file_id() const;
  inline void clear_file_id();
  static const int kFileIdFieldNumber = 1;
  inline const ::std::string& file_id() const;
  inline void set_file_id(const ::std::string& value);
  inline void set_file_id(const char* value);
  inline void set_file_id(const char* value, size_t size);
  inline ::std::string* mutable_file_id();
  inline ::std::string* release_file_id();
  inline void set_allocated_file_id(::std::string* file_id);

  // required int32 expected_xlocset_version = 2;
  inline bool has_expected_xlocset_version() const;
  inline void clear_expected_xlocset_version();
  static const int kExpectedXlocsetVersionFieldNumber = 2;
  inline ::google::protobuf::int32 expected_xlocset_version() const;
  inline void set_expected_xlocset_version(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.xtreemfs_reselect_osdsResponse)
 private:
  inline void set_has_file_id();
  inline void clear_has_file_id();
  inline void set_has_expected_xlocset_version();
  inline void clear_has_expected_xlocset_version();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* file_id_;
  ::google::protobuf::int32 expected_xlocset_version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_AssignDesc_xtreemfs_2fMRC_2eproto();
  friend void protobuf_ShutdownFile_xtreemfs_2fMRC_2eproto();

  void InitAsDefaultInstance();
  static xtreemfs_reselect_osdsResponse* default_instance_;
};
// ===================================================================


// ===================================================================

// Stat

// required fixed64 dev = 1;
inline bool Stat::has_dev() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stat::set_has_dev() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stat::clear_has_dev() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stat::clear_dev() {
  dev_ = GOOGLE_ULONGLONG(0);
  clear_has_dev();
}
inline ::google::protobuf::uint64 Stat::dev() const {
  return dev_;
}
inline void Stat::set_dev(::google::protobuf::uint64 value) {
  set_has_dev();
  dev_ = value;
}

// required fixed64 ino = 2;
inline bool Stat::has_ino() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stat::set_has_ino() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stat::clear_has_ino() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stat::clear_ino() {
  ino_ = GOOGLE_ULONGLONG(0);
  clear_has_ino();
}
inline ::google::protobuf::uint64 Stat::ino() const {
  return ino_;
}
inline void Stat::set_ino(::google::protobuf::uint64 value) {
  set_has_ino();
  ino_ = value;
}

// required fixed32 mode = 3;
inline bool Stat::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Stat::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Stat::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Stat::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 Stat::mode() const {
  return mode_;
}
inline void Stat::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// required fixed32 nlink = 4;
inline bool Stat::has_nlink() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Stat::set_has_nlink() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Stat::clear_has_nlink() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Stat::clear_nlink() {
  nlink_ = 0u;
  clear_has_nlink();
}
inline ::google::protobuf::uint32 Stat::nlink() const {
  return nlink_;
}
inline void Stat::set_nlink(::google::protobuf::uint32 value) {
  set_has_nlink();
  nlink_ = value;
}

// required string user_id = 5;
inline bool Stat::has_user_id() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Stat::set_has_user_id() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Stat::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Stat::clear_user_id() {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    user_id_->clear();
  }
  clear_has_user_id();
}
inline const ::std::string& Stat::user_id() const {
  return *user_id_;
}
inline void Stat::set_user_id(const ::std::string& value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void Stat::set_user_id(const char* value) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(value);
}
inline void Stat::set_user_id(const char* value, size_t size) {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stat::mutable_user_id() {
  set_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    user_id_ = new ::std::string;
  }
  return user_id_;
}
inline ::std::string* Stat::release_user_id() {
  clear_has_user_id();
  if (user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_id_;
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Stat::set_allocated_user_id(::std::string* user_id) {
  if (user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete user_id_;
  }
  if (user_id) {
    set_has_user_id();
    user_id_ = user_id;
  } else {
    clear_has_user_id();
    user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string group_id = 6;
inline bool Stat::has_group_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Stat::set_has_group_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Stat::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Stat::clear_group_id() {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    group_id_->clear();
  }
  clear_has_group_id();
}
inline const ::std::string& Stat::group_id() const {
  return *group_id_;
}
inline void Stat::set_group_id(const ::std::string& value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void Stat::set_group_id(const char* value) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(value);
}
inline void Stat::set_group_id(const char* value, size_t size) {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Stat::mutable_group_id() {
  set_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    group_id_ = new ::std::string;
  }
  return group_id_;
}
inline ::std::string* Stat::release_group_id() {
  clear_has_group_id();
  if (group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_id_;
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Stat::set_allocated_group_id(::std::string* group_id) {
  if (group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete group_id_;
  }
  if (group_id) {
    set_has_group_id();
    group_id_ = group_id;
  } else {
    clear_has_group_id();
    group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 size = 7;
inline bool Stat::has_size() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Stat::set_has_size() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Stat::clear_has_size() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Stat::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 Stat::size() const {
  return size_;
}
inline void Stat::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
}

// required fixed64 atime_ns = 8;
inline bool Stat::has_atime_ns() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Stat::set_has_atime_ns() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Stat::clear_has_atime_ns() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Stat::clear_atime_ns() {
  atime_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_atime_ns();
}
inline ::google::protobuf::uint64 Stat::atime_ns() const {
  return atime_ns_;
}
inline void Stat::set_atime_ns(::google::protobuf::uint64 value) {
  set_has_atime_ns();
  atime_ns_ = value;
}

// required fixed64 mtime_ns = 9;
inline bool Stat::has_mtime_ns() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Stat::set_has_mtime_ns() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Stat::clear_has_mtime_ns() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Stat::clear_mtime_ns() {
  mtime_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_mtime_ns();
}
inline ::google::protobuf::uint64 Stat::mtime_ns() const {
  return mtime_ns_;
}
inline void Stat::set_mtime_ns(::google::protobuf::uint64 value) {
  set_has_mtime_ns();
  mtime_ns_ = value;
}

// required fixed64 ctime_ns = 10;
inline bool Stat::has_ctime_ns() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Stat::set_has_ctime_ns() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Stat::clear_has_ctime_ns() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Stat::clear_ctime_ns() {
  ctime_ns_ = GOOGLE_ULONGLONG(0);
  clear_has_ctime_ns();
}
inline ::google::protobuf::uint64 Stat::ctime_ns() const {
  return ctime_ns_;
}
inline void Stat::set_ctime_ns(::google::protobuf::uint64 value) {
  set_has_ctime_ns();
  ctime_ns_ = value;
}

// required fixed32 blksize = 11;
inline bool Stat::has_blksize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Stat::set_has_blksize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Stat::clear_has_blksize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Stat::clear_blksize() {
  blksize_ = 0u;
  clear_has_blksize();
}
inline ::google::protobuf::uint32 Stat::blksize() const {
  return blksize_;
}
inline void Stat::set_blksize(::google::protobuf::uint32 value) {
  set_has_blksize();
  blksize_ = value;
}

// optional fixed64 etag = 12;
inline bool Stat::has_etag() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Stat::set_has_etag() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Stat::clear_has_etag() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Stat::clear_etag() {
  etag_ = GOOGLE_ULONGLONG(0);
  clear_has_etag();
}
inline ::google::protobuf::uint64 Stat::etag() const {
  return etag_;
}
inline void Stat::set_etag(::google::protobuf::uint64 value) {
  set_has_etag();
  etag_ = value;
}

// required fixed32 truncate_epoch = 13;
inline bool Stat::has_truncate_epoch() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Stat::set_has_truncate_epoch() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Stat::clear_has_truncate_epoch() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Stat::clear_truncate_epoch() {
  truncate_epoch_ = 0u;
  clear_has_truncate_epoch();
}
inline ::google::protobuf::uint32 Stat::truncate_epoch() const {
  return truncate_epoch_;
}
inline void Stat::set_truncate_epoch(::google::protobuf::uint32 value) {
  set_has_truncate_epoch();
  truncate_epoch_ = value;
}

// optional fixed32 attributes = 14;
inline bool Stat::has_attributes() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void Stat::set_has_attributes() {
  _has_bits_[0] |= 0x00002000u;
}
inline void Stat::clear_has_attributes() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void Stat::clear_attributes() {
  attributes_ = 0u;
  clear_has_attributes();
}
inline ::google::protobuf::uint32 Stat::attributes() const {
  return attributes_;
}
inline void Stat::set_attributes(::google::protobuf::uint32 value) {
  set_has_attributes();
  attributes_ = value;
}

// -------------------------------------------------------------------

// DirectoryEntry

// required string name = 1;
inline bool DirectoryEntry::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DirectoryEntry::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DirectoryEntry::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DirectoryEntry::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& DirectoryEntry::name() const {
  return *name_;
}
inline void DirectoryEntry::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DirectoryEntry::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void DirectoryEntry::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* DirectoryEntry::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* DirectoryEntry::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void DirectoryEntry::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .xtreemfs.pbrpc.Stat stbuf = 2;
inline bool DirectoryEntry::has_stbuf() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DirectoryEntry::set_has_stbuf() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DirectoryEntry::clear_has_stbuf() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DirectoryEntry::clear_stbuf() {
  if (stbuf_ != NULL) stbuf_->::xtreemfs::pbrpc::Stat::Clear();
  clear_has_stbuf();
}
inline const ::xtreemfs::pbrpc::Stat& DirectoryEntry::stbuf() const {
  return stbuf_ != NULL ? *stbuf_ : *default_instance_->stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* DirectoryEntry::mutable_stbuf() {
  set_has_stbuf();
  if (stbuf_ == NULL) stbuf_ = new ::xtreemfs::pbrpc::Stat;
  return stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* DirectoryEntry::release_stbuf() {
  clear_has_stbuf();
  ::xtreemfs::pbrpc::Stat* temp = stbuf_;
  stbuf_ = NULL;
  return temp;
}
inline void DirectoryEntry::set_allocated_stbuf(::xtreemfs::pbrpc::Stat* stbuf) {
  delete stbuf_;
  stbuf_ = stbuf;
  if (stbuf) {
    set_has_stbuf();
  } else {
    clear_has_stbuf();
  }
}

// -------------------------------------------------------------------

// DirectoryEntries

// repeated .xtreemfs.pbrpc.DirectoryEntry entries = 1;
inline int DirectoryEntries::entries_size() const {
  return entries_.size();
}
inline void DirectoryEntries::clear_entries() {
  entries_.Clear();
}
inline const ::xtreemfs::pbrpc::DirectoryEntry& DirectoryEntries::entries(int index) const {
  return entries_.Get(index);
}
inline ::xtreemfs::pbrpc::DirectoryEntry* DirectoryEntries::mutable_entries(int index) {
  return entries_.Mutable(index);
}
inline ::xtreemfs::pbrpc::DirectoryEntry* DirectoryEntries::add_entries() {
  return entries_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry >&
DirectoryEntries::entries() const {
  return entries_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::DirectoryEntry >*
DirectoryEntries::mutable_entries() {
  return &entries_;
}

// -------------------------------------------------------------------

// XAttr

// required string name = 1;
inline bool XAttr::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void XAttr::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void XAttr::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void XAttr::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& XAttr::name() const {
  return *name_;
}
inline void XAttr::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XAttr::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void XAttr::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XAttr::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* XAttr::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XAttr::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string value = 2;
inline bool XAttr::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void XAttr::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void XAttr::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void XAttr::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& XAttr::value() const {
  return *value_;
}
inline void XAttr::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void XAttr::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void XAttr::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XAttr::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* XAttr::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XAttr::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value_bytes_string = 3;
inline bool XAttr::has_value_bytes_string() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void XAttr::set_has_value_bytes_string() {
  _has_bits_[0] |= 0x00000004u;
}
inline void XAttr::clear_has_value_bytes_string() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void XAttr::clear_value_bytes_string() {
  if (value_bytes_string_ != &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_->clear();
  }
  clear_has_value_bytes_string();
}
inline const ::std::string& XAttr::value_bytes_string() const {
  return *value_bytes_string_;
}
inline void XAttr::set_value_bytes_string(const ::std::string& value) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(value);
}
inline void XAttr::set_value_bytes_string(const char* value) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(value);
}
inline void XAttr::set_value_bytes_string(const void* value, size_t size) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* XAttr::mutable_value_bytes_string() {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  return value_bytes_string_;
}
inline ::std::string* XAttr::release_value_bytes_string() {
  clear_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_bytes_string_;
    value_bytes_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void XAttr::set_allocated_value_bytes_string(::std::string* value_bytes_string) {
  if (value_bytes_string_ != &::google::protobuf::internal::kEmptyString) {
    delete value_bytes_string_;
  }
  if (value_bytes_string) {
    set_has_value_bytes_string();
    value_bytes_string_ = value_bytes_string;
  } else {
    clear_has_value_bytes_string();
    value_bytes_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Volume

// required .xtreemfs.pbrpc.AccessControlPolicyType access_control_policy = 1;
inline bool Volume::has_access_control_policy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Volume::set_has_access_control_policy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Volume::clear_has_access_control_policy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Volume::clear_access_control_policy() {
  access_control_policy_ = 1;
  clear_has_access_control_policy();
}
inline ::xtreemfs::pbrpc::AccessControlPolicyType Volume::access_control_policy() const {
  return static_cast< ::xtreemfs::pbrpc::AccessControlPolicyType >(access_control_policy_);
}
inline void Volume::set_access_control_policy(::xtreemfs::pbrpc::AccessControlPolicyType value) {
  assert(::xtreemfs::pbrpc::AccessControlPolicyType_IsValid(value));
  set_has_access_control_policy();
  access_control_policy_ = value;
}

// required .xtreemfs.pbrpc.StripingPolicy default_striping_policy = 2;
inline bool Volume::has_default_striping_policy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Volume::set_has_default_striping_policy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Volume::clear_has_default_striping_policy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Volume::clear_default_striping_policy() {
  if (default_striping_policy_ != NULL) default_striping_policy_->::xtreemfs::pbrpc::StripingPolicy::Clear();
  clear_has_default_striping_policy();
}
inline const ::xtreemfs::pbrpc::StripingPolicy& Volume::default_striping_policy() const {
  return default_striping_policy_ != NULL ? *default_striping_policy_ : *default_instance_->default_striping_policy_;
}
inline ::xtreemfs::pbrpc::StripingPolicy* Volume::mutable_default_striping_policy() {
  set_has_default_striping_policy();
  if (default_striping_policy_ == NULL) default_striping_policy_ = new ::xtreemfs::pbrpc::StripingPolicy;
  return default_striping_policy_;
}
inline ::xtreemfs::pbrpc::StripingPolicy* Volume::release_default_striping_policy() {
  clear_has_default_striping_policy();
  ::xtreemfs::pbrpc::StripingPolicy* temp = default_striping_policy_;
  default_striping_policy_ = NULL;
  return temp;
}
inline void Volume::set_allocated_default_striping_policy(::xtreemfs::pbrpc::StripingPolicy* default_striping_policy) {
  delete default_striping_policy_;
  default_striping_policy_ = default_striping_policy;
  if (default_striping_policy) {
    set_has_default_striping_policy();
  } else {
    clear_has_default_striping_policy();
  }
}

// required string id = 3;
inline bool Volume::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Volume::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Volume::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Volume::clear_id() {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    id_->clear();
  }
  clear_has_id();
}
inline const ::std::string& Volume::id() const {
  return *id_;
}
inline void Volume::set_id(const ::std::string& value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Volume::set_id(const char* value) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(value);
}
inline void Volume::set_id(const char* value, size_t size) {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_id() {
  set_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    id_ = new ::std::string;
  }
  return id_;
}
inline ::std::string* Volume::release_id() {
  clear_has_id();
  if (id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = id_;
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Volume::set_allocated_id(::std::string* id) {
  if (id_ != &::google::protobuf::internal::kEmptyString) {
    delete id_;
  }
  if (id) {
    set_has_id();
    id_ = id;
  } else {
    clear_has_id();
    id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 mode = 4;
inline bool Volume::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Volume::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Volume::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Volume::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 Volume::mode() const {
  return mode_;
}
inline void Volume::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// required string name = 5;
inline bool Volume::has_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Volume::set_has_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Volume::clear_has_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Volume::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Volume::name() const {
  return *name_;
}
inline void Volume::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Volume::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void Volume::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* Volume::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Volume::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string owner_group_id = 6;
inline bool Volume::has_owner_group_id() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Volume::set_has_owner_group_id() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Volume::clear_has_owner_group_id() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Volume::clear_owner_group_id() {
  if (owner_group_id_ != &::google::protobuf::internal::kEmptyString) {
    owner_group_id_->clear();
  }
  clear_has_owner_group_id();
}
inline const ::std::string& Volume::owner_group_id() const {
  return *owner_group_id_;
}
inline void Volume::set_owner_group_id(const ::std::string& value) {
  set_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(value);
}
inline void Volume::set_owner_group_id(const char* value) {
  set_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(value);
}
inline void Volume::set_owner_group_id(const char* value, size_t size) {
  set_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_owner_group_id() {
  set_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_group_id_ = new ::std::string;
  }
  return owner_group_id_;
}
inline ::std::string* Volume::release_owner_group_id() {
  clear_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_group_id_;
    owner_group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Volume::set_allocated_owner_group_id(::std::string* owner_group_id) {
  if (owner_group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_group_id_;
  }
  if (owner_group_id) {
    set_has_owner_group_id();
    owner_group_id_ = owner_group_id;
  } else {
    clear_has_owner_group_id();
    owner_group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string owner_user_id = 7;
inline bool Volume::has_owner_user_id() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Volume::set_has_owner_user_id() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Volume::clear_has_owner_user_id() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Volume::clear_owner_user_id() {
  if (owner_user_id_ != &::google::protobuf::internal::kEmptyString) {
    owner_user_id_->clear();
  }
  clear_has_owner_user_id();
}
inline const ::std::string& Volume::owner_user_id() const {
  return *owner_user_id_;
}
inline void Volume::set_owner_user_id(const ::std::string& value) {
  set_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(value);
}
inline void Volume::set_owner_user_id(const char* value) {
  set_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(value);
}
inline void Volume::set_owner_user_id(const char* value, size_t size) {
  set_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Volume::mutable_owner_user_id() {
  set_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_user_id_ = new ::std::string;
  }
  return owner_user_id_;
}
inline ::std::string* Volume::release_owner_user_id() {
  clear_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_user_id_;
    owner_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Volume::set_allocated_owner_user_id(::std::string* owner_user_id) {
  if (owner_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_user_id_;
  }
  if (owner_user_id) {
    set_has_owner_user_id();
    owner_user_id_ = owner_user_id;
  } else {
    clear_has_owner_user_id();
    owner_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .xtreemfs.pbrpc.KeyValuePair attrs = 8;
inline int Volume::attrs_size() const {
  return attrs_.size();
}
inline void Volume::clear_attrs() {
  attrs_.Clear();
}
inline const ::xtreemfs::pbrpc::KeyValuePair& Volume::attrs(int index) const {
  return attrs_.Get(index);
}
inline ::xtreemfs::pbrpc::KeyValuePair* Volume::mutable_attrs(int index) {
  return attrs_.Mutable(index);
}
inline ::xtreemfs::pbrpc::KeyValuePair* Volume::add_attrs() {
  return attrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >&
Volume::attrs() const {
  return attrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::KeyValuePair >*
Volume::mutable_attrs() {
  return &attrs_;
}

// optional fixed64 quota = 9;
inline bool Volume::has_quota() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Volume::set_has_quota() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Volume::clear_has_quota() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Volume::clear_quota() {
  quota_ = GOOGLE_ULONGLONG(0);
  clear_has_quota();
}
inline ::google::protobuf::uint64 Volume::quota() const {
  return quota_;
}
inline void Volume::set_quota(::google::protobuf::uint64 value) {
  set_has_quota();
  quota_ = value;
}

// -------------------------------------------------------------------

// Volumes

// repeated .xtreemfs.pbrpc.Volume volumes = 1;
inline int Volumes::volumes_size() const {
  return volumes_.size();
}
inline void Volumes::clear_volumes() {
  volumes_.Clear();
}
inline const ::xtreemfs::pbrpc::Volume& Volumes::volumes(int index) const {
  return volumes_.Get(index);
}
inline ::xtreemfs::pbrpc::Volume* Volumes::mutable_volumes(int index) {
  return volumes_.Mutable(index);
}
inline ::xtreemfs::pbrpc::Volume* Volumes::add_volumes() {
  return volumes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume >&
Volumes::volumes() const {
  return volumes_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::Volume >*
Volumes::mutable_volumes() {
  return &volumes_;
}

// -------------------------------------------------------------------

// StatVFS

// required fixed32 bsize = 1;
inline bool StatVFS::has_bsize() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StatVFS::set_has_bsize() {
  _has_bits_[0] |= 0x00000001u;
}
inline void StatVFS::clear_has_bsize() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void StatVFS::clear_bsize() {
  bsize_ = 0u;
  clear_has_bsize();
}
inline ::google::protobuf::uint32 StatVFS::bsize() const {
  return bsize_;
}
inline void StatVFS::set_bsize(::google::protobuf::uint32 value) {
  set_has_bsize();
  bsize_ = value;
}

// required fixed64 bavail = 2;
inline bool StatVFS::has_bavail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void StatVFS::set_has_bavail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void StatVFS::clear_has_bavail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void StatVFS::clear_bavail() {
  bavail_ = GOOGLE_ULONGLONG(0);
  clear_has_bavail();
}
inline ::google::protobuf::uint64 StatVFS::bavail() const {
  return bavail_;
}
inline void StatVFS::set_bavail(::google::protobuf::uint64 value) {
  set_has_bavail();
  bavail_ = value;
}

// optional fixed64 bfree = 13;
inline bool StatVFS::has_bfree() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void StatVFS::set_has_bfree() {
  _has_bits_[0] |= 0x00000004u;
}
inline void StatVFS::clear_has_bfree() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void StatVFS::clear_bfree() {
  bfree_ = GOOGLE_ULONGLONG(0);
  clear_has_bfree();
}
inline ::google::protobuf::uint64 StatVFS::bfree() const {
  return bfree_;
}
inline void StatVFS::set_bfree(::google::protobuf::uint64 value) {
  set_has_bfree();
  bfree_ = value;
}

// required fixed64 blocks = 3;
inline bool StatVFS::has_blocks() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void StatVFS::set_has_blocks() {
  _has_bits_[0] |= 0x00000008u;
}
inline void StatVFS::clear_has_blocks() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void StatVFS::clear_blocks() {
  blocks_ = GOOGLE_ULONGLONG(0);
  clear_has_blocks();
}
inline ::google::protobuf::uint64 StatVFS::blocks() const {
  return blocks_;
}
inline void StatVFS::set_blocks(::google::protobuf::uint64 value) {
  set_has_blocks();
  blocks_ = value;
}

// required string fsid = 4;
inline bool StatVFS::has_fsid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void StatVFS::set_has_fsid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void StatVFS::clear_has_fsid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void StatVFS::clear_fsid() {
  if (fsid_ != &::google::protobuf::internal::kEmptyString) {
    fsid_->clear();
  }
  clear_has_fsid();
}
inline const ::std::string& StatVFS::fsid() const {
  return *fsid_;
}
inline void StatVFS::set_fsid(const ::std::string& value) {
  set_has_fsid();
  if (fsid_ == &::google::protobuf::internal::kEmptyString) {
    fsid_ = new ::std::string;
  }
  fsid_->assign(value);
}
inline void StatVFS::set_fsid(const char* value) {
  set_has_fsid();
  if (fsid_ == &::google::protobuf::internal::kEmptyString) {
    fsid_ = new ::std::string;
  }
  fsid_->assign(value);
}
inline void StatVFS::set_fsid(const char* value, size_t size) {
  set_has_fsid();
  if (fsid_ == &::google::protobuf::internal::kEmptyString) {
    fsid_ = new ::std::string;
  }
  fsid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatVFS::mutable_fsid() {
  set_has_fsid();
  if (fsid_ == &::google::protobuf::internal::kEmptyString) {
    fsid_ = new ::std::string;
  }
  return fsid_;
}
inline ::std::string* StatVFS::release_fsid() {
  clear_has_fsid();
  if (fsid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fsid_;
    fsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatVFS::set_allocated_fsid(::std::string* fsid) {
  if (fsid_ != &::google::protobuf::internal::kEmptyString) {
    delete fsid_;
  }
  if (fsid) {
    set_has_fsid();
    fsid_ = fsid;
  } else {
    clear_has_fsid();
    fsid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 namemax = 5;
inline bool StatVFS::has_namemax() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void StatVFS::set_has_namemax() {
  _has_bits_[0] |= 0x00000020u;
}
inline void StatVFS::clear_has_namemax() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void StatVFS::clear_namemax() {
  namemax_ = 0u;
  clear_has_namemax();
}
inline ::google::protobuf::uint32 StatVFS::namemax() const {
  return namemax_;
}
inline void StatVFS::set_namemax(::google::protobuf::uint32 value) {
  set_has_namemax();
  namemax_ = value;
}

// required .xtreemfs.pbrpc.AccessControlPolicyType access_control_policy = 6;
inline bool StatVFS::has_access_control_policy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void StatVFS::set_has_access_control_policy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void StatVFS::clear_has_access_control_policy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void StatVFS::clear_access_control_policy() {
  access_control_policy_ = 1;
  clear_has_access_control_policy();
}
inline ::xtreemfs::pbrpc::AccessControlPolicyType StatVFS::access_control_policy() const {
  return static_cast< ::xtreemfs::pbrpc::AccessControlPolicyType >(access_control_policy_);
}
inline void StatVFS::set_access_control_policy(::xtreemfs::pbrpc::AccessControlPolicyType value) {
  assert(::xtreemfs::pbrpc::AccessControlPolicyType_IsValid(value));
  set_has_access_control_policy();
  access_control_policy_ = value;
}

// required .xtreemfs.pbrpc.StripingPolicy default_striping_policy = 7;
inline bool StatVFS::has_default_striping_policy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void StatVFS::set_has_default_striping_policy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void StatVFS::clear_has_default_striping_policy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void StatVFS::clear_default_striping_policy() {
  if (default_striping_policy_ != NULL) default_striping_policy_->::xtreemfs::pbrpc::StripingPolicy::Clear();
  clear_has_default_striping_policy();
}
inline const ::xtreemfs::pbrpc::StripingPolicy& StatVFS::default_striping_policy() const {
  return default_striping_policy_ != NULL ? *default_striping_policy_ : *default_instance_->default_striping_policy_;
}
inline ::xtreemfs::pbrpc::StripingPolicy* StatVFS::mutable_default_striping_policy() {
  set_has_default_striping_policy();
  if (default_striping_policy_ == NULL) default_striping_policy_ = new ::xtreemfs::pbrpc::StripingPolicy;
  return default_striping_policy_;
}
inline ::xtreemfs::pbrpc::StripingPolicy* StatVFS::release_default_striping_policy() {
  clear_has_default_striping_policy();
  ::xtreemfs::pbrpc::StripingPolicy* temp = default_striping_policy_;
  default_striping_policy_ = NULL;
  return temp;
}
inline void StatVFS::set_allocated_default_striping_policy(::xtreemfs::pbrpc::StripingPolicy* default_striping_policy) {
  delete default_striping_policy_;
  default_striping_policy_ = default_striping_policy;
  if (default_striping_policy) {
    set_has_default_striping_policy();
  } else {
    clear_has_default_striping_policy();
  }
}

// required fixed64 etag = 8;
inline bool StatVFS::has_etag() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void StatVFS::set_has_etag() {
  _has_bits_[0] |= 0x00000100u;
}
inline void StatVFS::clear_has_etag() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void StatVFS::clear_etag() {
  etag_ = GOOGLE_ULONGLONG(0);
  clear_has_etag();
}
inline ::google::protobuf::uint64 StatVFS::etag() const {
  return etag_;
}
inline void StatVFS::set_etag(::google::protobuf::uint64 value) {
  set_has_etag();
  etag_ = value;
}

// required fixed32 mode = 9;
inline bool StatVFS::has_mode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void StatVFS::set_has_mode() {
  _has_bits_[0] |= 0x00000200u;
}
inline void StatVFS::clear_has_mode() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void StatVFS::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 StatVFS::mode() const {
  return mode_;
}
inline void StatVFS::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// required string name = 10;
inline bool StatVFS::has_name() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void StatVFS::set_has_name() {
  _has_bits_[0] |= 0x00000400u;
}
inline void StatVFS::clear_has_name() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void StatVFS::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& StatVFS::name() const {
  return *name_;
}
inline void StatVFS::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StatVFS::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void StatVFS::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatVFS::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* StatVFS::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatVFS::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string owner_group_id = 11;
inline bool StatVFS::has_owner_group_id() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void StatVFS::set_has_owner_group_id() {
  _has_bits_[0] |= 0x00000800u;
}
inline void StatVFS::clear_has_owner_group_id() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void StatVFS::clear_owner_group_id() {
  if (owner_group_id_ != &::google::protobuf::internal::kEmptyString) {
    owner_group_id_->clear();
  }
  clear_has_owner_group_id();
}
inline const ::std::string& StatVFS::owner_group_id() const {
  return *owner_group_id_;
}
inline void StatVFS::set_owner_group_id(const ::std::string& value) {
  set_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(value);
}
inline void StatVFS::set_owner_group_id(const char* value) {
  set_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(value);
}
inline void StatVFS::set_owner_group_id(const char* value, size_t size) {
  set_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_group_id_ = new ::std::string;
  }
  owner_group_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatVFS::mutable_owner_group_id() {
  set_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_group_id_ = new ::std::string;
  }
  return owner_group_id_;
}
inline ::std::string* StatVFS::release_owner_group_id() {
  clear_has_owner_group_id();
  if (owner_group_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_group_id_;
    owner_group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatVFS::set_allocated_owner_group_id(::std::string* owner_group_id) {
  if (owner_group_id_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_group_id_;
  }
  if (owner_group_id) {
    set_has_owner_group_id();
    owner_group_id_ = owner_group_id;
  } else {
    clear_has_owner_group_id();
    owner_group_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string owner_user_id = 12;
inline bool StatVFS::has_owner_user_id() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void StatVFS::set_has_owner_user_id() {
  _has_bits_[0] |= 0x00001000u;
}
inline void StatVFS::clear_has_owner_user_id() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void StatVFS::clear_owner_user_id() {
  if (owner_user_id_ != &::google::protobuf::internal::kEmptyString) {
    owner_user_id_->clear();
  }
  clear_has_owner_user_id();
}
inline const ::std::string& StatVFS::owner_user_id() const {
  return *owner_user_id_;
}
inline void StatVFS::set_owner_user_id(const ::std::string& value) {
  set_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(value);
}
inline void StatVFS::set_owner_user_id(const char* value) {
  set_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(value);
}
inline void StatVFS::set_owner_user_id(const char* value, size_t size) {
  set_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_user_id_ = new ::std::string;
  }
  owner_user_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* StatVFS::mutable_owner_user_id() {
  set_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    owner_user_id_ = new ::std::string;
  }
  return owner_user_id_;
}
inline ::std::string* StatVFS::release_owner_user_id() {
  clear_has_owner_user_id();
  if (owner_user_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = owner_user_id_;
    owner_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void StatVFS::set_allocated_owner_user_id(::std::string* owner_user_id) {
  if (owner_user_id_ != &::google::protobuf::internal::kEmptyString) {
    delete owner_user_id_;
  }
  if (owner_user_id) {
    set_has_owner_user_id();
    owner_user_id_ = owner_user_id;
  } else {
    clear_has_owner_user_id();
    owner_user_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// fsetattrRequest

// required .xtreemfs.pbrpc.Stat stbuf = 1;
inline bool fsetattrRequest::has_stbuf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void fsetattrRequest::set_has_stbuf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void fsetattrRequest::clear_has_stbuf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void fsetattrRequest::clear_stbuf() {
  if (stbuf_ != NULL) stbuf_->::xtreemfs::pbrpc::Stat::Clear();
  clear_has_stbuf();
}
inline const ::xtreemfs::pbrpc::Stat& fsetattrRequest::stbuf() const {
  return stbuf_ != NULL ? *stbuf_ : *default_instance_->stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* fsetattrRequest::mutable_stbuf() {
  set_has_stbuf();
  if (stbuf_ == NULL) stbuf_ = new ::xtreemfs::pbrpc::Stat;
  return stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* fsetattrRequest::release_stbuf() {
  clear_has_stbuf();
  ::xtreemfs::pbrpc::Stat* temp = stbuf_;
  stbuf_ = NULL;
  return temp;
}
inline void fsetattrRequest::set_allocated_stbuf(::xtreemfs::pbrpc::Stat* stbuf) {
  delete stbuf_;
  stbuf_ = stbuf;
  if (stbuf) {
    set_has_stbuf();
  } else {
    clear_has_stbuf();
  }
}

// required fixed32 to_set = 2;
inline bool fsetattrRequest::has_to_set() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void fsetattrRequest::set_has_to_set() {
  _has_bits_[0] |= 0x00000002u;
}
inline void fsetattrRequest::clear_has_to_set() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void fsetattrRequest::clear_to_set() {
  to_set_ = 0u;
  clear_has_to_set();
}
inline ::google::protobuf::uint32 fsetattrRequest::to_set() const {
  return to_set_;
}
inline void fsetattrRequest::set_to_set(::google::protobuf::uint32 value) {
  set_has_to_set();
  to_set_ = value;
}

// required .xtreemfs.pbrpc.XCap cap = 3;
inline bool fsetattrRequest::has_cap() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void fsetattrRequest::set_has_cap() {
  _has_bits_[0] |= 0x00000004u;
}
inline void fsetattrRequest::clear_has_cap() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void fsetattrRequest::clear_cap() {
  if (cap_ != NULL) cap_->::xtreemfs::pbrpc::XCap::Clear();
  clear_has_cap();
}
inline const ::xtreemfs::pbrpc::XCap& fsetattrRequest::cap() const {
  return cap_ != NULL ? *cap_ : *default_instance_->cap_;
}
inline ::xtreemfs::pbrpc::XCap* fsetattrRequest::mutable_cap() {
  set_has_cap();
  if (cap_ == NULL) cap_ = new ::xtreemfs::pbrpc::XCap;
  return cap_;
}
inline ::xtreemfs::pbrpc::XCap* fsetattrRequest::release_cap() {
  clear_has_cap();
  ::xtreemfs::pbrpc::XCap* temp = cap_;
  cap_ = NULL;
  return temp;
}
inline void fsetattrRequest::set_allocated_cap(::xtreemfs::pbrpc::XCap* cap) {
  delete cap_;
  cap_ = cap;
  if (cap) {
    set_has_cap();
  } else {
    clear_has_cap();
  }
}

// -------------------------------------------------------------------

// getattrRequest

// required string volume_name = 1;
inline bool getattrRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getattrRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getattrRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getattrRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& getattrRequest::volume_name() const {
  return *volume_name_;
}
inline void getattrRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void getattrRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void getattrRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getattrRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* getattrRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void getattrRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool getattrRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getattrRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getattrRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getattrRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& getattrRequest::path() const {
  return *path_;
}
inline void getattrRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void getattrRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void getattrRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getattrRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* getattrRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void getattrRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 known_etag = 3;
inline bool getattrRequest::has_known_etag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getattrRequest::set_has_known_etag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void getattrRequest::clear_has_known_etag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void getattrRequest::clear_known_etag() {
  known_etag_ = GOOGLE_ULONGLONG(0);
  clear_has_known_etag();
}
inline ::google::protobuf::uint64 getattrRequest::known_etag() const {
  return known_etag_;
}
inline void getattrRequest::set_known_etag(::google::protobuf::uint64 value) {
  set_has_known_etag();
  known_etag_ = value;
}

// -------------------------------------------------------------------

// getattrResponse

// optional .xtreemfs.pbrpc.Stat stbuf = 1;
inline bool getattrResponse::has_stbuf() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getattrResponse::set_has_stbuf() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getattrResponse::clear_has_stbuf() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getattrResponse::clear_stbuf() {
  if (stbuf_ != NULL) stbuf_->::xtreemfs::pbrpc::Stat::Clear();
  clear_has_stbuf();
}
inline const ::xtreemfs::pbrpc::Stat& getattrResponse::stbuf() const {
  return stbuf_ != NULL ? *stbuf_ : *default_instance_->stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* getattrResponse::mutable_stbuf() {
  set_has_stbuf();
  if (stbuf_ == NULL) stbuf_ = new ::xtreemfs::pbrpc::Stat;
  return stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* getattrResponse::release_stbuf() {
  clear_has_stbuf();
  ::xtreemfs::pbrpc::Stat* temp = stbuf_;
  stbuf_ = NULL;
  return temp;
}
inline void getattrResponse::set_allocated_stbuf(::xtreemfs::pbrpc::Stat* stbuf) {
  delete stbuf_;
  stbuf_ = stbuf;
  if (stbuf) {
    set_has_stbuf();
  } else {
    clear_has_stbuf();
  }
}

// -------------------------------------------------------------------

// getxattrRequest

// required string volume_name = 1;
inline bool getxattrRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getxattrRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getxattrRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getxattrRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& getxattrRequest::volume_name() const {
  return *volume_name_;
}
inline void getxattrRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void getxattrRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void getxattrRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* getxattrRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void getxattrRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool getxattrRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getxattrRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getxattrRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getxattrRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& getxattrRequest::path() const {
  return *path_;
}
inline void getxattrRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void getxattrRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void getxattrRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* getxattrRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void getxattrRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool getxattrRequest::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void getxattrRequest::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void getxattrRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void getxattrRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& getxattrRequest::name() const {
  return *name_;
}
inline void getxattrRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void getxattrRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void getxattrRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* getxattrRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void getxattrRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// getxattrResponse

// required string value = 1;
inline bool getxattrResponse::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void getxattrResponse::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void getxattrResponse::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void getxattrResponse::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& getxattrResponse::value() const {
  return *value_;
}
inline void getxattrResponse::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void getxattrResponse::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void getxattrResponse::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrResponse::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* getxattrResponse::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void getxattrResponse::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value_bytes_string = 2;
inline bool getxattrResponse::has_value_bytes_string() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void getxattrResponse::set_has_value_bytes_string() {
  _has_bits_[0] |= 0x00000002u;
}
inline void getxattrResponse::clear_has_value_bytes_string() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void getxattrResponse::clear_value_bytes_string() {
  if (value_bytes_string_ != &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_->clear();
  }
  clear_has_value_bytes_string();
}
inline const ::std::string& getxattrResponse::value_bytes_string() const {
  return *value_bytes_string_;
}
inline void getxattrResponse::set_value_bytes_string(const ::std::string& value) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(value);
}
inline void getxattrResponse::set_value_bytes_string(const char* value) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(value);
}
inline void getxattrResponse::set_value_bytes_string(const void* value, size_t size) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* getxattrResponse::mutable_value_bytes_string() {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  return value_bytes_string_;
}
inline ::std::string* getxattrResponse::release_value_bytes_string() {
  clear_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_bytes_string_;
    value_bytes_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void getxattrResponse::set_allocated_value_bytes_string(::std::string* value_bytes_string) {
  if (value_bytes_string_ != &::google::protobuf::internal::kEmptyString) {
    delete value_bytes_string_;
  }
  if (value_bytes_string) {
    set_has_value_bytes_string();
    value_bytes_string_ = value_bytes_string;
  } else {
    clear_has_value_bytes_string();
    value_bytes_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// linkRequest

// required string volume_name = 1;
inline bool linkRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void linkRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void linkRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void linkRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& linkRequest::volume_name() const {
  return *volume_name_;
}
inline void linkRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void linkRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void linkRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* linkRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* linkRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void linkRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string target_path = 2;
inline bool linkRequest::has_target_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void linkRequest::set_has_target_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void linkRequest::clear_has_target_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void linkRequest::clear_target_path() {
  if (target_path_ != &::google::protobuf::internal::kEmptyString) {
    target_path_->clear();
  }
  clear_has_target_path();
}
inline const ::std::string& linkRequest::target_path() const {
  return *target_path_;
}
inline void linkRequest::set_target_path(const ::std::string& value) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void linkRequest::set_target_path(const char* value) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void linkRequest::set_target_path(const char* value, size_t size) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* linkRequest::mutable_target_path() {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  return target_path_;
}
inline ::std::string* linkRequest::release_target_path() {
  clear_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_path_;
    target_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void linkRequest::set_allocated_target_path(::std::string* target_path) {
  if (target_path_ != &::google::protobuf::internal::kEmptyString) {
    delete target_path_;
  }
  if (target_path) {
    set_has_target_path();
    target_path_ = target_path;
  } else {
    clear_has_target_path();
    target_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string link_path = 3;
inline bool linkRequest::has_link_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void linkRequest::set_has_link_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void linkRequest::clear_has_link_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void linkRequest::clear_link_path() {
  if (link_path_ != &::google::protobuf::internal::kEmptyString) {
    link_path_->clear();
  }
  clear_has_link_path();
}
inline const ::std::string& linkRequest::link_path() const {
  return *link_path_;
}
inline void linkRequest::set_link_path(const ::std::string& value) {
  set_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(value);
}
inline void linkRequest::set_link_path(const char* value) {
  set_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(value);
}
inline void linkRequest::set_link_path(const char* value, size_t size) {
  set_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* linkRequest::mutable_link_path() {
  set_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    link_path_ = new ::std::string;
  }
  return link_path_;
}
inline ::std::string* linkRequest::release_link_path() {
  clear_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = link_path_;
    link_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void linkRequest::set_allocated_link_path(::std::string* link_path) {
  if (link_path_ != &::google::protobuf::internal::kEmptyString) {
    delete link_path_;
  }
  if (link_path) {
    set_has_link_path();
    link_path_ = link_path;
  } else {
    clear_has_link_path();
    link_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// listxattrRequest

// required string volume_name = 1;
inline bool listxattrRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void listxattrRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void listxattrRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void listxattrRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& listxattrRequest::volume_name() const {
  return *volume_name_;
}
inline void listxattrRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void listxattrRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void listxattrRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* listxattrRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* listxattrRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void listxattrRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool listxattrRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void listxattrRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void listxattrRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void listxattrRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& listxattrRequest::path() const {
  return *path_;
}
inline void listxattrRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void listxattrRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void listxattrRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* listxattrRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* listxattrRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void listxattrRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool names_only = 3;
inline bool listxattrRequest::has_names_only() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void listxattrRequest::set_has_names_only() {
  _has_bits_[0] |= 0x00000004u;
}
inline void listxattrRequest::clear_has_names_only() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void listxattrRequest::clear_names_only() {
  names_only_ = false;
  clear_has_names_only();
}
inline bool listxattrRequest::names_only() const {
  return names_only_;
}
inline void listxattrRequest::set_names_only(bool value) {
  set_has_names_only();
  names_only_ = value;
}

// -------------------------------------------------------------------

// listxattrResponse

// repeated .xtreemfs.pbrpc.XAttr xattrs = 1;
inline int listxattrResponse::xattrs_size() const {
  return xattrs_.size();
}
inline void listxattrResponse::clear_xattrs() {
  xattrs_.Clear();
}
inline const ::xtreemfs::pbrpc::XAttr& listxattrResponse::xattrs(int index) const {
  return xattrs_.Get(index);
}
inline ::xtreemfs::pbrpc::XAttr* listxattrResponse::mutable_xattrs(int index) {
  return xattrs_.Mutable(index);
}
inline ::xtreemfs::pbrpc::XAttr* listxattrResponse::add_xattrs() {
  return xattrs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr >&
listxattrResponse::xattrs() const {
  return xattrs_;
}
inline ::google::protobuf::RepeatedPtrField< ::xtreemfs::pbrpc::XAttr >*
listxattrResponse::mutable_xattrs() {
  return &xattrs_;
}

// -------------------------------------------------------------------

// mkdirRequest

// required string volume_name = 1;
inline bool mkdirRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void mkdirRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void mkdirRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void mkdirRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& mkdirRequest::volume_name() const {
  return *volume_name_;
}
inline void mkdirRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void mkdirRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void mkdirRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mkdirRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* mkdirRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mkdirRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool mkdirRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void mkdirRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void mkdirRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void mkdirRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& mkdirRequest::path() const {
  return *path_;
}
inline void mkdirRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void mkdirRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void mkdirRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* mkdirRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* mkdirRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void mkdirRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 mode = 3;
inline bool mkdirRequest::has_mode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void mkdirRequest::set_has_mode() {
  _has_bits_[0] |= 0x00000004u;
}
inline void mkdirRequest::clear_has_mode() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void mkdirRequest::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 mkdirRequest::mode() const {
  return mode_;
}
inline void mkdirRequest::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// -------------------------------------------------------------------

// openRequest

// required string volume_name = 1;
inline bool openRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void openRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void openRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void openRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& openRequest::volume_name() const {
  return *volume_name_;
}
inline void openRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void openRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void openRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* openRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* openRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void openRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool openRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void openRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void openRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void openRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& openRequest::path() const {
  return *path_;
}
inline void openRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void openRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void openRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* openRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* openRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void openRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 flags = 3;
inline bool openRequest::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void openRequest::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void openRequest::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void openRequest::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 openRequest::flags() const {
  return flags_;
}
inline void openRequest::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// required fixed32 mode = 4;
inline bool openRequest::has_mode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void openRequest::set_has_mode() {
  _has_bits_[0] |= 0x00000008u;
}
inline void openRequest::clear_has_mode() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void openRequest::clear_mode() {
  mode_ = 0u;
  clear_has_mode();
}
inline ::google::protobuf::uint32 openRequest::mode() const {
  return mode_;
}
inline void openRequest::set_mode(::google::protobuf::uint32 value) {
  set_has_mode();
  mode_ = value;
}

// required fixed32 attributes = 5;
inline bool openRequest::has_attributes() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void openRequest::set_has_attributes() {
  _has_bits_[0] |= 0x00000010u;
}
inline void openRequest::clear_has_attributes() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void openRequest::clear_attributes() {
  attributes_ = 0u;
  clear_has_attributes();
}
inline ::google::protobuf::uint32 openRequest::attributes() const {
  return attributes_;
}
inline void openRequest::set_attributes(::google::protobuf::uint32 value) {
  set_has_attributes();
  attributes_ = value;
}

// optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 6;
inline bool openRequest::has_coordinates() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void openRequest::set_has_coordinates() {
  _has_bits_[0] |= 0x00000020u;
}
inline void openRequest::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void openRequest::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::xtreemfs::pbrpc::VivaldiCoordinates::Clear();
  clear_has_coordinates();
}
inline const ::xtreemfs::pbrpc::VivaldiCoordinates& openRequest::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* openRequest::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == NULL) coordinates_ = new ::xtreemfs::pbrpc::VivaldiCoordinates;
  return coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* openRequest::release_coordinates() {
  clear_has_coordinates();
  ::xtreemfs::pbrpc::VivaldiCoordinates* temp = coordinates_;
  coordinates_ = NULL;
  return temp;
}
inline void openRequest::set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates) {
  delete coordinates_;
  coordinates_ = coordinates;
  if (coordinates) {
    set_has_coordinates();
  } else {
    clear_has_coordinates();
  }
}

// -------------------------------------------------------------------

// openResponse

// required .xtreemfs.pbrpc.FileCredentials creds = 1;
inline bool openResponse::has_creds() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void openResponse::set_has_creds() {
  _has_bits_[0] |= 0x00000001u;
}
inline void openResponse::clear_has_creds() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void openResponse::clear_creds() {
  if (creds_ != NULL) creds_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_creds();
}
inline const ::xtreemfs::pbrpc::FileCredentials& openResponse::creds() const {
  return creds_ != NULL ? *creds_ : *default_instance_->creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* openResponse::mutable_creds() {
  set_has_creds();
  if (creds_ == NULL) creds_ = new ::xtreemfs::pbrpc::FileCredentials;
  return creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* openResponse::release_creds() {
  clear_has_creds();
  ::xtreemfs::pbrpc::FileCredentials* temp = creds_;
  creds_ = NULL;
  return temp;
}
inline void openResponse::set_allocated_creds(::xtreemfs::pbrpc::FileCredentials* creds) {
  delete creds_;
  creds_ = creds;
  if (creds) {
    set_has_creds();
  } else {
    clear_has_creds();
  }
}

// required fixed32 timestamp_s = 2;
inline bool openResponse::has_timestamp_s() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void openResponse::set_has_timestamp_s() {
  _has_bits_[0] |= 0x00000002u;
}
inline void openResponse::clear_has_timestamp_s() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void openResponse::clear_timestamp_s() {
  timestamp_s_ = 0u;
  clear_has_timestamp_s();
}
inline ::google::protobuf::uint32 openResponse::timestamp_s() const {
  return timestamp_s_;
}
inline void openResponse::set_timestamp_s(::google::protobuf::uint32 value) {
  set_has_timestamp_s();
  timestamp_s_ = value;
}

// -------------------------------------------------------------------

// readdirRequest

// required string volume_name = 1;
inline bool readdirRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void readdirRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void readdirRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void readdirRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& readdirRequest::volume_name() const {
  return *volume_name_;
}
inline void readdirRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void readdirRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void readdirRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readdirRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* readdirRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void readdirRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool readdirRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void readdirRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void readdirRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void readdirRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& readdirRequest::path() const {
  return *path_;
}
inline void readdirRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void readdirRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void readdirRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readdirRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* readdirRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void readdirRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 known_etag = 3;
inline bool readdirRequest::has_known_etag() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void readdirRequest::set_has_known_etag() {
  _has_bits_[0] |= 0x00000004u;
}
inline void readdirRequest::clear_has_known_etag() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void readdirRequest::clear_known_etag() {
  known_etag_ = GOOGLE_ULONGLONG(0);
  clear_has_known_etag();
}
inline ::google::protobuf::uint64 readdirRequest::known_etag() const {
  return known_etag_;
}
inline void readdirRequest::set_known_etag(::google::protobuf::uint64 value) {
  set_has_known_etag();
  known_etag_ = value;
}

// required fixed32 limit_directory_entries_count = 4;
inline bool readdirRequest::has_limit_directory_entries_count() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void readdirRequest::set_has_limit_directory_entries_count() {
  _has_bits_[0] |= 0x00000008u;
}
inline void readdirRequest::clear_has_limit_directory_entries_count() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void readdirRequest::clear_limit_directory_entries_count() {
  limit_directory_entries_count_ = 0u;
  clear_has_limit_directory_entries_count();
}
inline ::google::protobuf::uint32 readdirRequest::limit_directory_entries_count() const {
  return limit_directory_entries_count_;
}
inline void readdirRequest::set_limit_directory_entries_count(::google::protobuf::uint32 value) {
  set_has_limit_directory_entries_count();
  limit_directory_entries_count_ = value;
}

// required bool names_only = 5;
inline bool readdirRequest::has_names_only() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void readdirRequest::set_has_names_only() {
  _has_bits_[0] |= 0x00000010u;
}
inline void readdirRequest::clear_has_names_only() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void readdirRequest::clear_names_only() {
  names_only_ = false;
  clear_has_names_only();
}
inline bool readdirRequest::names_only() const {
  return names_only_;
}
inline void readdirRequest::set_names_only(bool value) {
  set_has_names_only();
  names_only_ = value;
}

// required fixed64 seen_directory_entries_count = 6;
inline bool readdirRequest::has_seen_directory_entries_count() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void readdirRequest::set_has_seen_directory_entries_count() {
  _has_bits_[0] |= 0x00000020u;
}
inline void readdirRequest::clear_has_seen_directory_entries_count() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void readdirRequest::clear_seen_directory_entries_count() {
  seen_directory_entries_count_ = GOOGLE_ULONGLONG(0);
  clear_has_seen_directory_entries_count();
}
inline ::google::protobuf::uint64 readdirRequest::seen_directory_entries_count() const {
  return seen_directory_entries_count_;
}
inline void readdirRequest::set_seen_directory_entries_count(::google::protobuf::uint64 value) {
  set_has_seen_directory_entries_count();
  seen_directory_entries_count_ = value;
}

// -------------------------------------------------------------------

// readlinkRequest

// required string volume_name = 1;
inline bool readlinkRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void readlinkRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void readlinkRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void readlinkRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& readlinkRequest::volume_name() const {
  return *volume_name_;
}
inline void readlinkRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void readlinkRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void readlinkRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readlinkRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* readlinkRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void readlinkRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool readlinkRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void readlinkRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void readlinkRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void readlinkRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& readlinkRequest::path() const {
  return *path_;
}
inline void readlinkRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void readlinkRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void readlinkRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readlinkRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* readlinkRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void readlinkRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// readlinkResponse

// repeated string link_target_path = 1;
inline int readlinkResponse::link_target_path_size() const {
  return link_target_path_.size();
}
inline void readlinkResponse::clear_link_target_path() {
  link_target_path_.Clear();
}
inline const ::std::string& readlinkResponse::link_target_path(int index) const {
  return link_target_path_.Get(index);
}
inline ::std::string* readlinkResponse::mutable_link_target_path(int index) {
  return link_target_path_.Mutable(index);
}
inline void readlinkResponse::set_link_target_path(int index, const ::std::string& value) {
  link_target_path_.Mutable(index)->assign(value);
}
inline void readlinkResponse::set_link_target_path(int index, const char* value) {
  link_target_path_.Mutable(index)->assign(value);
}
inline void readlinkResponse::set_link_target_path(int index, const char* value, size_t size) {
  link_target_path_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* readlinkResponse::add_link_target_path() {
  return link_target_path_.Add();
}
inline void readlinkResponse::add_link_target_path(const ::std::string& value) {
  link_target_path_.Add()->assign(value);
}
inline void readlinkResponse::add_link_target_path(const char* value) {
  link_target_path_.Add()->assign(value);
}
inline void readlinkResponse::add_link_target_path(const char* value, size_t size) {
  link_target_path_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
readlinkResponse::link_target_path() const {
  return link_target_path_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
readlinkResponse::mutable_link_target_path() {
  return &link_target_path_;
}

// -------------------------------------------------------------------

// removexattrRequest

// required string volume_name = 1;
inline bool removexattrRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void removexattrRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void removexattrRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void removexattrRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& removexattrRequest::volume_name() const {
  return *volume_name_;
}
inline void removexattrRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void removexattrRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void removexattrRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* removexattrRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* removexattrRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void removexattrRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool removexattrRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void removexattrRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void removexattrRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void removexattrRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& removexattrRequest::path() const {
  return *path_;
}
inline void removexattrRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void removexattrRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void removexattrRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* removexattrRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* removexattrRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void removexattrRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool removexattrRequest::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void removexattrRequest::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void removexattrRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void removexattrRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& removexattrRequest::name() const {
  return *name_;
}
inline void removexattrRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void removexattrRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void removexattrRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* removexattrRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* removexattrRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void removexattrRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// renameRequest

// required string volume_name = 1;
inline bool renameRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void renameRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void renameRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void renameRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& renameRequest::volume_name() const {
  return *volume_name_;
}
inline void renameRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void renameRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void renameRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* renameRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* renameRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void renameRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string source_path = 2;
inline bool renameRequest::has_source_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void renameRequest::set_has_source_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void renameRequest::clear_has_source_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void renameRequest::clear_source_path() {
  if (source_path_ != &::google::protobuf::internal::kEmptyString) {
    source_path_->clear();
  }
  clear_has_source_path();
}
inline const ::std::string& renameRequest::source_path() const {
  return *source_path_;
}
inline void renameRequest::set_source_path(const ::std::string& value) {
  set_has_source_path();
  if (source_path_ == &::google::protobuf::internal::kEmptyString) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(value);
}
inline void renameRequest::set_source_path(const char* value) {
  set_has_source_path();
  if (source_path_ == &::google::protobuf::internal::kEmptyString) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(value);
}
inline void renameRequest::set_source_path(const char* value, size_t size) {
  set_has_source_path();
  if (source_path_ == &::google::protobuf::internal::kEmptyString) {
    source_path_ = new ::std::string;
  }
  source_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* renameRequest::mutable_source_path() {
  set_has_source_path();
  if (source_path_ == &::google::protobuf::internal::kEmptyString) {
    source_path_ = new ::std::string;
  }
  return source_path_;
}
inline ::std::string* renameRequest::release_source_path() {
  clear_has_source_path();
  if (source_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = source_path_;
    source_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void renameRequest::set_allocated_source_path(::std::string* source_path) {
  if (source_path_ != &::google::protobuf::internal::kEmptyString) {
    delete source_path_;
  }
  if (source_path) {
    set_has_source_path();
    source_path_ = source_path;
  } else {
    clear_has_source_path();
    source_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string target_path = 3;
inline bool renameRequest::has_target_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void renameRequest::set_has_target_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void renameRequest::clear_has_target_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void renameRequest::clear_target_path() {
  if (target_path_ != &::google::protobuf::internal::kEmptyString) {
    target_path_->clear();
  }
  clear_has_target_path();
}
inline const ::std::string& renameRequest::target_path() const {
  return *target_path_;
}
inline void renameRequest::set_target_path(const ::std::string& value) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void renameRequest::set_target_path(const char* value) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void renameRequest::set_target_path(const char* value, size_t size) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* renameRequest::mutable_target_path() {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  return target_path_;
}
inline ::std::string* renameRequest::release_target_path() {
  clear_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_path_;
    target_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void renameRequest::set_allocated_target_path(::std::string* target_path) {
  if (target_path_ != &::google::protobuf::internal::kEmptyString) {
    delete target_path_;
  }
  if (target_path) {
    set_has_target_path();
    target_path_ = target_path;
  } else {
    clear_has_target_path();
    target_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// renameResponse

// required fixed32 timestamp_s = 1;
inline bool renameResponse::has_timestamp_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void renameResponse::set_has_timestamp_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void renameResponse::clear_has_timestamp_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void renameResponse::clear_timestamp_s() {
  timestamp_s_ = 0u;
  clear_has_timestamp_s();
}
inline ::google::protobuf::uint32 renameResponse::timestamp_s() const {
  return timestamp_s_;
}
inline void renameResponse::set_timestamp_s(::google::protobuf::uint32 value) {
  set_has_timestamp_s();
  timestamp_s_ = value;
}

// optional .xtreemfs.pbrpc.FileCredentials creds = 2;
inline bool renameResponse::has_creds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void renameResponse::set_has_creds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void renameResponse::clear_has_creds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void renameResponse::clear_creds() {
  if (creds_ != NULL) creds_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_creds();
}
inline const ::xtreemfs::pbrpc::FileCredentials& renameResponse::creds() const {
  return creds_ != NULL ? *creds_ : *default_instance_->creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* renameResponse::mutable_creds() {
  set_has_creds();
  if (creds_ == NULL) creds_ = new ::xtreemfs::pbrpc::FileCredentials;
  return creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* renameResponse::release_creds() {
  clear_has_creds();
  ::xtreemfs::pbrpc::FileCredentials* temp = creds_;
  creds_ = NULL;
  return temp;
}
inline void renameResponse::set_allocated_creds(::xtreemfs::pbrpc::FileCredentials* creds) {
  delete creds_;
  creds_ = creds;
  if (creds) {
    set_has_creds();
  } else {
    clear_has_creds();
  }
}

// -------------------------------------------------------------------

// rmdirRequest

// required string volume_name = 1;
inline bool rmdirRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void rmdirRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void rmdirRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void rmdirRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& rmdirRequest::volume_name() const {
  return *volume_name_;
}
inline void rmdirRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void rmdirRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void rmdirRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rmdirRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* rmdirRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rmdirRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool rmdirRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void rmdirRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void rmdirRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void rmdirRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& rmdirRequest::path() const {
  return *path_;
}
inline void rmdirRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void rmdirRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void rmdirRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* rmdirRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* rmdirRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void rmdirRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// setattrRequest

// required string volume_name = 1;
inline bool setattrRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void setattrRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void setattrRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void setattrRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& setattrRequest::volume_name() const {
  return *volume_name_;
}
inline void setattrRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void setattrRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void setattrRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setattrRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* setattrRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void setattrRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool setattrRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void setattrRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void setattrRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void setattrRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& setattrRequest::path() const {
  return *path_;
}
inline void setattrRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void setattrRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void setattrRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setattrRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* setattrRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void setattrRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .xtreemfs.pbrpc.Stat stbuf = 3;
inline bool setattrRequest::has_stbuf() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void setattrRequest::set_has_stbuf() {
  _has_bits_[0] |= 0x00000004u;
}
inline void setattrRequest::clear_has_stbuf() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void setattrRequest::clear_stbuf() {
  if (stbuf_ != NULL) stbuf_->::xtreemfs::pbrpc::Stat::Clear();
  clear_has_stbuf();
}
inline const ::xtreemfs::pbrpc::Stat& setattrRequest::stbuf() const {
  return stbuf_ != NULL ? *stbuf_ : *default_instance_->stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* setattrRequest::mutable_stbuf() {
  set_has_stbuf();
  if (stbuf_ == NULL) stbuf_ = new ::xtreemfs::pbrpc::Stat;
  return stbuf_;
}
inline ::xtreemfs::pbrpc::Stat* setattrRequest::release_stbuf() {
  clear_has_stbuf();
  ::xtreemfs::pbrpc::Stat* temp = stbuf_;
  stbuf_ = NULL;
  return temp;
}
inline void setattrRequest::set_allocated_stbuf(::xtreemfs::pbrpc::Stat* stbuf) {
  delete stbuf_;
  stbuf_ = stbuf;
  if (stbuf) {
    set_has_stbuf();
  } else {
    clear_has_stbuf();
  }
}

// required fixed32 to_set = 4;
inline bool setattrRequest::has_to_set() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void setattrRequest::set_has_to_set() {
  _has_bits_[0] |= 0x00000008u;
}
inline void setattrRequest::clear_has_to_set() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void setattrRequest::clear_to_set() {
  to_set_ = 0u;
  clear_has_to_set();
}
inline ::google::protobuf::uint32 setattrRequest::to_set() const {
  return to_set_;
}
inline void setattrRequest::set_to_set(::google::protobuf::uint32 value) {
  set_has_to_set();
  to_set_ = value;
}

// -------------------------------------------------------------------

// setxattrRequest

// required string volume_name = 1;
inline bool setxattrRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void setxattrRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void setxattrRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void setxattrRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& setxattrRequest::volume_name() const {
  return *volume_name_;
}
inline void setxattrRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void setxattrRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void setxattrRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* setxattrRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void setxattrRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool setxattrRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void setxattrRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void setxattrRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void setxattrRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& setxattrRequest::path() const {
  return *path_;
}
inline void setxattrRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void setxattrRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void setxattrRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* setxattrRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void setxattrRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string name = 3;
inline bool setxattrRequest::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void setxattrRequest::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void setxattrRequest::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void setxattrRequest::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& setxattrRequest::name() const {
  return *name_;
}
inline void setxattrRequest::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void setxattrRequest::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void setxattrRequest::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* setxattrRequest::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void setxattrRequest::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string value = 4;
inline bool setxattrRequest::has_value() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void setxattrRequest::set_has_value() {
  _has_bits_[0] |= 0x00000008u;
}
inline void setxattrRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void setxattrRequest::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& setxattrRequest::value() const {
  return *value_;
}
inline void setxattrRequest::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void setxattrRequest::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void setxattrRequest::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* setxattrRequest::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void setxattrRequest::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bytes value_bytes_string = 6;
inline bool setxattrRequest::has_value_bytes_string() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void setxattrRequest::set_has_value_bytes_string() {
  _has_bits_[0] |= 0x00000010u;
}
inline void setxattrRequest::clear_has_value_bytes_string() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void setxattrRequest::clear_value_bytes_string() {
  if (value_bytes_string_ != &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_->clear();
  }
  clear_has_value_bytes_string();
}
inline const ::std::string& setxattrRequest::value_bytes_string() const {
  return *value_bytes_string_;
}
inline void setxattrRequest::set_value_bytes_string(const ::std::string& value) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(value);
}
inline void setxattrRequest::set_value_bytes_string(const char* value) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(value);
}
inline void setxattrRequest::set_value_bytes_string(const void* value, size_t size) {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  value_bytes_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* setxattrRequest::mutable_value_bytes_string() {
  set_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    value_bytes_string_ = new ::std::string;
  }
  return value_bytes_string_;
}
inline ::std::string* setxattrRequest::release_value_bytes_string() {
  clear_has_value_bytes_string();
  if (value_bytes_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_bytes_string_;
    value_bytes_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void setxattrRequest::set_allocated_value_bytes_string(::std::string* value_bytes_string) {
  if (value_bytes_string_ != &::google::protobuf::internal::kEmptyString) {
    delete value_bytes_string_;
  }
  if (value_bytes_string) {
    set_has_value_bytes_string();
    value_bytes_string_ = value_bytes_string;
  } else {
    clear_has_value_bytes_string();
    value_bytes_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 flags = 5;
inline bool setxattrRequest::has_flags() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void setxattrRequest::set_has_flags() {
  _has_bits_[0] |= 0x00000020u;
}
inline void setxattrRequest::clear_has_flags() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void setxattrRequest::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 setxattrRequest::flags() const {
  return flags_;
}
inline void setxattrRequest::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// statvfsRequest

// required string volume_name = 1;
inline bool statvfsRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void statvfsRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void statvfsRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void statvfsRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& statvfsRequest::volume_name() const {
  return *volume_name_;
}
inline void statvfsRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void statvfsRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void statvfsRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* statvfsRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* statvfsRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void statvfsRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 known_etag = 5;
inline bool statvfsRequest::has_known_etag() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void statvfsRequest::set_has_known_etag() {
  _has_bits_[0] |= 0x00000002u;
}
inline void statvfsRequest::clear_has_known_etag() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void statvfsRequest::clear_known_etag() {
  known_etag_ = GOOGLE_ULONGLONG(0);
  clear_has_known_etag();
}
inline ::google::protobuf::uint64 statvfsRequest::known_etag() const {
  return known_etag_;
}
inline void statvfsRequest::set_known_etag(::google::protobuf::uint64 value) {
  set_has_known_etag();
  known_etag_ = value;
}

// -------------------------------------------------------------------

// symlinkRequest

// required string volume_name = 1;
inline bool symlinkRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void symlinkRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void symlinkRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void symlinkRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& symlinkRequest::volume_name() const {
  return *volume_name_;
}
inline void symlinkRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void symlinkRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void symlinkRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* symlinkRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* symlinkRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void symlinkRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string target_path = 2;
inline bool symlinkRequest::has_target_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void symlinkRequest::set_has_target_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void symlinkRequest::clear_has_target_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void symlinkRequest::clear_target_path() {
  if (target_path_ != &::google::protobuf::internal::kEmptyString) {
    target_path_->clear();
  }
  clear_has_target_path();
}
inline const ::std::string& symlinkRequest::target_path() const {
  return *target_path_;
}
inline void symlinkRequest::set_target_path(const ::std::string& value) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void symlinkRequest::set_target_path(const char* value) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(value);
}
inline void symlinkRequest::set_target_path(const char* value, size_t size) {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  target_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* symlinkRequest::mutable_target_path() {
  set_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    target_path_ = new ::std::string;
  }
  return target_path_;
}
inline ::std::string* symlinkRequest::release_target_path() {
  clear_has_target_path();
  if (target_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = target_path_;
    target_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void symlinkRequest::set_allocated_target_path(::std::string* target_path) {
  if (target_path_ != &::google::protobuf::internal::kEmptyString) {
    delete target_path_;
  }
  if (target_path) {
    set_has_target_path();
    target_path_ = target_path;
  } else {
    clear_has_target_path();
    target_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string link_path = 3;
inline bool symlinkRequest::has_link_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void symlinkRequest::set_has_link_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void symlinkRequest::clear_has_link_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void symlinkRequest::clear_link_path() {
  if (link_path_ != &::google::protobuf::internal::kEmptyString) {
    link_path_->clear();
  }
  clear_has_link_path();
}
inline const ::std::string& symlinkRequest::link_path() const {
  return *link_path_;
}
inline void symlinkRequest::set_link_path(const ::std::string& value) {
  set_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(value);
}
inline void symlinkRequest::set_link_path(const char* value) {
  set_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(value);
}
inline void symlinkRequest::set_link_path(const char* value, size_t size) {
  set_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    link_path_ = new ::std::string;
  }
  link_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* symlinkRequest::mutable_link_path() {
  set_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    link_path_ = new ::std::string;
  }
  return link_path_;
}
inline ::std::string* symlinkRequest::release_link_path() {
  clear_has_link_path();
  if (link_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = link_path_;
    link_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void symlinkRequest::set_allocated_link_path(::std::string* link_path) {
  if (link_path_ != &::google::protobuf::internal::kEmptyString) {
    delete link_path_;
  }
  if (link_path) {
    set_has_link_path();
    link_path_ = link_path;
  } else {
    clear_has_link_path();
    link_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// unlinkRequest

// required string volume_name = 1;
inline bool unlinkRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void unlinkRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void unlinkRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void unlinkRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& unlinkRequest::volume_name() const {
  return *volume_name_;
}
inline void unlinkRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void unlinkRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void unlinkRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* unlinkRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* unlinkRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void unlinkRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool unlinkRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void unlinkRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void unlinkRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void unlinkRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& unlinkRequest::path() const {
  return *path_;
}
inline void unlinkRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void unlinkRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void unlinkRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* unlinkRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* unlinkRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void unlinkRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// unlinkResponse

// required fixed32 timestamp_s = 1;
inline bool unlinkResponse::has_timestamp_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void unlinkResponse::set_has_timestamp_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void unlinkResponse::clear_has_timestamp_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void unlinkResponse::clear_timestamp_s() {
  timestamp_s_ = 0u;
  clear_has_timestamp_s();
}
inline ::google::protobuf::uint32 unlinkResponse::timestamp_s() const {
  return timestamp_s_;
}
inline void unlinkResponse::set_timestamp_s(::google::protobuf::uint32 value) {
  set_has_timestamp_s();
  timestamp_s_ = value;
}

// optional .xtreemfs.pbrpc.FileCredentials creds = 2;
inline bool unlinkResponse::has_creds() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void unlinkResponse::set_has_creds() {
  _has_bits_[0] |= 0x00000002u;
}
inline void unlinkResponse::clear_has_creds() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void unlinkResponse::clear_creds() {
  if (creds_ != NULL) creds_->::xtreemfs::pbrpc::FileCredentials::Clear();
  clear_has_creds();
}
inline const ::xtreemfs::pbrpc::FileCredentials& unlinkResponse::creds() const {
  return creds_ != NULL ? *creds_ : *default_instance_->creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* unlinkResponse::mutable_creds() {
  set_has_creds();
  if (creds_ == NULL) creds_ = new ::xtreemfs::pbrpc::FileCredentials;
  return creds_;
}
inline ::xtreemfs::pbrpc::FileCredentials* unlinkResponse::release_creds() {
  clear_has_creds();
  ::xtreemfs::pbrpc::FileCredentials* temp = creds_;
  creds_ = NULL;
  return temp;
}
inline void unlinkResponse::set_allocated_creds(::xtreemfs::pbrpc::FileCredentials* creds) {
  delete creds_;
  creds_ = creds;
  if (creds) {
    set_has_creds();
  } else {
    clear_has_creds();
  }
}

// -------------------------------------------------------------------

// accessRequest

// required string volume_name = 1;
inline bool accessRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void accessRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void accessRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void accessRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& accessRequest::volume_name() const {
  return *volume_name_;
}
inline void accessRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void accessRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void accessRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accessRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* accessRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accessRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string path = 2;
inline bool accessRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void accessRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void accessRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void accessRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& accessRequest::path() const {
  return *path_;
}
inline void accessRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void accessRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void accessRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* accessRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* accessRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void accessRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 flags = 3;
inline bool accessRequest::has_flags() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void accessRequest::set_has_flags() {
  _has_bits_[0] |= 0x00000004u;
}
inline void accessRequest::clear_has_flags() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void accessRequest::clear_flags() {
  flags_ = 0u;
  clear_has_flags();
}
inline ::google::protobuf::uint32 accessRequest::flags() const {
  return flags_;
}
inline void accessRequest::set_flags(::google::protobuf::uint32 value) {
  set_has_flags();
  flags_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_check_file_existsRequest

// required string volume_id = 1;
inline bool xtreemfs_check_file_existsRequest::has_volume_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_check_file_existsRequest::set_has_volume_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_check_file_existsRequest::clear_has_volume_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_check_file_existsRequest::clear_volume_id() {
  if (volume_id_ != &::google::protobuf::internal::kEmptyString) {
    volume_id_->clear();
  }
  clear_has_volume_id();
}
inline const ::std::string& xtreemfs_check_file_existsRequest::volume_id() const {
  return *volume_id_;
}
inline void xtreemfs_check_file_existsRequest::set_volume_id(const ::std::string& value) {
  set_has_volume_id();
  if (volume_id_ == &::google::protobuf::internal::kEmptyString) {
    volume_id_ = new ::std::string;
  }
  volume_id_->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_volume_id(const char* value) {
  set_has_volume_id();
  if (volume_id_ == &::google::protobuf::internal::kEmptyString) {
    volume_id_ = new ::std::string;
  }
  volume_id_->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_volume_id(const char* value, size_t size) {
  set_has_volume_id();
  if (volume_id_ == &::google::protobuf::internal::kEmptyString) {
    volume_id_ = new ::std::string;
  }
  volume_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_check_file_existsRequest::mutable_volume_id() {
  set_has_volume_id();
  if (volume_id_ == &::google::protobuf::internal::kEmptyString) {
    volume_id_ = new ::std::string;
  }
  return volume_id_;
}
inline ::std::string* xtreemfs_check_file_existsRequest::release_volume_id() {
  clear_has_volume_id();
  if (volume_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_id_;
    volume_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_check_file_existsRequest::set_allocated_volume_id(::std::string* volume_id) {
  if (volume_id_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_id_;
  }
  if (volume_id) {
    set_has_volume_id();
    volume_id_ = volume_id;
  } else {
    clear_has_volume_id();
    volume_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string file_ids = 2;
inline int xtreemfs_check_file_existsRequest::file_ids_size() const {
  return file_ids_.size();
}
inline void xtreemfs_check_file_existsRequest::clear_file_ids() {
  file_ids_.Clear();
}
inline const ::std::string& xtreemfs_check_file_existsRequest::file_ids(int index) const {
  return file_ids_.Get(index);
}
inline ::std::string* xtreemfs_check_file_existsRequest::mutable_file_ids(int index) {
  return file_ids_.Mutable(index);
}
inline void xtreemfs_check_file_existsRequest::set_file_ids(int index, const ::std::string& value) {
  file_ids_.Mutable(index)->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_file_ids(int index, const char* value) {
  file_ids_.Mutable(index)->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_file_ids(int index, const char* value, size_t size) {
  file_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_check_file_existsRequest::add_file_ids() {
  return file_ids_.Add();
}
inline void xtreemfs_check_file_existsRequest::add_file_ids(const ::std::string& value) {
  file_ids_.Add()->assign(value);
}
inline void xtreemfs_check_file_existsRequest::add_file_ids(const char* value) {
  file_ids_.Add()->assign(value);
}
inline void xtreemfs_check_file_existsRequest::add_file_ids(const char* value, size_t size) {
  file_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
xtreemfs_check_file_existsRequest::file_ids() const {
  return file_ids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
xtreemfs_check_file_existsRequest::mutable_file_ids() {
  return &file_ids_;
}

// required string osd_uuid = 3;
inline bool xtreemfs_check_file_existsRequest::has_osd_uuid() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_check_file_existsRequest::set_has_osd_uuid() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_check_file_existsRequest::clear_has_osd_uuid() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_check_file_existsRequest::clear_osd_uuid() {
  if (osd_uuid_ != &::google::protobuf::internal::kEmptyString) {
    osd_uuid_->clear();
  }
  clear_has_osd_uuid();
}
inline const ::std::string& xtreemfs_check_file_existsRequest::osd_uuid() const {
  return *osd_uuid_;
}
inline void xtreemfs_check_file_existsRequest::set_osd_uuid(const ::std::string& value) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_osd_uuid(const char* value) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_check_file_existsRequest::set_osd_uuid(const char* value, size_t size) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_check_file_existsRequest::mutable_osd_uuid() {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  return osd_uuid_;
}
inline ::std::string* xtreemfs_check_file_existsRequest::release_osd_uuid() {
  clear_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osd_uuid_;
    osd_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_check_file_existsRequest::set_allocated_osd_uuid(::std::string* osd_uuid) {
  if (osd_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete osd_uuid_;
  }
  if (osd_uuid) {
    set_has_osd_uuid();
    osd_uuid_ = osd_uuid;
  } else {
    clear_has_osd_uuid();
    osd_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_check_file_existsResponse

// required bool volume_exists = 1;
inline bool xtreemfs_check_file_existsResponse::has_volume_exists() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_check_file_existsResponse::set_has_volume_exists() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_check_file_existsResponse::clear_has_volume_exists() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_check_file_existsResponse::clear_volume_exists() {
  volume_exists_ = false;
  clear_has_volume_exists();
}
inline bool xtreemfs_check_file_existsResponse::volume_exists() const {
  return volume_exists_;
}
inline void xtreemfs_check_file_existsResponse::set_volume_exists(bool value) {
  set_has_volume_exists();
  volume_exists_ = value;
}

// repeated .xtreemfs.pbrpc.xtreemfs_check_file_existsResponse.FILE_STATE file_states = 2 [packed = true];
inline int xtreemfs_check_file_existsResponse::file_states_size() const {
  return file_states_.size();
}
inline void xtreemfs_check_file_existsResponse::clear_file_states() {
  file_states_.Clear();
}
inline ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE xtreemfs_check_file_existsResponse::file_states(int index) const {
  return static_cast< ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE >(file_states_.Get(index));
}
inline void xtreemfs_check_file_existsResponse::set_file_states(int index, ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE value) {
  assert(::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE_IsValid(value));
  file_states_.Set(index, value);
}
inline void xtreemfs_check_file_existsResponse::add_file_states(::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE value) {
  assert(::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE_IsValid(value));
  file_states_.Add(value);
}
inline const ::google::protobuf::RepeatedField<int>&
xtreemfs_check_file_existsResponse::file_states() const {
  return file_states_;
}
inline ::google::protobuf::RepeatedField<int>*
xtreemfs_check_file_existsResponse::mutable_file_states() {
  return &file_states_;
}

// -------------------------------------------------------------------

// xtreemfs_dump_restore_databaseRequest

// required string dump_file = 1;
inline bool xtreemfs_dump_restore_databaseRequest::has_dump_file() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_dump_restore_databaseRequest::set_has_dump_file() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_dump_restore_databaseRequest::clear_has_dump_file() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_dump_restore_databaseRequest::clear_dump_file() {
  if (dump_file_ != &::google::protobuf::internal::kEmptyString) {
    dump_file_->clear();
  }
  clear_has_dump_file();
}
inline const ::std::string& xtreemfs_dump_restore_databaseRequest::dump_file() const {
  return *dump_file_;
}
inline void xtreemfs_dump_restore_databaseRequest::set_dump_file(const ::std::string& value) {
  set_has_dump_file();
  if (dump_file_ == &::google::protobuf::internal::kEmptyString) {
    dump_file_ = new ::std::string;
  }
  dump_file_->assign(value);
}
inline void xtreemfs_dump_restore_databaseRequest::set_dump_file(const char* value) {
  set_has_dump_file();
  if (dump_file_ == &::google::protobuf::internal::kEmptyString) {
    dump_file_ = new ::std::string;
  }
  dump_file_->assign(value);
}
inline void xtreemfs_dump_restore_databaseRequest::set_dump_file(const char* value, size_t size) {
  set_has_dump_file();
  if (dump_file_ == &::google::protobuf::internal::kEmptyString) {
    dump_file_ = new ::std::string;
  }
  dump_file_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_dump_restore_databaseRequest::mutable_dump_file() {
  set_has_dump_file();
  if (dump_file_ == &::google::protobuf::internal::kEmptyString) {
    dump_file_ = new ::std::string;
  }
  return dump_file_;
}
inline ::std::string* xtreemfs_dump_restore_databaseRequest::release_dump_file() {
  clear_has_dump_file();
  if (dump_file_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = dump_file_;
    dump_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_dump_restore_databaseRequest::set_allocated_dump_file(::std::string* dump_file) {
  if (dump_file_ != &::google::protobuf::internal::kEmptyString) {
    delete dump_file_;
  }
  if (dump_file) {
    set_has_dump_file();
    dump_file_ = dump_file;
  } else {
    clear_has_dump_file();
    dump_file_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_get_suitable_osdsRequest

// optional string file_id = 1;
inline bool xtreemfs_get_suitable_osdsRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_get_suitable_osdsRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_get_suitable_osdsRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_get_suitable_osdsRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_get_suitable_osdsRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_get_suitable_osdsRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_get_suitable_osdsRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 3;
inline bool xtreemfs_get_suitable_osdsRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_get_suitable_osdsRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_get_suitable_osdsRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_get_suitable_osdsRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& xtreemfs_get_suitable_osdsRequest::path() const {
  return *path_;
}
inline void xtreemfs_get_suitable_osdsRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_get_suitable_osdsRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volume_name = 4;
inline bool xtreemfs_get_suitable_osdsRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_get_suitable_osdsRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_get_suitable_osdsRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_get_suitable_osdsRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& xtreemfs_get_suitable_osdsRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_get_suitable_osdsRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_get_suitable_osdsRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* xtreemfs_get_suitable_osdsRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_get_suitable_osdsRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 num_osds = 2;
inline bool xtreemfs_get_suitable_osdsRequest::has_num_osds() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_get_suitable_osdsRequest::set_has_num_osds() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_get_suitable_osdsRequest::clear_has_num_osds() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_get_suitable_osdsRequest::clear_num_osds() {
  num_osds_ = 0u;
  clear_has_num_osds();
}
inline ::google::protobuf::uint32 xtreemfs_get_suitable_osdsRequest::num_osds() const {
  return num_osds_;
}
inline void xtreemfs_get_suitable_osdsRequest::set_num_osds(::google::protobuf::uint32 value) {
  set_has_num_osds();
  num_osds_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_get_suitable_osdsResponse

// repeated string osd_uuids = 1;
inline int xtreemfs_get_suitable_osdsResponse::osd_uuids_size() const {
  return osd_uuids_.size();
}
inline void xtreemfs_get_suitable_osdsResponse::clear_osd_uuids() {
  osd_uuids_.Clear();
}
inline const ::std::string& xtreemfs_get_suitable_osdsResponse::osd_uuids(int index) const {
  return osd_uuids_.Get(index);
}
inline ::std::string* xtreemfs_get_suitable_osdsResponse::mutable_osd_uuids(int index) {
  return osd_uuids_.Mutable(index);
}
inline void xtreemfs_get_suitable_osdsResponse::set_osd_uuids(int index, const ::std::string& value) {
  osd_uuids_.Mutable(index)->assign(value);
}
inline void xtreemfs_get_suitable_osdsResponse::set_osd_uuids(int index, const char* value) {
  osd_uuids_.Mutable(index)->assign(value);
}
inline void xtreemfs_get_suitable_osdsResponse::set_osd_uuids(int index, const char* value, size_t size) {
  osd_uuids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_suitable_osdsResponse::add_osd_uuids() {
  return osd_uuids_.Add();
}
inline void xtreemfs_get_suitable_osdsResponse::add_osd_uuids(const ::std::string& value) {
  osd_uuids_.Add()->assign(value);
}
inline void xtreemfs_get_suitable_osdsResponse::add_osd_uuids(const char* value) {
  osd_uuids_.Add()->assign(value);
}
inline void xtreemfs_get_suitable_osdsResponse::add_osd_uuids(const char* value, size_t size) {
  osd_uuids_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
xtreemfs_get_suitable_osdsResponse::osd_uuids() const {
  return osd_uuids_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
xtreemfs_get_suitable_osdsResponse::mutable_osd_uuids() {
  return &osd_uuids_;
}

// -------------------------------------------------------------------

// timestampResponse

// required fixed32 timestamp_s = 1;
inline bool timestampResponse::has_timestamp_s() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void timestampResponse::set_has_timestamp_s() {
  _has_bits_[0] |= 0x00000001u;
}
inline void timestampResponse::clear_has_timestamp_s() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void timestampResponse::clear_timestamp_s() {
  timestamp_s_ = 0u;
  clear_has_timestamp_s();
}
inline ::google::protobuf::uint32 timestampResponse::timestamp_s() const {
  return timestamp_s_;
}
inline void timestampResponse::set_timestamp_s(::google::protobuf::uint32 value) {
  set_has_timestamp_s();
  timestamp_s_ = value;
}

// -------------------------------------------------------------------

// stringMessage

// required string a_string = 1;
inline bool stringMessage::has_a_string() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void stringMessage::set_has_a_string() {
  _has_bits_[0] |= 0x00000001u;
}
inline void stringMessage::clear_has_a_string() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void stringMessage::clear_a_string() {
  if (a_string_ != &::google::protobuf::internal::kEmptyString) {
    a_string_->clear();
  }
  clear_has_a_string();
}
inline const ::std::string& stringMessage::a_string() const {
  return *a_string_;
}
inline void stringMessage::set_a_string(const ::std::string& value) {
  set_has_a_string();
  if (a_string_ == &::google::protobuf::internal::kEmptyString) {
    a_string_ = new ::std::string;
  }
  a_string_->assign(value);
}
inline void stringMessage::set_a_string(const char* value) {
  set_has_a_string();
  if (a_string_ == &::google::protobuf::internal::kEmptyString) {
    a_string_ = new ::std::string;
  }
  a_string_->assign(value);
}
inline void stringMessage::set_a_string(const char* value, size_t size) {
  set_has_a_string();
  if (a_string_ == &::google::protobuf::internal::kEmptyString) {
    a_string_ = new ::std::string;
  }
  a_string_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* stringMessage::mutable_a_string() {
  set_has_a_string();
  if (a_string_ == &::google::protobuf::internal::kEmptyString) {
    a_string_ = new ::std::string;
  }
  return a_string_;
}
inline ::std::string* stringMessage::release_a_string() {
  clear_has_a_string();
  if (a_string_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = a_string_;
    a_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void stringMessage::set_allocated_a_string(::std::string* a_string) {
  if (a_string_ != &::google::protobuf::internal::kEmptyString) {
    delete a_string_;
  }
  if (a_string) {
    set_has_a_string();
    a_string_ = a_string;
  } else {
    clear_has_a_string();
    a_string_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_listdirRequest

// required string path = 1;
inline bool xtreemfs_listdirRequest::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_listdirRequest::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_listdirRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_listdirRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& xtreemfs_listdirRequest::path() const {
  return *path_;
}
inline void xtreemfs_listdirRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_listdirRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_listdirRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_listdirRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* xtreemfs_listdirRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_listdirRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_listdirResponse

// repeated string names = 1;
inline int xtreemfs_listdirResponse::names_size() const {
  return names_.size();
}
inline void xtreemfs_listdirResponse::clear_names() {
  names_.Clear();
}
inline const ::std::string& xtreemfs_listdirResponse::names(int index) const {
  return names_.Get(index);
}
inline ::std::string* xtreemfs_listdirResponse::mutable_names(int index) {
  return names_.Mutable(index);
}
inline void xtreemfs_listdirResponse::set_names(int index, const ::std::string& value) {
  names_.Mutable(index)->assign(value);
}
inline void xtreemfs_listdirResponse::set_names(int index, const char* value) {
  names_.Mutable(index)->assign(value);
}
inline void xtreemfs_listdirResponse::set_names(int index, const char* value, size_t size) {
  names_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_listdirResponse::add_names() {
  return names_.Add();
}
inline void xtreemfs_listdirResponse::add_names(const ::std::string& value) {
  names_.Add()->assign(value);
}
inline void xtreemfs_listdirResponse::add_names(const char* value) {
  names_.Add()->assign(value);
}
inline void xtreemfs_listdirResponse::add_names(const char* value, size_t size) {
  names_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
xtreemfs_listdirResponse::names() const {
  return names_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
xtreemfs_listdirResponse::mutable_names() {
  return &names_;
}

// -------------------------------------------------------------------

// xtreemfs_replica_addRequest

// optional string file_id = 1;
inline bool xtreemfs_replica_addRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_replica_addRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_replica_addRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_replica_addRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_replica_addRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_replica_addRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_addRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_replica_addRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_addRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 3;
inline bool xtreemfs_replica_addRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_replica_addRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_replica_addRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_replica_addRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& xtreemfs_replica_addRequest::path() const {
  return *path_;
}
inline void xtreemfs_replica_addRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_addRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* xtreemfs_replica_addRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_addRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volume_name = 4;
inline bool xtreemfs_replica_addRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_replica_addRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_replica_addRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_replica_addRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& xtreemfs_replica_addRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_replica_addRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_addRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_addRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* xtreemfs_replica_addRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_addRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required .xtreemfs.pbrpc.Replica new_replica = 2;
inline bool xtreemfs_replica_addRequest::has_new_replica() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_replica_addRequest::set_has_new_replica() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_replica_addRequest::clear_has_new_replica() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_replica_addRequest::clear_new_replica() {
  if (new_replica_ != NULL) new_replica_->::xtreemfs::pbrpc::Replica::Clear();
  clear_has_new_replica();
}
inline const ::xtreemfs::pbrpc::Replica& xtreemfs_replica_addRequest::new_replica() const {
  return new_replica_ != NULL ? *new_replica_ : *default_instance_->new_replica_;
}
inline ::xtreemfs::pbrpc::Replica* xtreemfs_replica_addRequest::mutable_new_replica() {
  set_has_new_replica();
  if (new_replica_ == NULL) new_replica_ = new ::xtreemfs::pbrpc::Replica;
  return new_replica_;
}
inline ::xtreemfs::pbrpc::Replica* xtreemfs_replica_addRequest::release_new_replica() {
  clear_has_new_replica();
  ::xtreemfs::pbrpc::Replica* temp = new_replica_;
  new_replica_ = NULL;
  return temp;
}
inline void xtreemfs_replica_addRequest::set_allocated_new_replica(::xtreemfs::pbrpc::Replica* new_replica) {
  delete new_replica_;
  new_replica_ = new_replica;
  if (new_replica) {
    set_has_new_replica();
  } else {
    clear_has_new_replica();
  }
}

// -------------------------------------------------------------------

// xtreemfs_replica_addResponse

// required string file_id = 1;
inline bool xtreemfs_replica_addResponse::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_replica_addResponse::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_replica_addResponse::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_replica_addResponse::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_replica_addResponse::file_id() const {
  return *file_id_;
}
inline void xtreemfs_replica_addResponse::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_addResponse::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_addResponse::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_addResponse::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_replica_addResponse::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_addResponse::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 expected_xlocset_version = 2;
inline bool xtreemfs_replica_addResponse::has_expected_xlocset_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_replica_addResponse::set_has_expected_xlocset_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_replica_addResponse::clear_has_expected_xlocset_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_replica_addResponse::clear_expected_xlocset_version() {
  expected_xlocset_version_ = 0;
  clear_has_expected_xlocset_version();
}
inline ::google::protobuf::int32 xtreemfs_replica_addResponse::expected_xlocset_version() const {
  return expected_xlocset_version_;
}
inline void xtreemfs_replica_addResponse::set_expected_xlocset_version(::google::protobuf::int32 value) {
  set_has_expected_xlocset_version();
  expected_xlocset_version_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_replica_listRequest

// optional string file_id = 1;
inline bool xtreemfs_replica_listRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_replica_listRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_replica_listRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_replica_listRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_replica_listRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_replica_listRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_listRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_replica_listRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_listRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 2;
inline bool xtreemfs_replica_listRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_replica_listRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_replica_listRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_replica_listRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& xtreemfs_replica_listRequest::path() const {
  return *path_;
}
inline void xtreemfs_replica_listRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_listRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* xtreemfs_replica_listRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_listRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volume_name = 3;
inline bool xtreemfs_replica_listRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_replica_listRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_replica_listRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_replica_listRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& xtreemfs_replica_listRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_replica_listRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_listRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_listRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* xtreemfs_replica_listRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_listRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_get_xlocsetRequest

// optional string file_id = 1;
inline bool xtreemfs_get_xlocsetRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_get_xlocsetRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_get_xlocsetRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_get_xlocsetRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_get_xlocsetRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_get_xlocsetRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_xlocsetRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_xlocsetRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_xlocsetRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_get_xlocsetRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_get_xlocsetRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 2;
inline bool xtreemfs_get_xlocsetRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_get_xlocsetRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_get_xlocsetRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_get_xlocsetRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& xtreemfs_get_xlocsetRequest::path() const {
  return *path_;
}
inline void xtreemfs_get_xlocsetRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_get_xlocsetRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_get_xlocsetRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_xlocsetRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* xtreemfs_get_xlocsetRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_get_xlocsetRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volume_name = 3;
inline bool xtreemfs_get_xlocsetRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_get_xlocsetRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_get_xlocsetRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_get_xlocsetRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& xtreemfs_get_xlocsetRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_get_xlocsetRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_get_xlocsetRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_get_xlocsetRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_xlocsetRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* xtreemfs_get_xlocsetRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_get_xlocsetRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .xtreemfs.pbrpc.XCap xcap = 4;
inline bool xtreemfs_get_xlocsetRequest::has_xcap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_get_xlocsetRequest::set_has_xcap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_get_xlocsetRequest::clear_has_xcap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_get_xlocsetRequest::clear_xcap() {
  if (xcap_ != NULL) xcap_->::xtreemfs::pbrpc::XCap::Clear();
  clear_has_xcap();
}
inline const ::xtreemfs::pbrpc::XCap& xtreemfs_get_xlocsetRequest::xcap() const {
  return xcap_ != NULL ? *xcap_ : *default_instance_->xcap_;
}
inline ::xtreemfs::pbrpc::XCap* xtreemfs_get_xlocsetRequest::mutable_xcap() {
  set_has_xcap();
  if (xcap_ == NULL) xcap_ = new ::xtreemfs::pbrpc::XCap;
  return xcap_;
}
inline ::xtreemfs::pbrpc::XCap* xtreemfs_get_xlocsetRequest::release_xcap() {
  clear_has_xcap();
  ::xtreemfs::pbrpc::XCap* temp = xcap_;
  xcap_ = NULL;
  return temp;
}
inline void xtreemfs_get_xlocsetRequest::set_allocated_xcap(::xtreemfs::pbrpc::XCap* xcap) {
  delete xcap_;
  xcap_ = xcap;
  if (xcap) {
    set_has_xcap();
  } else {
    clear_has_xcap();
  }
}

// optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 5;
inline bool xtreemfs_get_xlocsetRequest::has_coordinates() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void xtreemfs_get_xlocsetRequest::set_has_coordinates() {
  _has_bits_[0] |= 0x00000010u;
}
inline void xtreemfs_get_xlocsetRequest::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void xtreemfs_get_xlocsetRequest::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::xtreemfs::pbrpc::VivaldiCoordinates::Clear();
  clear_has_coordinates();
}
inline const ::xtreemfs::pbrpc::VivaldiCoordinates& xtreemfs_get_xlocsetRequest::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_get_xlocsetRequest::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == NULL) coordinates_ = new ::xtreemfs::pbrpc::VivaldiCoordinates;
  return coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_get_xlocsetRequest::release_coordinates() {
  clear_has_coordinates();
  ::xtreemfs::pbrpc::VivaldiCoordinates* temp = coordinates_;
  coordinates_ = NULL;
  return temp;
}
inline void xtreemfs_get_xlocsetRequest::set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates) {
  delete coordinates_;
  coordinates_ = coordinates;
  if (coordinates) {
    set_has_coordinates();
  } else {
    clear_has_coordinates();
  }
}

// -------------------------------------------------------------------

// xtreemfs_replica_removeRequest

// optional string file_id = 1;
inline bool xtreemfs_replica_removeRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_replica_removeRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_replica_removeRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_replica_removeRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_replica_removeRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_replica_removeRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_replica_removeRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_removeRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string path = 3;
inline bool xtreemfs_replica_removeRequest::has_path() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_replica_removeRequest::set_has_path() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_replica_removeRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_replica_removeRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& xtreemfs_replica_removeRequest::path() const {
  return *path_;
}
inline void xtreemfs_replica_removeRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* xtreemfs_replica_removeRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_removeRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string volume_name = 4;
inline bool xtreemfs_replica_removeRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_replica_removeRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_replica_removeRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_replica_removeRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& xtreemfs_replica_removeRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_replica_removeRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* xtreemfs_replica_removeRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_removeRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string osd_uuid = 2;
inline bool xtreemfs_replica_removeRequest::has_osd_uuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_replica_removeRequest::set_has_osd_uuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_replica_removeRequest::clear_has_osd_uuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_replica_removeRequest::clear_osd_uuid() {
  if (osd_uuid_ != &::google::protobuf::internal::kEmptyString) {
    osd_uuid_->clear();
  }
  clear_has_osd_uuid();
}
inline const ::std::string& xtreemfs_replica_removeRequest::osd_uuid() const {
  return *osd_uuid_;
}
inline void xtreemfs_replica_removeRequest::set_osd_uuid(const ::std::string& value) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_osd_uuid(const char* value) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_replica_removeRequest::set_osd_uuid(const char* value, size_t size) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeRequest::mutable_osd_uuid() {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  return osd_uuid_;
}
inline ::std::string* xtreemfs_replica_removeRequest::release_osd_uuid() {
  clear_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osd_uuid_;
    osd_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_removeRequest::set_allocated_osd_uuid(::std::string* osd_uuid) {
  if (osd_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete osd_uuid_;
  }
  if (osd_uuid) {
    set_has_osd_uuid();
    osd_uuid_ = osd_uuid;
  } else {
    clear_has_osd_uuid();
    osd_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_replica_removeResponse

// required string file_id = 1;
inline bool xtreemfs_replica_removeResponse::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_replica_removeResponse::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_replica_removeResponse::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_replica_removeResponse::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_replica_removeResponse::file_id() const {
  return *file_id_;
}
inline void xtreemfs_replica_removeResponse::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_removeResponse::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_replica_removeResponse::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_replica_removeResponse::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_replica_removeResponse::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_replica_removeResponse::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 expected_xlocset_version = 2;
inline bool xtreemfs_replica_removeResponse::has_expected_xlocset_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_replica_removeResponse::set_has_expected_xlocset_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_replica_removeResponse::clear_has_expected_xlocset_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_replica_removeResponse::clear_expected_xlocset_version() {
  expected_xlocset_version_ = 0;
  clear_has_expected_xlocset_version();
}
inline ::google::protobuf::int32 xtreemfs_replica_removeResponse::expected_xlocset_version() const {
  return expected_xlocset_version_;
}
inline void xtreemfs_replica_removeResponse::set_expected_xlocset_version(::google::protobuf::int32 value) {
  set_has_expected_xlocset_version();
  expected_xlocset_version_ = value;
}

// required .xtreemfs.pbrpc.XLocSet unlink_xloc = 3;
inline bool xtreemfs_replica_removeResponse::has_unlink_xloc() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_replica_removeResponse::set_has_unlink_xloc() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_replica_removeResponse::clear_has_unlink_xloc() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_replica_removeResponse::clear_unlink_xloc() {
  if (unlink_xloc_ != NULL) unlink_xloc_->::xtreemfs::pbrpc::XLocSet::Clear();
  clear_has_unlink_xloc();
}
inline const ::xtreemfs::pbrpc::XLocSet& xtreemfs_replica_removeResponse::unlink_xloc() const {
  return unlink_xloc_ != NULL ? *unlink_xloc_ : *default_instance_->unlink_xloc_;
}
inline ::xtreemfs::pbrpc::XLocSet* xtreemfs_replica_removeResponse::mutable_unlink_xloc() {
  set_has_unlink_xloc();
  if (unlink_xloc_ == NULL) unlink_xloc_ = new ::xtreemfs::pbrpc::XLocSet;
  return unlink_xloc_;
}
inline ::xtreemfs::pbrpc::XLocSet* xtreemfs_replica_removeResponse::release_unlink_xloc() {
  clear_has_unlink_xloc();
  ::xtreemfs::pbrpc::XLocSet* temp = unlink_xloc_;
  unlink_xloc_ = NULL;
  return temp;
}
inline void xtreemfs_replica_removeResponse::set_allocated_unlink_xloc(::xtreemfs::pbrpc::XLocSet* unlink_xloc) {
  delete unlink_xloc_;
  unlink_xloc_ = unlink_xloc;
  if (unlink_xloc) {
    set_has_unlink_xloc();
  } else {
    clear_has_unlink_xloc();
  }
}

// required .xtreemfs.pbrpc.XCap unlink_xcap = 4;
inline bool xtreemfs_replica_removeResponse::has_unlink_xcap() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_replica_removeResponse::set_has_unlink_xcap() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_replica_removeResponse::clear_has_unlink_xcap() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_replica_removeResponse::clear_unlink_xcap() {
  if (unlink_xcap_ != NULL) unlink_xcap_->::xtreemfs::pbrpc::XCap::Clear();
  clear_has_unlink_xcap();
}
inline const ::xtreemfs::pbrpc::XCap& xtreemfs_replica_removeResponse::unlink_xcap() const {
  return unlink_xcap_ != NULL ? *unlink_xcap_ : *default_instance_->unlink_xcap_;
}
inline ::xtreemfs::pbrpc::XCap* xtreemfs_replica_removeResponse::mutable_unlink_xcap() {
  set_has_unlink_xcap();
  if (unlink_xcap_ == NULL) unlink_xcap_ = new ::xtreemfs::pbrpc::XCap;
  return unlink_xcap_;
}
inline ::xtreemfs::pbrpc::XCap* xtreemfs_replica_removeResponse::release_unlink_xcap() {
  clear_has_unlink_xcap();
  ::xtreemfs::pbrpc::XCap* temp = unlink_xcap_;
  unlink_xcap_ = NULL;
  return temp;
}
inline void xtreemfs_replica_removeResponse::set_allocated_unlink_xcap(::xtreemfs::pbrpc::XCap* unlink_xcap) {
  delete unlink_xcap_;
  unlink_xcap_ = unlink_xcap;
  if (unlink_xcap) {
    set_has_unlink_xcap();
  } else {
    clear_has_unlink_xcap();
  }
}

// -------------------------------------------------------------------

// xtreemfs_restore_fileRequest

// required string file_path = 1;
inline bool xtreemfs_restore_fileRequest::has_file_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_restore_fileRequest::set_has_file_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_restore_fileRequest::clear_has_file_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_restore_fileRequest::clear_file_path() {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    file_path_->clear();
  }
  clear_has_file_path();
}
inline const ::std::string& xtreemfs_restore_fileRequest::file_path() const {
  return *file_path_;
}
inline void xtreemfs_restore_fileRequest::set_file_path(const ::std::string& value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_file_path(const char* value) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_file_path(const char* value, size_t size) {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  file_path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_restore_fileRequest::mutable_file_path() {
  set_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    file_path_ = new ::std::string;
  }
  return file_path_;
}
inline ::std::string* xtreemfs_restore_fileRequest::release_file_path() {
  clear_has_file_path();
  if (file_path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_path_;
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_restore_fileRequest::set_allocated_file_path(::std::string* file_path) {
  if (file_path_ != &::google::protobuf::internal::kEmptyString) {
    delete file_path_;
  }
  if (file_path) {
    set_has_file_path();
    file_path_ = file_path;
  } else {
    clear_has_file_path();
    file_path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string file_id = 2;
inline bool xtreemfs_restore_fileRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_restore_fileRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_restore_fileRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_restore_fileRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_restore_fileRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_restore_fileRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_restore_fileRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_restore_fileRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_restore_fileRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed64 file_size = 3;
inline bool xtreemfs_restore_fileRequest::has_file_size() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_restore_fileRequest::set_has_file_size() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_restore_fileRequest::clear_has_file_size() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_restore_fileRequest::clear_file_size() {
  file_size_ = GOOGLE_ULONGLONG(0);
  clear_has_file_size();
}
inline ::google::protobuf::uint64 xtreemfs_restore_fileRequest::file_size() const {
  return file_size_;
}
inline void xtreemfs_restore_fileRequest::set_file_size(::google::protobuf::uint64 value) {
  set_has_file_size();
  file_size_ = value;
}

// required string osd_uuid = 4;
inline bool xtreemfs_restore_fileRequest::has_osd_uuid() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_restore_fileRequest::set_has_osd_uuid() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_restore_fileRequest::clear_has_osd_uuid() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_restore_fileRequest::clear_osd_uuid() {
  if (osd_uuid_ != &::google::protobuf::internal::kEmptyString) {
    osd_uuid_->clear();
  }
  clear_has_osd_uuid();
}
inline const ::std::string& xtreemfs_restore_fileRequest::osd_uuid() const {
  return *osd_uuid_;
}
inline void xtreemfs_restore_fileRequest::set_osd_uuid(const ::std::string& value) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_osd_uuid(const char* value) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(value);
}
inline void xtreemfs_restore_fileRequest::set_osd_uuid(const char* value, size_t size) {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  osd_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_restore_fileRequest::mutable_osd_uuid() {
  set_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    osd_uuid_ = new ::std::string;
  }
  return osd_uuid_;
}
inline ::std::string* xtreemfs_restore_fileRequest::release_osd_uuid() {
  clear_has_osd_uuid();
  if (osd_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = osd_uuid_;
    osd_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_restore_fileRequest::set_allocated_osd_uuid(::std::string* osd_uuid) {
  if (osd_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete osd_uuid_;
  }
  if (osd_uuid) {
    set_has_osd_uuid();
    osd_uuid_ = osd_uuid;
  } else {
    clear_has_osd_uuid();
    osd_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required fixed32 stripe_size = 5;
inline bool xtreemfs_restore_fileRequest::has_stripe_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void xtreemfs_restore_fileRequest::set_has_stripe_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void xtreemfs_restore_fileRequest::clear_has_stripe_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void xtreemfs_restore_fileRequest::clear_stripe_size() {
  stripe_size_ = 0u;
  clear_has_stripe_size();
}
inline ::google::protobuf::uint32 xtreemfs_restore_fileRequest::stripe_size() const {
  return stripe_size_;
}
inline void xtreemfs_restore_fileRequest::set_stripe_size(::google::protobuf::uint32 value) {
  set_has_stripe_size();
  stripe_size_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_rmvolRequest

// required string volume_name = 1;
inline bool xtreemfs_rmvolRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_rmvolRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_rmvolRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_rmvolRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& xtreemfs_rmvolRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_rmvolRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_rmvolRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_rmvolRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_rmvolRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* xtreemfs_rmvolRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_rmvolRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_update_file_sizeRequest

// required .xtreemfs.pbrpc.XCap xcap = 1;
inline bool xtreemfs_update_file_sizeRequest::has_xcap() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_update_file_sizeRequest::set_has_xcap() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_update_file_sizeRequest::clear_has_xcap() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_update_file_sizeRequest::clear_xcap() {
  if (xcap_ != NULL) xcap_->::xtreemfs::pbrpc::XCap::Clear();
  clear_has_xcap();
}
inline const ::xtreemfs::pbrpc::XCap& xtreemfs_update_file_sizeRequest::xcap() const {
  return xcap_ != NULL ? *xcap_ : *default_instance_->xcap_;
}
inline ::xtreemfs::pbrpc::XCap* xtreemfs_update_file_sizeRequest::mutable_xcap() {
  set_has_xcap();
  if (xcap_ == NULL) xcap_ = new ::xtreemfs::pbrpc::XCap;
  return xcap_;
}
inline ::xtreemfs::pbrpc::XCap* xtreemfs_update_file_sizeRequest::release_xcap() {
  clear_has_xcap();
  ::xtreemfs::pbrpc::XCap* temp = xcap_;
  xcap_ = NULL;
  return temp;
}
inline void xtreemfs_update_file_sizeRequest::set_allocated_xcap(::xtreemfs::pbrpc::XCap* xcap) {
  delete xcap_;
  xcap_ = xcap;
  if (xcap) {
    set_has_xcap();
  } else {
    clear_has_xcap();
  }
}

// required .xtreemfs.pbrpc.OSDWriteResponse osd_write_response = 2;
inline bool xtreemfs_update_file_sizeRequest::has_osd_write_response() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_update_file_sizeRequest::set_has_osd_write_response() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_update_file_sizeRequest::clear_has_osd_write_response() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_update_file_sizeRequest::clear_osd_write_response() {
  if (osd_write_response_ != NULL) osd_write_response_->::xtreemfs::pbrpc::OSDWriteResponse::Clear();
  clear_has_osd_write_response();
}
inline const ::xtreemfs::pbrpc::OSDWriteResponse& xtreemfs_update_file_sizeRequest::osd_write_response() const {
  return osd_write_response_ != NULL ? *osd_write_response_ : *default_instance_->osd_write_response_;
}
inline ::xtreemfs::pbrpc::OSDWriteResponse* xtreemfs_update_file_sizeRequest::mutable_osd_write_response() {
  set_has_osd_write_response();
  if (osd_write_response_ == NULL) osd_write_response_ = new ::xtreemfs::pbrpc::OSDWriteResponse;
  return osd_write_response_;
}
inline ::xtreemfs::pbrpc::OSDWriteResponse* xtreemfs_update_file_sizeRequest::release_osd_write_response() {
  clear_has_osd_write_response();
  ::xtreemfs::pbrpc::OSDWriteResponse* temp = osd_write_response_;
  osd_write_response_ = NULL;
  return temp;
}
inline void xtreemfs_update_file_sizeRequest::set_allocated_osd_write_response(::xtreemfs::pbrpc::OSDWriteResponse* osd_write_response) {
  delete osd_write_response_;
  osd_write_response_ = osd_write_response;
  if (osd_write_response) {
    set_has_osd_write_response();
  } else {
    clear_has_osd_write_response();
  }
}

// optional bool close_file = 3;
inline bool xtreemfs_update_file_sizeRequest::has_close_file() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_update_file_sizeRequest::set_has_close_file() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_update_file_sizeRequest::clear_has_close_file() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_update_file_sizeRequest::clear_close_file() {
  close_file_ = false;
  clear_has_close_file();
}
inline bool xtreemfs_update_file_sizeRequest::close_file() const {
  return close_file_;
}
inline void xtreemfs_update_file_sizeRequest::set_close_file(bool value) {
  set_has_close_file();
  close_file_ = value;
}

// optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 4;
inline bool xtreemfs_update_file_sizeRequest::has_coordinates() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void xtreemfs_update_file_sizeRequest::set_has_coordinates() {
  _has_bits_[0] |= 0x00000008u;
}
inline void xtreemfs_update_file_sizeRequest::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void xtreemfs_update_file_sizeRequest::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::xtreemfs::pbrpc::VivaldiCoordinates::Clear();
  clear_has_coordinates();
}
inline const ::xtreemfs::pbrpc::VivaldiCoordinates& xtreemfs_update_file_sizeRequest::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_update_file_sizeRequest::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == NULL) coordinates_ = new ::xtreemfs::pbrpc::VivaldiCoordinates;
  return coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_update_file_sizeRequest::release_coordinates() {
  clear_has_coordinates();
  ::xtreemfs::pbrpc::VivaldiCoordinates* temp = coordinates_;
  coordinates_ = NULL;
  return temp;
}
inline void xtreemfs_update_file_sizeRequest::set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates) {
  delete coordinates_;
  coordinates_ = coordinates;
  if (coordinates) {
    set_has_coordinates();
  } else {
    clear_has_coordinates();
  }
}

// -------------------------------------------------------------------

// xtreemfs_set_replica_update_policyRequest

// required string file_id = 1;
inline bool xtreemfs_set_replica_update_policyRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_set_replica_update_policyRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_set_replica_update_policyRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_set_replica_update_policyRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_set_replica_update_policyRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_set_replica_update_policyRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_set_replica_update_policyRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_set_replica_update_policyRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_set_replica_update_policyRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_set_replica_update_policyRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_set_replica_update_policyRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string update_policy = 2;
inline bool xtreemfs_set_replica_update_policyRequest::has_update_policy() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_set_replica_update_policyRequest::set_has_update_policy() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_set_replica_update_policyRequest::clear_has_update_policy() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_set_replica_update_policyRequest::clear_update_policy() {
  if (update_policy_ != &::google::protobuf::internal::kEmptyString) {
    update_policy_->clear();
  }
  clear_has_update_policy();
}
inline const ::std::string& xtreemfs_set_replica_update_policyRequest::update_policy() const {
  return *update_policy_;
}
inline void xtreemfs_set_replica_update_policyRequest::set_update_policy(const ::std::string& value) {
  set_has_update_policy();
  if (update_policy_ == &::google::protobuf::internal::kEmptyString) {
    update_policy_ = new ::std::string;
  }
  update_policy_->assign(value);
}
inline void xtreemfs_set_replica_update_policyRequest::set_update_policy(const char* value) {
  set_has_update_policy();
  if (update_policy_ == &::google::protobuf::internal::kEmptyString) {
    update_policy_ = new ::std::string;
  }
  update_policy_->assign(value);
}
inline void xtreemfs_set_replica_update_policyRequest::set_update_policy(const char* value, size_t size) {
  set_has_update_policy();
  if (update_policy_ == &::google::protobuf::internal::kEmptyString) {
    update_policy_ = new ::std::string;
  }
  update_policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_set_replica_update_policyRequest::mutable_update_policy() {
  set_has_update_policy();
  if (update_policy_ == &::google::protobuf::internal::kEmptyString) {
    update_policy_ = new ::std::string;
  }
  return update_policy_;
}
inline ::std::string* xtreemfs_set_replica_update_policyRequest::release_update_policy() {
  clear_has_update_policy();
  if (update_policy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = update_policy_;
    update_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_set_replica_update_policyRequest::set_allocated_update_policy(::std::string* update_policy) {
  if (update_policy_ != &::google::protobuf::internal::kEmptyString) {
    delete update_policy_;
  }
  if (update_policy) {
    set_has_update_policy();
    update_policy_ = update_policy;
  } else {
    clear_has_update_policy();
    update_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_set_replica_update_policyResponse

// required string old_update_policy = 1;
inline bool xtreemfs_set_replica_update_policyResponse::has_old_update_policy() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_set_replica_update_policyResponse::set_has_old_update_policy() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_set_replica_update_policyResponse::clear_has_old_update_policy() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_set_replica_update_policyResponse::clear_old_update_policy() {
  if (old_update_policy_ != &::google::protobuf::internal::kEmptyString) {
    old_update_policy_->clear();
  }
  clear_has_old_update_policy();
}
inline const ::std::string& xtreemfs_set_replica_update_policyResponse::old_update_policy() const {
  return *old_update_policy_;
}
inline void xtreemfs_set_replica_update_policyResponse::set_old_update_policy(const ::std::string& value) {
  set_has_old_update_policy();
  if (old_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    old_update_policy_ = new ::std::string;
  }
  old_update_policy_->assign(value);
}
inline void xtreemfs_set_replica_update_policyResponse::set_old_update_policy(const char* value) {
  set_has_old_update_policy();
  if (old_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    old_update_policy_ = new ::std::string;
  }
  old_update_policy_->assign(value);
}
inline void xtreemfs_set_replica_update_policyResponse::set_old_update_policy(const char* value, size_t size) {
  set_has_old_update_policy();
  if (old_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    old_update_policy_ = new ::std::string;
  }
  old_update_policy_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_set_replica_update_policyResponse::mutable_old_update_policy() {
  set_has_old_update_policy();
  if (old_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    old_update_policy_ = new ::std::string;
  }
  return old_update_policy_;
}
inline ::std::string* xtreemfs_set_replica_update_policyResponse::release_old_update_policy() {
  clear_has_old_update_policy();
  if (old_update_policy_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = old_update_policy_;
    old_update_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_set_replica_update_policyResponse::set_allocated_old_update_policy(::std::string* old_update_policy) {
  if (old_update_policy_ != &::google::protobuf::internal::kEmptyString) {
    delete old_update_policy_;
  }
  if (old_update_policy) {
    set_has_old_update_policy();
    old_update_policy_ = old_update_policy;
  } else {
    clear_has_old_update_policy();
    old_update_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_set_read_only_xattrRequest

// required string file_id = 1;
inline bool xtreemfs_set_read_only_xattrRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_set_read_only_xattrRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_set_read_only_xattrRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_set_read_only_xattrRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_set_read_only_xattrRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_set_read_only_xattrRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_set_read_only_xattrRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_set_read_only_xattrRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_set_read_only_xattrRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_set_read_only_xattrRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_set_read_only_xattrRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required bool value = 2;
inline bool xtreemfs_set_read_only_xattrRequest::has_value() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_set_read_only_xattrRequest::set_has_value() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_set_read_only_xattrRequest::clear_has_value() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_set_read_only_xattrRequest::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool xtreemfs_set_read_only_xattrRequest::value() const {
  return value_;
}
inline void xtreemfs_set_read_only_xattrRequest::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_set_read_only_xattrResponse

// required bool was_set = 1;
inline bool xtreemfs_set_read_only_xattrResponse::has_was_set() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_set_read_only_xattrResponse::set_has_was_set() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_set_read_only_xattrResponse::clear_has_was_set() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_set_read_only_xattrResponse::clear_was_set() {
  was_set_ = false;
  clear_has_was_set();
}
inline bool xtreemfs_set_read_only_xattrResponse::was_set() const {
  return was_set_;
}
inline void xtreemfs_set_read_only_xattrResponse::set_was_set(bool value) {
  set_has_was_set();
  was_set_ = value;
}

// -------------------------------------------------------------------

// xtreemfs_get_file_credentialsRequest

// required string file_id = 1;
inline bool xtreemfs_get_file_credentialsRequest::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_get_file_credentialsRequest::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_get_file_credentialsRequest::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_get_file_credentialsRequest::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_get_file_credentialsRequest::file_id() const {
  return *file_id_;
}
inline void xtreemfs_get_file_credentialsRequest::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_file_credentialsRequest::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_get_file_credentialsRequest::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_get_file_credentialsRequest::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_get_file_credentialsRequest::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_get_file_credentialsRequest::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// xtreemfs_reselect_osdsRequest

// required string path = 1;
inline bool xtreemfs_reselect_osdsRequest::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_reselect_osdsRequest::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_reselect_osdsRequest::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_reselect_osdsRequest::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& xtreemfs_reselect_osdsRequest::path() const {
  return *path_;
}
inline void xtreemfs_reselect_osdsRequest::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_reselect_osdsRequest::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void xtreemfs_reselect_osdsRequest::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_reselect_osdsRequest::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* xtreemfs_reselect_osdsRequest::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_reselect_osdsRequest::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required string volume_name = 2;
inline bool xtreemfs_reselect_osdsRequest::has_volume_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_reselect_osdsRequest::set_has_volume_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_reselect_osdsRequest::clear_has_volume_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_reselect_osdsRequest::clear_volume_name() {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    volume_name_->clear();
  }
  clear_has_volume_name();
}
inline const ::std::string& xtreemfs_reselect_osdsRequest::volume_name() const {
  return *volume_name_;
}
inline void xtreemfs_reselect_osdsRequest::set_volume_name(const ::std::string& value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_reselect_osdsRequest::set_volume_name(const char* value) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(value);
}
inline void xtreemfs_reselect_osdsRequest::set_volume_name(const char* value, size_t size) {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  volume_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_reselect_osdsRequest::mutable_volume_name() {
  set_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    volume_name_ = new ::std::string;
  }
  return volume_name_;
}
inline ::std::string* xtreemfs_reselect_osdsRequest::release_volume_name() {
  clear_has_volume_name();
  if (volume_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = volume_name_;
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_reselect_osdsRequest::set_allocated_volume_name(::std::string* volume_name) {
  if (volume_name_ != &::google::protobuf::internal::kEmptyString) {
    delete volume_name_;
  }
  if (volume_name) {
    set_has_volume_name();
    volume_name_ = volume_name;
  } else {
    clear_has_volume_name();
    volume_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .xtreemfs.pbrpc.VivaldiCoordinates coordinates = 3;
inline bool xtreemfs_reselect_osdsRequest::has_coordinates() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void xtreemfs_reselect_osdsRequest::set_has_coordinates() {
  _has_bits_[0] |= 0x00000004u;
}
inline void xtreemfs_reselect_osdsRequest::clear_has_coordinates() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void xtreemfs_reselect_osdsRequest::clear_coordinates() {
  if (coordinates_ != NULL) coordinates_->::xtreemfs::pbrpc::VivaldiCoordinates::Clear();
  clear_has_coordinates();
}
inline const ::xtreemfs::pbrpc::VivaldiCoordinates& xtreemfs_reselect_osdsRequest::coordinates() const {
  return coordinates_ != NULL ? *coordinates_ : *default_instance_->coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_reselect_osdsRequest::mutable_coordinates() {
  set_has_coordinates();
  if (coordinates_ == NULL) coordinates_ = new ::xtreemfs::pbrpc::VivaldiCoordinates;
  return coordinates_;
}
inline ::xtreemfs::pbrpc::VivaldiCoordinates* xtreemfs_reselect_osdsRequest::release_coordinates() {
  clear_has_coordinates();
  ::xtreemfs::pbrpc::VivaldiCoordinates* temp = coordinates_;
  coordinates_ = NULL;
  return temp;
}
inline void xtreemfs_reselect_osdsRequest::set_allocated_coordinates(::xtreemfs::pbrpc::VivaldiCoordinates* coordinates) {
  delete coordinates_;
  coordinates_ = coordinates;
  if (coordinates) {
    set_has_coordinates();
  } else {
    clear_has_coordinates();
  }
}

// -------------------------------------------------------------------

// xtreemfs_reselect_osdsResponse

// required string file_id = 1;
inline bool xtreemfs_reselect_osdsResponse::has_file_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void xtreemfs_reselect_osdsResponse::set_has_file_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void xtreemfs_reselect_osdsResponse::clear_has_file_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void xtreemfs_reselect_osdsResponse::clear_file_id() {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    file_id_->clear();
  }
  clear_has_file_id();
}
inline const ::std::string& xtreemfs_reselect_osdsResponse::file_id() const {
  return *file_id_;
}
inline void xtreemfs_reselect_osdsResponse::set_file_id(const ::std::string& value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_reselect_osdsResponse::set_file_id(const char* value) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(value);
}
inline void xtreemfs_reselect_osdsResponse::set_file_id(const char* value, size_t size) {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  file_id_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* xtreemfs_reselect_osdsResponse::mutable_file_id() {
  set_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    file_id_ = new ::std::string;
  }
  return file_id_;
}
inline ::std::string* xtreemfs_reselect_osdsResponse::release_file_id() {
  clear_has_file_id();
  if (file_id_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = file_id_;
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void xtreemfs_reselect_osdsResponse::set_allocated_file_id(::std::string* file_id) {
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (file_id) {
    set_has_file_id();
    file_id_ = file_id;
  } else {
    clear_has_file_id();
    file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// required int32 expected_xlocset_version = 2;
inline bool xtreemfs_reselect_osdsResponse::has_expected_xlocset_version() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void xtreemfs_reselect_osdsResponse::set_has_expected_xlocset_version() {
  _has_bits_[0] |= 0x00000002u;
}
inline void xtreemfs_reselect_osdsResponse::clear_has_expected_xlocset_version() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void xtreemfs_reselect_osdsResponse::clear_expected_xlocset_version() {
  expected_xlocset_version_ = 0;
  clear_has_expected_xlocset_version();
}
inline ::google::protobuf::int32 xtreemfs_reselect_osdsResponse::expected_xlocset_version() const {
  return expected_xlocset_version_;
}
inline void xtreemfs_reselect_osdsResponse::set_expected_xlocset_version(::google::protobuf::int32 value) {
  set_has_expected_xlocset_version();
  expected_xlocset_version_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE>() {
  return ::xtreemfs::pbrpc::xtreemfs_check_file_existsResponse_FILE_STATE_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::Setattrs>() {
  return ::xtreemfs::pbrpc::Setattrs_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::XATTR_FLAGS>() {
  return ::xtreemfs::pbrpc::XATTR_FLAGS_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::ACCESS_FLAGS>() {
  return ::xtreemfs::pbrpc::ACCESS_FLAGS_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_xtreemfs_2fMRC_2eproto__INCLUDED
