// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: xtreemfs/GlobalTypes.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "xtreemfs/GlobalTypes.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

namespace {

const ::google::protobuf::Descriptor* NewFileSize_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NewFileSize_reflection_ = NULL;
const ::google::protobuf::Descriptor* StripingPolicy_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  StripingPolicy_reflection_ = NULL;
const ::google::protobuf::Descriptor* Replica_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Replica_reflection_ = NULL;
const ::google::protobuf::Descriptor* Replicas_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  Replicas_reflection_ = NULL;
const ::google::protobuf::Descriptor* XCap_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  XCap_reflection_ = NULL;
const ::google::protobuf::Descriptor* XLocSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  XLocSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileCredentials_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileCredentials_reflection_ = NULL;
const ::google::protobuf::Descriptor* FileCredentialsSet_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  FileCredentialsSet_reflection_ = NULL;
const ::google::protobuf::Descriptor* VivaldiCoordinates_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VivaldiCoordinates_reflection_ = NULL;
const ::google::protobuf::Descriptor* OSDWriteResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  OSDWriteResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* KeyValuePair_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  KeyValuePair_reflection_ = NULL;
const ::google::protobuf::EnumDescriptor* AccessControlPolicyType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* OSDSelectionPolicyType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* ReplicaSelectionPolicyType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* SnapConfig_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* StripingPolicyType_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* PORTS_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* CONSTANTS_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* SYSTEM_V_FCNTL_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* REPL_FLAG_descriptor_ = NULL;
const ::google::protobuf::EnumDescriptor* SERVICES_descriptor_ = NULL;

}  // namespace


void protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto() {
  protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "xtreemfs/GlobalTypes.proto");
  GOOGLE_CHECK(file != NULL);
  NewFileSize_descriptor_ = file->message_type(0);
  static const int NewFileSize_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewFileSize, size_in_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewFileSize, truncate_epoch_),
  };
  NewFileSize_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      NewFileSize_descriptor_,
      NewFileSize::default_instance_,
      NewFileSize_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewFileSize, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NewFileSize, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(NewFileSize));
  StripingPolicy_descriptor_ = file->message_type(1);
  static const int StripingPolicy_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StripingPolicy, type_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StripingPolicy, stripe_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StripingPolicy, width_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StripingPolicy, parity_width_),
  };
  StripingPolicy_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      StripingPolicy_descriptor_,
      StripingPolicy::default_instance_,
      StripingPolicy_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StripingPolicy, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(StripingPolicy, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(StripingPolicy));
  Replica_descriptor_ = file->message_type(2);
  static const int Replica_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Replica, osd_uuids_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Replica, replication_flags_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Replica, striping_policy_),
  };
  Replica_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Replica_descriptor_,
      Replica::default_instance_,
      Replica_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Replica, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Replica, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Replica));
  Replicas_descriptor_ = file->message_type(3);
  static const int Replicas_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Replicas, replicas_),
  };
  Replicas_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      Replicas_descriptor_,
      Replicas::default_instance_,
      Replicas_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Replicas, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(Replicas, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(Replicas));
  XCap_descriptor_ = file->message_type(4);
  static const int XCap_offsets_[10] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, access_mode_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, client_identity_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, expire_time_s_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, expire_timeout_s_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, file_id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, replicate_on_close_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, server_signature_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, truncate_epoch_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, snap_config_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, snap_timestamp_),
  };
  XCap_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      XCap_descriptor_,
      XCap::default_instance_,
      XCap_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XCap, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(XCap));
  XLocSet_descriptor_ = file->message_type(5);
  static const int XLocSet_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XLocSet, read_only_file_size_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XLocSet, replicas_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XLocSet, replica_update_policy_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XLocSet, version_),
  };
  XLocSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      XLocSet_descriptor_,
      XLocSet::default_instance_,
      XLocSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XLocSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(XLocSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(XLocSet));
  FileCredentials_descriptor_ = file->message_type(6);
  static const int FileCredentials_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCredentials, xcap_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCredentials, xlocs_),
  };
  FileCredentials_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileCredentials_descriptor_,
      FileCredentials::default_instance_,
      FileCredentials_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCredentials, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCredentials, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileCredentials));
  FileCredentialsSet_descriptor_ = file->message_type(7);
  static const int FileCredentialsSet_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCredentialsSet, file_credentials_),
  };
  FileCredentialsSet_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      FileCredentialsSet_descriptor_,
      FileCredentialsSet::default_instance_,
      FileCredentialsSet_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCredentialsSet, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(FileCredentialsSet, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(FileCredentialsSet));
  VivaldiCoordinates_descriptor_ = file->message_type(8);
  static const int VivaldiCoordinates_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VivaldiCoordinates, x_coordinate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VivaldiCoordinates, y_coordinate_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VivaldiCoordinates, local_error_),
  };
  VivaldiCoordinates_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      VivaldiCoordinates_descriptor_,
      VivaldiCoordinates::default_instance_,
      VivaldiCoordinates_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VivaldiCoordinates, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VivaldiCoordinates, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(VivaldiCoordinates));
  OSDWriteResponse_descriptor_ = file->message_type(9);
  static const int OSDWriteResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OSDWriteResponse, size_in_bytes_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OSDWriteResponse, truncate_epoch_),
  };
  OSDWriteResponse_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      OSDWriteResponse_descriptor_,
      OSDWriteResponse::default_instance_,
      OSDWriteResponse_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OSDWriteResponse, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(OSDWriteResponse, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(OSDWriteResponse));
  KeyValuePair_descriptor_ = file->message_type(10);
  static const int KeyValuePair_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValuePair, key_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValuePair, value_),
  };
  KeyValuePair_reflection_ =
    new ::google::protobuf::internal::GeneratedMessageReflection(
      KeyValuePair_descriptor_,
      KeyValuePair::default_instance_,
      KeyValuePair_offsets_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValuePair, _has_bits_[0]),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(KeyValuePair, _unknown_fields_),
      -1,
      ::google::protobuf::DescriptorPool::generated_pool(),
      ::google::protobuf::MessageFactory::generated_factory(),
      sizeof(KeyValuePair));
  AccessControlPolicyType_descriptor_ = file->enum_type(0);
  OSDSelectionPolicyType_descriptor_ = file->enum_type(1);
  ReplicaSelectionPolicyType_descriptor_ = file->enum_type(2);
  SnapConfig_descriptor_ = file->enum_type(3);
  StripingPolicyType_descriptor_ = file->enum_type(4);
  PORTS_descriptor_ = file->enum_type(5);
  CONSTANTS_descriptor_ = file->enum_type(6);
  SYSTEM_V_FCNTL_descriptor_ = file->enum_type(7);
  REPL_FLAG_descriptor_ = file->enum_type(8);
  SERVICES_descriptor_ = file->enum_type(9);
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
inline void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_xtreemfs_2fGlobalTypes_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    NewFileSize_descriptor_, &NewFileSize::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    StripingPolicy_descriptor_, &StripingPolicy::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Replica_descriptor_, &Replica::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    Replicas_descriptor_, &Replicas::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    XCap_descriptor_, &XCap::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    XLocSet_descriptor_, &XLocSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileCredentials_descriptor_, &FileCredentials::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    FileCredentialsSet_descriptor_, &FileCredentialsSet::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    VivaldiCoordinates_descriptor_, &VivaldiCoordinates::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    OSDWriteResponse_descriptor_, &OSDWriteResponse::default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
    KeyValuePair_descriptor_, &KeyValuePair::default_instance());
}

}  // namespace

void protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto() {
  delete NewFileSize::default_instance_;
  delete NewFileSize_reflection_;
  delete StripingPolicy::default_instance_;
  delete StripingPolicy_reflection_;
  delete Replica::default_instance_;
  delete Replica_reflection_;
  delete Replicas::default_instance_;
  delete Replicas_reflection_;
  delete XCap::default_instance_;
  delete XCap_reflection_;
  delete XLocSet::default_instance_;
  delete XLocSet_reflection_;
  delete FileCredentials::default_instance_;
  delete FileCredentials_reflection_;
  delete FileCredentialsSet::default_instance_;
  delete FileCredentialsSet_reflection_;
  delete VivaldiCoordinates::default_instance_;
  delete VivaldiCoordinates_reflection_;
  delete OSDWriteResponse::default_instance_;
  delete OSDWriteResponse_reflection_;
  delete KeyValuePair::default_instance_;
  delete KeyValuePair_reflection_;
}

void protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto() {
  static bool already_here = false;
  if (already_here) return;
  already_here = true;
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::xtreemfs::pbrpc::protobuf_AddDesc_include_2fPBRPC_2eproto();
  ::xtreemfs::pbrpc::protobuf_AddDesc_include_2fCommon_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\032xtreemfs/GlobalTypes.proto\022\016xtreemfs.p"
    "brpc\032\023include/PBRPC.proto\032\024include/Commo"
    "n.proto\"<\n\013NewFileSize\022\025\n\rsize_in_bytes\030"
    "\001 \002(\006\022\026\n\016truncate_epoch\030\002 \002(\007\"|\n\016Stripin"
    "gPolicy\0220\n\004type\030\001 \002(\0162\".xtreemfs.pbrpc.S"
    "tripingPolicyType\022\023\n\013stripe_size\030\002 \002(\007\022\r"
    "\n\005width\030\003 \002(\007\022\024\n\014parity_width\030\004 \001(\007\"p\n\007R"
    "eplica\022\021\n\tosd_uuids\030\001 \003(\t\022\031\n\021replication"
    "_flags\030\002 \002(\007\0227\n\017striping_policy\030\003 \002(\0132\036."
    "xtreemfs.pbrpc.StripingPolicy\"5\n\010Replica"
    "s\022)\n\010replicas\030\001 \003(\0132\027.xtreemfs.pbrpc.Rep"
    "lica\"\215\002\n\004XCap\022\023\n\013access_mode\030\001 \002(\007\022\027\n\017cl"
    "ient_identity\030\002 \002(\t\022\025\n\rexpire_time_s\030\003 \002"
    "(\006\022\030\n\020expire_timeout_s\030\004 \002(\007\022\017\n\007file_id\030"
    "\005 \002(\t\022\032\n\022replicate_on_close\030\006 \002(\010\022\030\n\020ser"
    "ver_signature\030\007 \002(\t\022\026\n\016truncate_epoch\030\010 "
    "\002(\007\022/\n\013snap_config\030\t \002(\0162\032.xtreemfs.pbrp"
    "c.SnapConfig\022\026\n\016snap_timestamp\030\n \002(\006\"\201\001\n"
    "\007XLocSet\022\033\n\023read_only_file_size\030\001 \002(\006\022)\n"
    "\010replicas\030\002 \003(\0132\027.xtreemfs.pbrpc.Replica"
    "\022\035\n\025replica_update_policy\030\003 \002(\t\022\017\n\007versi"
    "on\030\004 \002(\007\"]\n\017FileCredentials\022\"\n\004xcap\030\001 \002("
    "\0132\024.xtreemfs.pbrpc.XCap\022&\n\005xlocs\030\002 \002(\0132\027"
    ".xtreemfs.pbrpc.XLocSet\"O\n\022FileCredentia"
    "lsSet\0229\n\020file_credentials\030\001 \001(\0132\037.xtreem"
    "fs.pbrpc.FileCredentials\"U\n\022VivaldiCoord"
    "inates\022\024\n\014x_coordinate\030\001 \002(\001\022\024\n\014y_coordi"
    "nate\030\002 \002(\001\022\023\n\013local_error\030\003 \002(\001\"A\n\020OSDWr"
    "iteResponse\022\025\n\rsize_in_bytes\030\001 \001(\006\022\026\n\016tr"
    "uncate_epoch\030\002 \001(\007\"*\n\014KeyValuePair\022\013\n\003ke"
    "y\030\001 \002(\t\022\r\n\005value\030\002 \002(\t*|\n\027AccessControlP"
    "olicyType\022\036\n\032ACCESS_CONTROL_POLICY_NULL\020"
    "\001\022\037\n\033ACCESS_CONTROL_POLICY_POSIX\020\002\022 \n\034AC"
    "CESS_CONTROL_POLICY_VOLUME\020\003*\365\003\n\026OSDSele"
    "ctionPolicyType\022(\n#OSD_SELECTION_POLICY_"
    "FILTER_DEFAULT\020\350\007\022%\n OSD_SELECTION_POLIC"
    "Y_FILTER_FQDN\020\351\007\022%\n OSD_SELECTION_POLICY"
    "_FILTER_UUID\020\352\007\022%\n OSD_SELECTION_POLICY_"
    "GROUP_DCMAP\020\320\017\022$\n\037OSD_SELECTION_POLICY_G"
    "ROUP_FQDN\020\321\017\022$\n\037OSD_SELECTION_POLICY_SOR"
    "T_DCMAP\020\270\027\022#\n\036OSD_SELECTION_POLICY_SORT_"
    "FQDN\020\271\027\022%\n OSD_SELECTION_POLICY_SORT_RAN"
    "DOM\020\272\027\022&\n!OSD_SELECTION_POLICY_SORT_VIVA"
    "LDI\020\273\027\022/\n*OSD_SELECTION_POLICY_SORT_HOST"
    "_ROUND_ROBIN\020\274\027\022#\n\036OSD_SELECTION_POLICY_"
    "SORT_UUID\020\236\037\022&\n!OSD_SELECTION_POLICY_SOR"
    "T_REVERSE\020\237\037*A\n\032ReplicaSelectionPolicyTy"
    "pe\022#\n\037REPLICA_SELECTION_POLICY_SIMPLE\020\001*"
    "i\n\nSnapConfig\022\036\n\032SNAP_CONFIG_SNAPS_DISAB"
    "LED\020\000\022\036\n\032SNAP_CONFIG_ACCESS_CURRENT\020\001\022\033\n"
    "\027SNAP_CONFIG_ACCESS_SNAP\020\002*P\n\022StripingPo"
    "licyType\022\031\n\025STRIPING_POLICY_RAID0\020\000\022\037\n\033S"
    "TRIPING_POLICY_ERASURECODE\020\001*\270\001\n\005PORTS\022\033"
    "\n\025DIR_HTTP_PORT_DEFAULT\020\256\357\001\022\034\n\026DIR_PBRPC"
    "_PORT_DEFAULT\020\376\376\001\022\033\n\025MRC_HTTP_PORT_DEFAU"
    "LT\020\254\357\001\022\034\n\026MRC_PBRPC_PORT_DEFAULT\020\374\376\001\022\033\n\025"
    "OSD_HTTP_PORT_DEFAULT\020\260\357\001\022\034\n\026OSD_PBRPC_P"
    "ORT_DEFAULT\020\200\377\001*+\n\tCONSTANTS\022\036\n\032XCAP_REN"
    "EW_INTERVAL_IN_MIN\020\001*\202\003\n\016SYSTEM_V_FCNTL\022"
    "\035\n\031SYSTEM_V_FCNTL_H_O_RDONLY\020\000\022\035\n\031SYSTEM"
    "_V_FCNTL_H_O_WRONLY\020\001\022\033\n\027SYSTEM_V_FCNTL_"
    "H_O_RDWR\020\002\022\035\n\031SYSTEM_V_FCNTL_H_O_APPEND\020"
    "\010\022\035\n\030SYSTEM_V_FCNTL_H_O_CREAT\020\200\002\022\035\n\030SYST"
    "EM_V_FCNTL_H_O_TRUNC\020\200\004\022\034\n\027SYSTEM_V_FCNT"
    "L_H_O_EXCL\020\200\010\022\033\n\027SYSTEM_V_FCNTL_H_O_SYNC"
    "\020\020\022\036\n\030SYSTEM_V_FCNTL_H_S_IFREG\020\200\200\002\022\036\n\030SY"
    "STEM_V_FCNTL_H_S_IFDIR\020\200\200\001\022\036\n\030SYSTEM_V_F"
    "CNTL_H_S_IFLNK\020\200\300\002\022\035\n\030SYSTEM_V_FCNTL_H_S"
    "_IFIFO\020\200 *\330\001\n\tREPL_FLAG\022\032\n\026REPL_FLAG_FUL"
    "L_REPLICA\020\001\022\031\n\025REPL_FLAG_IS_COMPLETE\020\002\022\035"
    "\n\031REPL_FLAG_STRATEGY_RANDOM\020\004\022#\n\037REPL_FL"
    "AG_STRATEGY_RAREST_FIRST\020\010\022!\n\035REPL_FLAG_"
    "STRATEGY_SEQUENTIAL\020\020\022-\n)REPL_FLAG_STRAT"
    "EGY_SEQUENTIAL_PREFETCHING\020 *%\n\010SERVICES"
    "\022\007\n\003DIR\020\001\022\007\n\003MRC\020\002\022\007\n\003OSD\020\003B(\n&org.xtree"
    "mfs.pbrpc.generatedinterfaces", 3029);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "xtreemfs/GlobalTypes.proto", &protobuf_RegisterTypes);
  NewFileSize::default_instance_ = new NewFileSize();
  StripingPolicy::default_instance_ = new StripingPolicy();
  Replica::default_instance_ = new Replica();
  Replicas::default_instance_ = new Replicas();
  XCap::default_instance_ = new XCap();
  XLocSet::default_instance_ = new XLocSet();
  FileCredentials::default_instance_ = new FileCredentials();
  FileCredentialsSet::default_instance_ = new FileCredentialsSet();
  VivaldiCoordinates::default_instance_ = new VivaldiCoordinates();
  OSDWriteResponse::default_instance_ = new OSDWriteResponse();
  KeyValuePair::default_instance_ = new KeyValuePair();
  NewFileSize::default_instance_->InitAsDefaultInstance();
  StripingPolicy::default_instance_->InitAsDefaultInstance();
  Replica::default_instance_->InitAsDefaultInstance();
  Replicas::default_instance_->InitAsDefaultInstance();
  XCap::default_instance_->InitAsDefaultInstance();
  XLocSet::default_instance_->InitAsDefaultInstance();
  FileCredentials::default_instance_->InitAsDefaultInstance();
  FileCredentialsSet::default_instance_->InitAsDefaultInstance();
  VivaldiCoordinates::default_instance_->InitAsDefaultInstance();
  OSDWriteResponse::default_instance_->InitAsDefaultInstance();
  KeyValuePair::default_instance_->InitAsDefaultInstance();
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_xtreemfs_2fGlobalTypes_2eproto);
}

// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_xtreemfs_2fGlobalTypes_2eproto {
  StaticDescriptorInitializer_xtreemfs_2fGlobalTypes_2eproto() {
    protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  }
} static_descriptor_initializer_xtreemfs_2fGlobalTypes_2eproto_;
const ::google::protobuf::EnumDescriptor* AccessControlPolicyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AccessControlPolicyType_descriptor_;
}
bool AccessControlPolicyType_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* OSDSelectionPolicyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OSDSelectionPolicyType_descriptor_;
}
bool OSDSelectionPolicyType_IsValid(int value) {
  switch(value) {
    case 1000:
    case 1001:
    case 1002:
    case 2000:
    case 2001:
    case 3000:
    case 3001:
    case 3002:
    case 3003:
    case 3004:
    case 3998:
    case 3999:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* ReplicaSelectionPolicyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return ReplicaSelectionPolicyType_descriptor_;
}
bool ReplicaSelectionPolicyType_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SnapConfig_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SnapConfig_descriptor_;
}
bool SnapConfig_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* StripingPolicyType_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StripingPolicyType_descriptor_;
}
bool StripingPolicyType_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* PORTS_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return PORTS_descriptor_;
}
bool PORTS_IsValid(int value) {
  switch(value) {
    case 30636:
    case 30638:
    case 30640:
    case 32636:
    case 32638:
    case 32640:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* CONSTANTS_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return CONSTANTS_descriptor_;
}
bool CONSTANTS_IsValid(int value) {
  switch(value) {
    case 1:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SYSTEM_V_FCNTL_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SYSTEM_V_FCNTL_descriptor_;
}
bool SYSTEM_V_FCNTL_IsValid(int value) {
  switch(value) {
    case 0:
    case 1:
    case 2:
    case 8:
    case 16:
    case 256:
    case 512:
    case 1024:
    case 4096:
    case 16384:
    case 32768:
    case 40960:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* REPL_FLAG_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return REPL_FLAG_descriptor_;
}
bool REPL_FLAG_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 4:
    case 8:
    case 16:
    case 32:
      return true;
    default:
      return false;
  }
}

const ::google::protobuf::EnumDescriptor* SERVICES_descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SERVICES_descriptor_;
}
bool SERVICES_IsValid(int value) {
  switch(value) {
    case 1:
    case 2:
    case 3:
      return true;
    default:
      return false;
  }
}


// ===================================================================

#ifndef _MSC_VER
const int NewFileSize::kSizeInBytesFieldNumber;
const int NewFileSize::kTruncateEpochFieldNumber;
#endif  // !_MSC_VER

NewFileSize::NewFileSize()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void NewFileSize::InitAsDefaultInstance() {
}

NewFileSize::NewFileSize(const NewFileSize& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void NewFileSize::SharedCtor() {
  _cached_size_ = 0;
  size_in_bytes_ = GOOGLE_ULONGLONG(0);
  truncate_epoch_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

NewFileSize::~NewFileSize() {
  SharedDtor();
}

void NewFileSize::SharedDtor() {
  if (this != default_instance_) {
  }
}

void NewFileSize::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NewFileSize::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NewFileSize_descriptor_;
}

const NewFileSize& NewFileSize::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

NewFileSize* NewFileSize::default_instance_ = NULL;

NewFileSize* NewFileSize::New() const {
  return new NewFileSize;
}

void NewFileSize::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    size_in_bytes_ = GOOGLE_ULONGLONG(0);
    truncate_epoch_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool NewFileSize::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed64 size_in_bytes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &size_in_bytes_)));
          set_has_size_in_bytes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_truncate_epoch;
        break;
      }

      // required fixed32 truncate_epoch = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_truncate_epoch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &truncate_epoch_)));
          set_has_truncate_epoch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void NewFileSize::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required fixed64 size_in_bytes = 1;
  if (has_size_in_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->size_in_bytes(), output);
  }

  // required fixed32 truncate_epoch = 2;
  if (has_truncate_epoch()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->truncate_epoch(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* NewFileSize::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required fixed64 size_in_bytes = 1;
  if (has_size_in_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->size_in_bytes(), target);
  }

  // required fixed32 truncate_epoch = 2;
  if (has_truncate_epoch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(2, this->truncate_epoch(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int NewFileSize::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed64 size_in_bytes = 1;
    if (has_size_in_bytes()) {
      total_size += 1 + 8;
    }

    // required fixed32 truncate_epoch = 2;
    if (has_truncate_epoch()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NewFileSize::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const NewFileSize* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const NewFileSize*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void NewFileSize::MergeFrom(const NewFileSize& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size_in_bytes()) {
      set_size_in_bytes(from.size_in_bytes());
    }
    if (from.has_truncate_epoch()) {
      set_truncate_epoch(from.truncate_epoch());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void NewFileSize::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NewFileSize::CopyFrom(const NewFileSize& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NewFileSize::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void NewFileSize::Swap(NewFileSize* other) {
  if (other != this) {
    std::swap(size_in_bytes_, other->size_in_bytes_);
    std::swap(truncate_epoch_, other->truncate_epoch_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata NewFileSize::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NewFileSize_descriptor_;
  metadata.reflection = NewFileSize_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int StripingPolicy::kTypeFieldNumber;
const int StripingPolicy::kStripeSizeFieldNumber;
const int StripingPolicy::kWidthFieldNumber;
const int StripingPolicy::kParityWidthFieldNumber;
#endif  // !_MSC_VER

StripingPolicy::StripingPolicy()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void StripingPolicy::InitAsDefaultInstance() {
}

StripingPolicy::StripingPolicy(const StripingPolicy& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void StripingPolicy::SharedCtor() {
  _cached_size_ = 0;
  type_ = 0;
  stripe_size_ = 0u;
  width_ = 0u;
  parity_width_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

StripingPolicy::~StripingPolicy() {
  SharedDtor();
}

void StripingPolicy::SharedDtor() {
  if (this != default_instance_) {
  }
}

void StripingPolicy::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* StripingPolicy::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return StripingPolicy_descriptor_;
}

const StripingPolicy& StripingPolicy::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

StripingPolicy* StripingPolicy::default_instance_ = NULL;

StripingPolicy* StripingPolicy::New() const {
  return new StripingPolicy;
}

void StripingPolicy::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    type_ = 0;
    stripe_size_ = 0u;
    width_ = 0u;
    parity_width_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool StripingPolicy::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .xtreemfs.pbrpc.StripingPolicyType type = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::xtreemfs::pbrpc::StripingPolicyType_IsValid(value)) {
            set_type(static_cast< ::xtreemfs::pbrpc::StripingPolicyType >(value));
          } else {
            mutable_unknown_fields()->AddVarint(1, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_stripe_size;
        break;
      }

      // required fixed32 stripe_size = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_stripe_size:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &stripe_size_)));
          set_has_stripe_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(29)) goto parse_width;
        break;
      }

      // required fixed32 width = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &width_)));
          set_has_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_parity_width;
        break;
      }

      // optional fixed32 parity_width = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_parity_width:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &parity_width_)));
          set_has_parity_width();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void StripingPolicy::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .xtreemfs.pbrpc.StripingPolicyType type = 1;
  if (has_type()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      1, this->type(), output);
  }

  // required fixed32 stripe_size = 2;
  if (has_stripe_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->stripe_size(), output);
  }

  // required fixed32 width = 3;
  if (has_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(3, this->width(), output);
  }

  // optional fixed32 parity_width = 4;
  if (has_parity_width()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(4, this->parity_width(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* StripingPolicy::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .xtreemfs.pbrpc.StripingPolicyType type = 1;
  if (has_type()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      1, this->type(), target);
  }

  // required fixed32 stripe_size = 2;
  if (has_stripe_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(2, this->stripe_size(), target);
  }

  // required fixed32 width = 3;
  if (has_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(3, this->width(), target);
  }

  // optional fixed32 parity_width = 4;
  if (has_parity_width()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(4, this->parity_width(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int StripingPolicy::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .xtreemfs.pbrpc.StripingPolicyType type = 1;
    if (has_type()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->type());
    }

    // required fixed32 stripe_size = 2;
    if (has_stripe_size()) {
      total_size += 1 + 4;
    }

    // required fixed32 width = 3;
    if (has_width()) {
      total_size += 1 + 4;
    }

    // optional fixed32 parity_width = 4;
    if (has_parity_width()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void StripingPolicy::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const StripingPolicy* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const StripingPolicy*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void StripingPolicy::MergeFrom(const StripingPolicy& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_type()) {
      set_type(from.type());
    }
    if (from.has_stripe_size()) {
      set_stripe_size(from.stripe_size());
    }
    if (from.has_width()) {
      set_width(from.width());
    }
    if (from.has_parity_width()) {
      set_parity_width(from.parity_width());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void StripingPolicy::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void StripingPolicy::CopyFrom(const StripingPolicy& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StripingPolicy::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void StripingPolicy::Swap(StripingPolicy* other) {
  if (other != this) {
    std::swap(type_, other->type_);
    std::swap(stripe_size_, other->stripe_size_);
    std::swap(width_, other->width_);
    std::swap(parity_width_, other->parity_width_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata StripingPolicy::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = StripingPolicy_descriptor_;
  metadata.reflection = StripingPolicy_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Replica::kOsdUuidsFieldNumber;
const int Replica::kReplicationFlagsFieldNumber;
const int Replica::kStripingPolicyFieldNumber;
#endif  // !_MSC_VER

Replica::Replica()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Replica::InitAsDefaultInstance() {
  striping_policy_ = const_cast< ::xtreemfs::pbrpc::StripingPolicy*>(&::xtreemfs::pbrpc::StripingPolicy::default_instance());
}

Replica::Replica(const Replica& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Replica::SharedCtor() {
  _cached_size_ = 0;
  replication_flags_ = 0u;
  striping_policy_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Replica::~Replica() {
  SharedDtor();
}

void Replica::SharedDtor() {
  if (this != default_instance_) {
    delete striping_policy_;
  }
}

void Replica::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Replica::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Replica_descriptor_;
}

const Replica& Replica::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

Replica* Replica::default_instance_ = NULL;

Replica* Replica::New() const {
  return new Replica;
}

void Replica::Clear() {
  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    replication_flags_ = 0u;
    if (has_striping_policy()) {
      if (striping_policy_ != NULL) striping_policy_->::xtreemfs::pbrpc::StripingPolicy::Clear();
    }
  }
  osd_uuids_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Replica::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated string osd_uuids = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_osd_uuids:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->add_osd_uuids()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->osd_uuids(this->osd_uuids_size() - 1).data(),
            this->osd_uuids(this->osd_uuids_size() - 1).length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_osd_uuids;
        if (input->ExpectTag(21)) goto parse_replication_flags;
        break;
      }

      // required fixed32 replication_flags = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_replication_flags:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &replication_flags_)));
          set_has_replication_flags();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(26)) goto parse_striping_policy;
        break;
      }

      // required .xtreemfs.pbrpc.StripingPolicy striping_policy = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_striping_policy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_striping_policy()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Replica::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated string osd_uuids = 1;
  for (int i = 0; i < this->osd_uuids_size(); i++) {
  ::google::protobuf::internal::WireFormat::VerifyUTF8String(
    this->osd_uuids(i).data(), this->osd_uuids(i).length(),
    ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->osd_uuids(i), output);
  }

  // required fixed32 replication_flags = 2;
  if (has_replication_flags()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->replication_flags(), output);
  }

  // required .xtreemfs.pbrpc.StripingPolicy striping_policy = 3;
  if (has_striping_policy()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      3, this->striping_policy(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Replica::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated string osd_uuids = 1;
  for (int i = 0; i < this->osd_uuids_size(); i++) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->osd_uuids(i).data(), this->osd_uuids(i).length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target = ::google::protobuf::internal::WireFormatLite::
      WriteStringToArray(1, this->osd_uuids(i), target);
  }

  // required fixed32 replication_flags = 2;
  if (has_replication_flags()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(2, this->replication_flags(), target);
  }

  // required .xtreemfs.pbrpc.StripingPolicy striping_policy = 3;
  if (has_striping_policy()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        3, this->striping_policy(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Replica::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    // required fixed32 replication_flags = 2;
    if (has_replication_flags()) {
      total_size += 1 + 4;
    }

    // required .xtreemfs.pbrpc.StripingPolicy striping_policy = 3;
    if (has_striping_policy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->striping_policy());
    }

  }
  // repeated string osd_uuids = 1;
  total_size += 1 * this->osd_uuids_size();
  for (int i = 0; i < this->osd_uuids_size(); i++) {
    total_size += ::google::protobuf::internal::WireFormatLite::StringSize(
      this->osd_uuids(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Replica::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Replica* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Replica*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Replica::MergeFrom(const Replica& from) {
  GOOGLE_CHECK_NE(&from, this);
  osd_uuids_.MergeFrom(from.osd_uuids_);
  if (from._has_bits_[1 / 32] & (0xffu << (1 % 32))) {
    if (from.has_replication_flags()) {
      set_replication_flags(from.replication_flags());
    }
    if (from.has_striping_policy()) {
      mutable_striping_policy()->::xtreemfs::pbrpc::StripingPolicy::MergeFrom(from.striping_policy());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Replica::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Replica::CopyFrom(const Replica& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Replica::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000006) != 0x00000006) return false;

  if (has_striping_policy()) {
    if (!this->striping_policy().IsInitialized()) return false;
  }
  return true;
}

void Replica::Swap(Replica* other) {
  if (other != this) {
    osd_uuids_.Swap(&other->osd_uuids_);
    std::swap(replication_flags_, other->replication_flags_);
    std::swap(striping_policy_, other->striping_policy_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Replica::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Replica_descriptor_;
  metadata.reflection = Replica_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int Replicas::kReplicasFieldNumber;
#endif  // !_MSC_VER

Replicas::Replicas()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void Replicas::InitAsDefaultInstance() {
}

Replicas::Replicas(const Replicas& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void Replicas::SharedCtor() {
  _cached_size_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

Replicas::~Replicas() {
  SharedDtor();
}

void Replicas::SharedDtor() {
  if (this != default_instance_) {
  }
}

void Replicas::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* Replicas::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return Replicas_descriptor_;
}

const Replicas& Replicas::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

Replicas* Replicas::default_instance_ = NULL;

Replicas* Replicas::New() const {
  return new Replicas;
}

void Replicas::Clear() {
  replicas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool Replicas::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // repeated .xtreemfs.pbrpc.Replica replicas = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_replicas:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_replicas()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(10)) goto parse_replicas;
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void Replicas::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // repeated .xtreemfs.pbrpc.Replica replicas = 1;
  for (int i = 0; i < this->replicas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->replicas(i), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* Replicas::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // repeated .xtreemfs.pbrpc.Replica replicas = 1;
  for (int i = 0; i < this->replicas_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->replicas(i), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int Replicas::ByteSize() const {
  int total_size = 0;

  // repeated .xtreemfs.pbrpc.Replica replicas = 1;
  total_size += 1 * this->replicas_size();
  for (int i = 0; i < this->replicas_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->replicas(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void Replicas::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const Replicas* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const Replicas*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void Replicas::MergeFrom(const Replicas& from) {
  GOOGLE_CHECK_NE(&from, this);
  replicas_.MergeFrom(from.replicas_);
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void Replicas::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void Replicas::CopyFrom(const Replicas& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool Replicas::IsInitialized() const {

  for (int i = 0; i < replicas_size(); i++) {
    if (!this->replicas(i).IsInitialized()) return false;
  }
  return true;
}

void Replicas::Swap(Replicas* other) {
  if (other != this) {
    replicas_.Swap(&other->replicas_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata Replicas::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = Replicas_descriptor_;
  metadata.reflection = Replicas_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int XCap::kAccessModeFieldNumber;
const int XCap::kClientIdentityFieldNumber;
const int XCap::kExpireTimeSFieldNumber;
const int XCap::kExpireTimeoutSFieldNumber;
const int XCap::kFileIdFieldNumber;
const int XCap::kReplicateOnCloseFieldNumber;
const int XCap::kServerSignatureFieldNumber;
const int XCap::kTruncateEpochFieldNumber;
const int XCap::kSnapConfigFieldNumber;
const int XCap::kSnapTimestampFieldNumber;
#endif  // !_MSC_VER

XCap::XCap()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void XCap::InitAsDefaultInstance() {
}

XCap::XCap(const XCap& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void XCap::SharedCtor() {
  _cached_size_ = 0;
  access_mode_ = 0u;
  client_identity_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  expire_time_s_ = GOOGLE_ULONGLONG(0);
  expire_timeout_s_ = 0u;
  file_id_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  replicate_on_close_ = false;
  server_signature_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  truncate_epoch_ = 0u;
  snap_config_ = 0;
  snap_timestamp_ = GOOGLE_ULONGLONG(0);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XCap::~XCap() {
  SharedDtor();
}

void XCap::SharedDtor() {
  if (client_identity_ != &::google::protobuf::internal::kEmptyString) {
    delete client_identity_;
  }
  if (file_id_ != &::google::protobuf::internal::kEmptyString) {
    delete file_id_;
  }
  if (server_signature_ != &::google::protobuf::internal::kEmptyString) {
    delete server_signature_;
  }
  if (this != default_instance_) {
  }
}

void XCap::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* XCap::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return XCap_descriptor_;
}

const XCap& XCap::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

XCap* XCap::default_instance_ = NULL;

XCap* XCap::New() const {
  return new XCap;
}

void XCap::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    access_mode_ = 0u;
    if (has_client_identity()) {
      if (client_identity_ != &::google::protobuf::internal::kEmptyString) {
        client_identity_->clear();
      }
    }
    expire_time_s_ = GOOGLE_ULONGLONG(0);
    expire_timeout_s_ = 0u;
    if (has_file_id()) {
      if (file_id_ != &::google::protobuf::internal::kEmptyString) {
        file_id_->clear();
      }
    }
    replicate_on_close_ = false;
    if (has_server_signature()) {
      if (server_signature_ != &::google::protobuf::internal::kEmptyString) {
        server_signature_->clear();
      }
    }
    truncate_epoch_ = 0u;
  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    snap_config_ = 0;
    snap_timestamp_ = GOOGLE_ULONGLONG(0);
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool XCap::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed32 access_mode = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &access_mode_)));
          set_has_access_mode();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_client_identity;
        break;
      }

      // required string client_identity = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_client_identity:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_client_identity()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->client_identity().data(), this->client_identity().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_expire_time_s;
        break;
      }

      // required fixed64 expire_time_s = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_expire_time_s:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &expire_time_s_)));
          set_has_expire_time_s();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_expire_timeout_s;
        break;
      }

      // required fixed32 expire_timeout_s = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_expire_timeout_s:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &expire_timeout_s_)));
          set_has_expire_timeout_s();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(42)) goto parse_file_id;
        break;
      }

      // required string file_id = 5;
      case 5: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_file_id:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_file_id()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->file_id().data(), this->file_id().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(48)) goto parse_replicate_on_close;
        break;
      }

      // required bool replicate_on_close = 6;
      case 6: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_replicate_on_close:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   bool, ::google::protobuf::internal::WireFormatLite::TYPE_BOOL>(
                 input, &replicate_on_close_)));
          set_has_replicate_on_close();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(58)) goto parse_server_signature;
        break;
      }

      // required string server_signature = 7;
      case 7: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_server_signature:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_server_signature()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->server_signature().data(), this->server_signature().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(69)) goto parse_truncate_epoch;
        break;
      }

      // required fixed32 truncate_epoch = 8;
      case 8: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_truncate_epoch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &truncate_epoch_)));
          set_has_truncate_epoch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(72)) goto parse_snap_config;
        break;
      }

      // required .xtreemfs.pbrpc.SnapConfig snap_config = 9;
      case 9: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_VARINT) {
         parse_snap_config:
          int value;
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   int, ::google::protobuf::internal::WireFormatLite::TYPE_ENUM>(
                 input, &value)));
          if (::xtreemfs::pbrpc::SnapConfig_IsValid(value)) {
            set_snap_config(static_cast< ::xtreemfs::pbrpc::SnapConfig >(value));
          } else {
            mutable_unknown_fields()->AddVarint(9, value);
          }
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(81)) goto parse_snap_timestamp;
        break;
      }

      // required fixed64 snap_timestamp = 10;
      case 10: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_snap_timestamp:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &snap_timestamp_)));
          set_has_snap_timestamp();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void XCap::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required fixed32 access_mode = 1;
  if (has_access_mode()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(1, this->access_mode(), output);
  }

  // required string client_identity = 2;
  if (has_client_identity()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->client_identity().data(), this->client_identity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->client_identity(), output);
  }

  // required fixed64 expire_time_s = 3;
  if (has_expire_time_s()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(3, this->expire_time_s(), output);
  }

  // required fixed32 expire_timeout_s = 4;
  if (has_expire_timeout_s()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(4, this->expire_timeout_s(), output);
  }

  // required string file_id = 5;
  if (has_file_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->file_id().data(), this->file_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      5, this->file_id(), output);
  }

  // required bool replicate_on_close = 6;
  if (has_replicate_on_close()) {
    ::google::protobuf::internal::WireFormatLite::WriteBool(6, this->replicate_on_close(), output);
  }

  // required string server_signature = 7;
  if (has_server_signature()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->server_signature().data(), this->server_signature().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      7, this->server_signature(), output);
  }

  // required fixed32 truncate_epoch = 8;
  if (has_truncate_epoch()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(8, this->truncate_epoch(), output);
  }

  // required .xtreemfs.pbrpc.SnapConfig snap_config = 9;
  if (has_snap_config()) {
    ::google::protobuf::internal::WireFormatLite::WriteEnum(
      9, this->snap_config(), output);
  }

  // required fixed64 snap_timestamp = 10;
  if (has_snap_timestamp()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(10, this->snap_timestamp(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* XCap::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required fixed32 access_mode = 1;
  if (has_access_mode()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(1, this->access_mode(), target);
  }

  // required string client_identity = 2;
  if (has_client_identity()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->client_identity().data(), this->client_identity().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->client_identity(), target);
  }

  // required fixed64 expire_time_s = 3;
  if (has_expire_time_s()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(3, this->expire_time_s(), target);
  }

  // required fixed32 expire_timeout_s = 4;
  if (has_expire_timeout_s()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(4, this->expire_timeout_s(), target);
  }

  // required string file_id = 5;
  if (has_file_id()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->file_id().data(), this->file_id().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->file_id(), target);
  }

  // required bool replicate_on_close = 6;
  if (has_replicate_on_close()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteBoolToArray(6, this->replicate_on_close(), target);
  }

  // required string server_signature = 7;
  if (has_server_signature()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->server_signature().data(), this->server_signature().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        7, this->server_signature(), target);
  }

  // required fixed32 truncate_epoch = 8;
  if (has_truncate_epoch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(8, this->truncate_epoch(), target);
  }

  // required .xtreemfs.pbrpc.SnapConfig snap_config = 9;
  if (has_snap_config()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteEnumToArray(
      9, this->snap_config(), target);
  }

  // required fixed64 snap_timestamp = 10;
  if (has_snap_timestamp()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(10, this->snap_timestamp(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int XCap::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed32 access_mode = 1;
    if (has_access_mode()) {
      total_size += 1 + 4;
    }

    // required string client_identity = 2;
    if (has_client_identity()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->client_identity());
    }

    // required fixed64 expire_time_s = 3;
    if (has_expire_time_s()) {
      total_size += 1 + 8;
    }

    // required fixed32 expire_timeout_s = 4;
    if (has_expire_timeout_s()) {
      total_size += 1 + 4;
    }

    // required string file_id = 5;
    if (has_file_id()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->file_id());
    }

    // required bool replicate_on_close = 6;
    if (has_replicate_on_close()) {
      total_size += 1 + 1;
    }

    // required string server_signature = 7;
    if (has_server_signature()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->server_signature());
    }

    // required fixed32 truncate_epoch = 8;
    if (has_truncate_epoch()) {
      total_size += 1 + 4;
    }

  }
  if (_has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    // required .xtreemfs.pbrpc.SnapConfig snap_config = 9;
    if (has_snap_config()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::EnumSize(this->snap_config());
    }

    // required fixed64 snap_timestamp = 10;
    if (has_snap_timestamp()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XCap::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const XCap* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const XCap*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void XCap::MergeFrom(const XCap& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_access_mode()) {
      set_access_mode(from.access_mode());
    }
    if (from.has_client_identity()) {
      set_client_identity(from.client_identity());
    }
    if (from.has_expire_time_s()) {
      set_expire_time_s(from.expire_time_s());
    }
    if (from.has_expire_timeout_s()) {
      set_expire_timeout_s(from.expire_timeout_s());
    }
    if (from.has_file_id()) {
      set_file_id(from.file_id());
    }
    if (from.has_replicate_on_close()) {
      set_replicate_on_close(from.replicate_on_close());
    }
    if (from.has_server_signature()) {
      set_server_signature(from.server_signature());
    }
    if (from.has_truncate_epoch()) {
      set_truncate_epoch(from.truncate_epoch());
    }
  }
  if (from._has_bits_[8 / 32] & (0xffu << (8 % 32))) {
    if (from.has_snap_config()) {
      set_snap_config(from.snap_config());
    }
    if (from.has_snap_timestamp()) {
      set_snap_timestamp(from.snap_timestamp());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void XCap::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void XCap::CopyFrom(const XCap& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XCap::IsInitialized() const {
  if ((_has_bits_[0] & 0x000003ff) != 0x000003ff) return false;

  return true;
}

void XCap::Swap(XCap* other) {
  if (other != this) {
    std::swap(access_mode_, other->access_mode_);
    std::swap(client_identity_, other->client_identity_);
    std::swap(expire_time_s_, other->expire_time_s_);
    std::swap(expire_timeout_s_, other->expire_timeout_s_);
    std::swap(file_id_, other->file_id_);
    std::swap(replicate_on_close_, other->replicate_on_close_);
    std::swap(server_signature_, other->server_signature_);
    std::swap(truncate_epoch_, other->truncate_epoch_);
    std::swap(snap_config_, other->snap_config_);
    std::swap(snap_timestamp_, other->snap_timestamp_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata XCap::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = XCap_descriptor_;
  metadata.reflection = XCap_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int XLocSet::kReadOnlyFileSizeFieldNumber;
const int XLocSet::kReplicasFieldNumber;
const int XLocSet::kReplicaUpdatePolicyFieldNumber;
const int XLocSet::kVersionFieldNumber;
#endif  // !_MSC_VER

XLocSet::XLocSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void XLocSet::InitAsDefaultInstance() {
}

XLocSet::XLocSet(const XLocSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void XLocSet::SharedCtor() {
  _cached_size_ = 0;
  read_only_file_size_ = GOOGLE_ULONGLONG(0);
  replica_update_policy_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  version_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

XLocSet::~XLocSet() {
  SharedDtor();
}

void XLocSet::SharedDtor() {
  if (replica_update_policy_ != &::google::protobuf::internal::kEmptyString) {
    delete replica_update_policy_;
  }
  if (this != default_instance_) {
  }
}

void XLocSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* XLocSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return XLocSet_descriptor_;
}

const XLocSet& XLocSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

XLocSet* XLocSet::default_instance_ = NULL;

XLocSet* XLocSet::New() const {
  return new XLocSet;
}

void XLocSet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    read_only_file_size_ = GOOGLE_ULONGLONG(0);
    if (has_replica_update_policy()) {
      if (replica_update_policy_ != &::google::protobuf::internal::kEmptyString) {
        replica_update_policy_->clear();
      }
    }
    version_ = 0u;
  }
  replicas_.Clear();
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool XLocSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required fixed64 read_only_file_size = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &read_only_file_size_)));
          set_has_read_only_file_size();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_replicas;
        break;
      }

      // repeated .xtreemfs.pbrpc.Replica replicas = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_replicas:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
                input, add_replicas()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_replicas;
        if (input->ExpectTag(26)) goto parse_replica_update_policy;
        break;
      }

      // required string replica_update_policy = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_replica_update_policy:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_replica_update_policy()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->replica_update_policy().data(), this->replica_update_policy().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(37)) goto parse_version;
        break;
      }

      // required fixed32 version = 4;
      case 4: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_version:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &version_)));
          set_has_version();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void XLocSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required fixed64 read_only_file_size = 1;
  if (has_read_only_file_size()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->read_only_file_size(), output);
  }

  // repeated .xtreemfs.pbrpc.Replica replicas = 2;
  for (int i = 0; i < this->replicas_size(); i++) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->replicas(i), output);
  }

  // required string replica_update_policy = 3;
  if (has_replica_update_policy()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->replica_update_policy().data(), this->replica_update_policy().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      3, this->replica_update_policy(), output);
  }

  // required fixed32 version = 4;
  if (has_version()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(4, this->version(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* XLocSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required fixed64 read_only_file_size = 1;
  if (has_read_only_file_size()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->read_only_file_size(), target);
  }

  // repeated .xtreemfs.pbrpc.Replica replicas = 2;
  for (int i = 0; i < this->replicas_size(); i++) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->replicas(i), target);
  }

  // required string replica_update_policy = 3;
  if (has_replica_update_policy()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->replica_update_policy().data(), this->replica_update_policy().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->replica_update_policy(), target);
  }

  // required fixed32 version = 4;
  if (has_version()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(4, this->version(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int XLocSet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required fixed64 read_only_file_size = 1;
    if (has_read_only_file_size()) {
      total_size += 1 + 8;
    }

    // required string replica_update_policy = 3;
    if (has_replica_update_policy()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->replica_update_policy());
    }

    // required fixed32 version = 4;
    if (has_version()) {
      total_size += 1 + 4;
    }

  }
  // repeated .xtreemfs.pbrpc.Replica replicas = 2;
  total_size += 1 * this->replicas_size();
  for (int i = 0; i < this->replicas_size(); i++) {
    total_size +=
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        this->replicas(i));
  }

  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void XLocSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const XLocSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const XLocSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void XLocSet::MergeFrom(const XLocSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  replicas_.MergeFrom(from.replicas_);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_read_only_file_size()) {
      set_read_only_file_size(from.read_only_file_size());
    }
    if (from.has_replica_update_policy()) {
      set_replica_update_policy(from.replica_update_policy());
    }
    if (from.has_version()) {
      set_version(from.version());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void XLocSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void XLocSet::CopyFrom(const XLocSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool XLocSet::IsInitialized() const {
  if ((_has_bits_[0] & 0x0000000d) != 0x0000000d) return false;

  for (int i = 0; i < replicas_size(); i++) {
    if (!this->replicas(i).IsInitialized()) return false;
  }
  return true;
}

void XLocSet::Swap(XLocSet* other) {
  if (other != this) {
    std::swap(read_only_file_size_, other->read_only_file_size_);
    replicas_.Swap(&other->replicas_);
    std::swap(replica_update_policy_, other->replica_update_policy_);
    std::swap(version_, other->version_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata XLocSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = XLocSet_descriptor_;
  metadata.reflection = XLocSet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileCredentials::kXcapFieldNumber;
const int FileCredentials::kXlocsFieldNumber;
#endif  // !_MSC_VER

FileCredentials::FileCredentials()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileCredentials::InitAsDefaultInstance() {
  xcap_ = const_cast< ::xtreemfs::pbrpc::XCap*>(&::xtreemfs::pbrpc::XCap::default_instance());
  xlocs_ = const_cast< ::xtreemfs::pbrpc::XLocSet*>(&::xtreemfs::pbrpc::XLocSet::default_instance());
}

FileCredentials::FileCredentials(const FileCredentials& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileCredentials::SharedCtor() {
  _cached_size_ = 0;
  xcap_ = NULL;
  xlocs_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileCredentials::~FileCredentials() {
  SharedDtor();
}

void FileCredentials::SharedDtor() {
  if (this != default_instance_) {
    delete xcap_;
    delete xlocs_;
  }
}

void FileCredentials::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileCredentials::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileCredentials_descriptor_;
}

const FileCredentials& FileCredentials::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

FileCredentials* FileCredentials::default_instance_ = NULL;

FileCredentials* FileCredentials::New() const {
  return new FileCredentials;
}

void FileCredentials::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_xcap()) {
      if (xcap_ != NULL) xcap_->::xtreemfs::pbrpc::XCap::Clear();
    }
    if (has_xlocs()) {
      if (xlocs_ != NULL) xlocs_->::xtreemfs::pbrpc::XLocSet::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileCredentials::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required .xtreemfs.pbrpc.XCap xcap = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_xcap()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_xlocs;
        break;
      }

      // required .xtreemfs.pbrpc.XLocSet xlocs = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_xlocs:
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_xlocs()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileCredentials::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required .xtreemfs.pbrpc.XCap xcap = 1;
  if (has_xcap()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->xcap(), output);
  }

  // required .xtreemfs.pbrpc.XLocSet xlocs = 2;
  if (has_xlocs()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      2, this->xlocs(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileCredentials::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required .xtreemfs.pbrpc.XCap xcap = 1;
  if (has_xcap()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->xcap(), target);
  }

  // required .xtreemfs.pbrpc.XLocSet xlocs = 2;
  if (has_xlocs()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        2, this->xlocs(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileCredentials::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required .xtreemfs.pbrpc.XCap xcap = 1;
    if (has_xcap()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->xcap());
    }

    // required .xtreemfs.pbrpc.XLocSet xlocs = 2;
    if (has_xlocs()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->xlocs());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileCredentials::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileCredentials* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileCredentials*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileCredentials::MergeFrom(const FileCredentials& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_xcap()) {
      mutable_xcap()->::xtreemfs::pbrpc::XCap::MergeFrom(from.xcap());
    }
    if (from.has_xlocs()) {
      mutable_xlocs()->::xtreemfs::pbrpc::XLocSet::MergeFrom(from.xlocs());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileCredentials::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileCredentials::CopyFrom(const FileCredentials& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileCredentials::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  if (has_xcap()) {
    if (!this->xcap().IsInitialized()) return false;
  }
  if (has_xlocs()) {
    if (!this->xlocs().IsInitialized()) return false;
  }
  return true;
}

void FileCredentials::Swap(FileCredentials* other) {
  if (other != this) {
    std::swap(xcap_, other->xcap_);
    std::swap(xlocs_, other->xlocs_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileCredentials::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileCredentials_descriptor_;
  metadata.reflection = FileCredentials_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int FileCredentialsSet::kFileCredentialsFieldNumber;
#endif  // !_MSC_VER

FileCredentialsSet::FileCredentialsSet()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void FileCredentialsSet::InitAsDefaultInstance() {
  file_credentials_ = const_cast< ::xtreemfs::pbrpc::FileCredentials*>(&::xtreemfs::pbrpc::FileCredentials::default_instance());
}

FileCredentialsSet::FileCredentialsSet(const FileCredentialsSet& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void FileCredentialsSet::SharedCtor() {
  _cached_size_ = 0;
  file_credentials_ = NULL;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

FileCredentialsSet::~FileCredentialsSet() {
  SharedDtor();
}

void FileCredentialsSet::SharedDtor() {
  if (this != default_instance_) {
    delete file_credentials_;
  }
}

void FileCredentialsSet::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* FileCredentialsSet::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return FileCredentialsSet_descriptor_;
}

const FileCredentialsSet& FileCredentialsSet::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

FileCredentialsSet* FileCredentialsSet::default_instance_ = NULL;

FileCredentialsSet* FileCredentialsSet::New() const {
  return new FileCredentialsSet;
}

void FileCredentialsSet::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_file_credentials()) {
      if (file_credentials_ != NULL) file_credentials_->::xtreemfs::pbrpc::FileCredentials::Clear();
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool FileCredentialsSet::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_file_credentials()));
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void FileCredentialsSet::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  if (has_file_credentials()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, this->file_credentials(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* FileCredentialsSet::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
  if (has_file_credentials()) {
    target = ::google::protobuf::internal::WireFormatLite::
      WriteMessageNoVirtualToArray(
        1, this->file_credentials(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int FileCredentialsSet::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional .xtreemfs.pbrpc.FileCredentials file_credentials = 1;
    if (has_file_credentials()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          this->file_credentials());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void FileCredentialsSet::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const FileCredentialsSet* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const FileCredentialsSet*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void FileCredentialsSet::MergeFrom(const FileCredentialsSet& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_file_credentials()) {
      mutable_file_credentials()->::xtreemfs::pbrpc::FileCredentials::MergeFrom(from.file_credentials());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void FileCredentialsSet::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void FileCredentialsSet::CopyFrom(const FileCredentialsSet& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool FileCredentialsSet::IsInitialized() const {

  if (has_file_credentials()) {
    if (!this->file_credentials().IsInitialized()) return false;
  }
  return true;
}

void FileCredentialsSet::Swap(FileCredentialsSet* other) {
  if (other != this) {
    std::swap(file_credentials_, other->file_credentials_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata FileCredentialsSet::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = FileCredentialsSet_descriptor_;
  metadata.reflection = FileCredentialsSet_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int VivaldiCoordinates::kXCoordinateFieldNumber;
const int VivaldiCoordinates::kYCoordinateFieldNumber;
const int VivaldiCoordinates::kLocalErrorFieldNumber;
#endif  // !_MSC_VER

VivaldiCoordinates::VivaldiCoordinates()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void VivaldiCoordinates::InitAsDefaultInstance() {
}

VivaldiCoordinates::VivaldiCoordinates(const VivaldiCoordinates& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void VivaldiCoordinates::SharedCtor() {
  _cached_size_ = 0;
  x_coordinate_ = 0;
  y_coordinate_ = 0;
  local_error_ = 0;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

VivaldiCoordinates::~VivaldiCoordinates() {
  SharedDtor();
}

void VivaldiCoordinates::SharedDtor() {
  if (this != default_instance_) {
  }
}

void VivaldiCoordinates::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VivaldiCoordinates::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VivaldiCoordinates_descriptor_;
}

const VivaldiCoordinates& VivaldiCoordinates::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

VivaldiCoordinates* VivaldiCoordinates::default_instance_ = NULL;

VivaldiCoordinates* VivaldiCoordinates::New() const {
  return new VivaldiCoordinates;
}

void VivaldiCoordinates::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    x_coordinate_ = 0;
    y_coordinate_ = 0;
    local_error_ = 0;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool VivaldiCoordinates::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required double x_coordinate = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &x_coordinate_)));
          set_has_x_coordinate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(17)) goto parse_y_coordinate;
        break;
      }

      // required double y_coordinate = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_y_coordinate:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &y_coordinate_)));
          set_has_y_coordinate();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(25)) goto parse_local_error;
        break;
      }

      // required double local_error = 3;
      case 3: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
         parse_local_error:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   double, ::google::protobuf::internal::WireFormatLite::TYPE_DOUBLE>(
                 input, &local_error_)));
          set_has_local_error();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void VivaldiCoordinates::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required double x_coordinate = 1;
  if (has_x_coordinate()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(1, this->x_coordinate(), output);
  }

  // required double y_coordinate = 2;
  if (has_y_coordinate()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(2, this->y_coordinate(), output);
  }

  // required double local_error = 3;
  if (has_local_error()) {
    ::google::protobuf::internal::WireFormatLite::WriteDouble(3, this->local_error(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* VivaldiCoordinates::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required double x_coordinate = 1;
  if (has_x_coordinate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(1, this->x_coordinate(), target);
  }

  // required double y_coordinate = 2;
  if (has_y_coordinate()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(2, this->y_coordinate(), target);
  }

  // required double local_error = 3;
  if (has_local_error()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteDoubleToArray(3, this->local_error(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int VivaldiCoordinates::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required double x_coordinate = 1;
    if (has_x_coordinate()) {
      total_size += 1 + 8;
    }

    // required double y_coordinate = 2;
    if (has_y_coordinate()) {
      total_size += 1 + 8;
    }

    // required double local_error = 3;
    if (has_local_error()) {
      total_size += 1 + 8;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VivaldiCoordinates::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const VivaldiCoordinates* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const VivaldiCoordinates*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void VivaldiCoordinates::MergeFrom(const VivaldiCoordinates& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_x_coordinate()) {
      set_x_coordinate(from.x_coordinate());
    }
    if (from.has_y_coordinate()) {
      set_y_coordinate(from.y_coordinate());
    }
    if (from.has_local_error()) {
      set_local_error(from.local_error());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void VivaldiCoordinates::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VivaldiCoordinates::CopyFrom(const VivaldiCoordinates& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool VivaldiCoordinates::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000007) != 0x00000007) return false;

  return true;
}

void VivaldiCoordinates::Swap(VivaldiCoordinates* other) {
  if (other != this) {
    std::swap(x_coordinate_, other->x_coordinate_);
    std::swap(y_coordinate_, other->y_coordinate_);
    std::swap(local_error_, other->local_error_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata VivaldiCoordinates::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VivaldiCoordinates_descriptor_;
  metadata.reflection = VivaldiCoordinates_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int OSDWriteResponse::kSizeInBytesFieldNumber;
const int OSDWriteResponse::kTruncateEpochFieldNumber;
#endif  // !_MSC_VER

OSDWriteResponse::OSDWriteResponse()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void OSDWriteResponse::InitAsDefaultInstance() {
}

OSDWriteResponse::OSDWriteResponse(const OSDWriteResponse& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void OSDWriteResponse::SharedCtor() {
  _cached_size_ = 0;
  size_in_bytes_ = GOOGLE_ULONGLONG(0);
  truncate_epoch_ = 0u;
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

OSDWriteResponse::~OSDWriteResponse() {
  SharedDtor();
}

void OSDWriteResponse::SharedDtor() {
  if (this != default_instance_) {
  }
}

void OSDWriteResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* OSDWriteResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return OSDWriteResponse_descriptor_;
}

const OSDWriteResponse& OSDWriteResponse::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

OSDWriteResponse* OSDWriteResponse::default_instance_ = NULL;

OSDWriteResponse* OSDWriteResponse::New() const {
  return new OSDWriteResponse;
}

void OSDWriteResponse::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    size_in_bytes_ = GOOGLE_ULONGLONG(0);
    truncate_epoch_ = 0u;
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool OSDWriteResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional fixed64 size_in_bytes = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED64) {
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint64, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED64>(
                 input, &size_in_bytes_)));
          set_has_size_in_bytes();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(21)) goto parse_truncate_epoch;
        break;
      }

      // optional fixed32 truncate_epoch = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_FIXED32) {
         parse_truncate_epoch:
          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::uint32, ::google::protobuf::internal::WireFormatLite::TYPE_FIXED32>(
                 input, &truncate_epoch_)));
          set_has_truncate_epoch();
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void OSDWriteResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // optional fixed64 size_in_bytes = 1;
  if (has_size_in_bytes()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed64(1, this->size_in_bytes(), output);
  }

  // optional fixed32 truncate_epoch = 2;
  if (has_truncate_epoch()) {
    ::google::protobuf::internal::WireFormatLite::WriteFixed32(2, this->truncate_epoch(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* OSDWriteResponse::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // optional fixed64 size_in_bytes = 1;
  if (has_size_in_bytes()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed64ToArray(1, this->size_in_bytes(), target);
  }

  // optional fixed32 truncate_epoch = 2;
  if (has_truncate_epoch()) {
    target = ::google::protobuf::internal::WireFormatLite::WriteFixed32ToArray(2, this->truncate_epoch(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int OSDWriteResponse::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // optional fixed64 size_in_bytes = 1;
    if (has_size_in_bytes()) {
      total_size += 1 + 8;
    }

    // optional fixed32 truncate_epoch = 2;
    if (has_truncate_epoch()) {
      total_size += 1 + 4;
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void OSDWriteResponse::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const OSDWriteResponse* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const OSDWriteResponse*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void OSDWriteResponse::MergeFrom(const OSDWriteResponse& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_size_in_bytes()) {
      set_size_in_bytes(from.size_in_bytes());
    }
    if (from.has_truncate_epoch()) {
      set_truncate_epoch(from.truncate_epoch());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void OSDWriteResponse::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void OSDWriteResponse::CopyFrom(const OSDWriteResponse& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool OSDWriteResponse::IsInitialized() const {

  return true;
}

void OSDWriteResponse::Swap(OSDWriteResponse* other) {
  if (other != this) {
    std::swap(size_in_bytes_, other->size_in_bytes_);
    std::swap(truncate_epoch_, other->truncate_epoch_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata OSDWriteResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = OSDWriteResponse_descriptor_;
  metadata.reflection = OSDWriteResponse_reflection_;
  return metadata;
}


// ===================================================================

#ifndef _MSC_VER
const int KeyValuePair::kKeyFieldNumber;
const int KeyValuePair::kValueFieldNumber;
#endif  // !_MSC_VER

KeyValuePair::KeyValuePair()
  : ::google::protobuf::Message() {
  SharedCtor();
}

void KeyValuePair::InitAsDefaultInstance() {
}

KeyValuePair::KeyValuePair(const KeyValuePair& from)
  : ::google::protobuf::Message() {
  SharedCtor();
  MergeFrom(from);
}

void KeyValuePair::SharedCtor() {
  _cached_size_ = 0;
  key_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
}

KeyValuePair::~KeyValuePair() {
  SharedDtor();
}

void KeyValuePair::SharedDtor() {
  if (key_ != &::google::protobuf::internal::kEmptyString) {
    delete key_;
  }
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (this != default_instance_) {
  }
}

void KeyValuePair::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* KeyValuePair::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return KeyValuePair_descriptor_;
}

const KeyValuePair& KeyValuePair::default_instance() {
  if (default_instance_ == NULL) protobuf_AddDesc_xtreemfs_2fGlobalTypes_2eproto();
  return *default_instance_;
}

KeyValuePair* KeyValuePair::default_instance_ = NULL;

KeyValuePair* KeyValuePair::New() const {
  return new KeyValuePair;
}

void KeyValuePair::Clear() {
  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (has_key()) {
      if (key_ != &::google::protobuf::internal::kEmptyString) {
        key_->clear();
      }
    }
    if (has_value()) {
      if (value_ != &::google::protobuf::internal::kEmptyString) {
        value_->clear();
      }
    }
  }
  ::memset(_has_bits_, 0, sizeof(_has_bits_));
  mutable_unknown_fields()->Clear();
}

bool KeyValuePair::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!(EXPRESSION)) return false
  ::google::protobuf::uint32 tag;
  while ((tag = input->ReadTag()) != 0) {
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // required string key = 1;
      case 1: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_key()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->key().data(), this->key().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectTag(18)) goto parse_value;
        break;
      }

      // required string value = 2;
      case 2: {
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_LENGTH_DELIMITED) {
         parse_value:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_value()));
          ::google::protobuf::internal::WireFormat::VerifyUTF8String(
            this->value().data(), this->value().length(),
            ::google::protobuf::internal::WireFormat::PARSE);
        } else {
          goto handle_uninterpreted;
        }
        if (input->ExpectAtEnd()) return true;
        break;
      }

      default: {
      handle_uninterpreted:
        if (::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          return true;
        }
        DO_(::google::protobuf::internal::WireFormat::SkipField(
              input, tag, mutable_unknown_fields()));
        break;
      }
    }
  }
  return true;
#undef DO_
}

void KeyValuePair::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      1, this->key(), output);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    ::google::protobuf::internal::WireFormatLite::WriteString(
      2, this->value(), output);
  }

  if (!unknown_fields().empty()) {
    ::google::protobuf::internal::WireFormat::SerializeUnknownFields(
        unknown_fields(), output);
  }
}

::google::protobuf::uint8* KeyValuePair::SerializeWithCachedSizesToArray(
    ::google::protobuf::uint8* target) const {
  // required string key = 1;
  if (has_key()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->key().data(), this->key().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->key(), target);
  }

  // required string value = 2;
  if (has_value()) {
    ::google::protobuf::internal::WireFormat::VerifyUTF8String(
      this->value().data(), this->value().length(),
      ::google::protobuf::internal::WireFormat::SERIALIZE);
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->value(), target);
  }

  if (!unknown_fields().empty()) {
    target = ::google::protobuf::internal::WireFormat::SerializeUnknownFieldsToArray(
        unknown_fields(), target);
  }
  return target;
}

int KeyValuePair::ByteSize() const {
  int total_size = 0;

  if (_has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    // required string key = 1;
    if (has_key()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->key());
    }

    // required string value = 2;
    if (has_value()) {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::StringSize(
          this->value());
    }

  }
  if (!unknown_fields().empty()) {
    total_size +=
      ::google::protobuf::internal::WireFormat::ComputeUnknownFieldsSize(
        unknown_fields());
  }
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = total_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void KeyValuePair::MergeFrom(const ::google::protobuf::Message& from) {
  GOOGLE_CHECK_NE(&from, this);
  const KeyValuePair* source =
    ::google::protobuf::internal::dynamic_cast_if_available<const KeyValuePair*>(
      &from);
  if (source == NULL) {
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
    MergeFrom(*source);
  }
}

void KeyValuePair::MergeFrom(const KeyValuePair& from) {
  GOOGLE_CHECK_NE(&from, this);
  if (from._has_bits_[0 / 32] & (0xffu << (0 % 32))) {
    if (from.has_key()) {
      set_key(from.key());
    }
    if (from.has_value()) {
      set_value(from.value());
    }
  }
  mutable_unknown_fields()->MergeFrom(from.unknown_fields());
}

void KeyValuePair::CopyFrom(const ::google::protobuf::Message& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void KeyValuePair::CopyFrom(const KeyValuePair& from) {
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool KeyValuePair::IsInitialized() const {
  if ((_has_bits_[0] & 0x00000003) != 0x00000003) return false;

  return true;
}

void KeyValuePair::Swap(KeyValuePair* other) {
  if (other != this) {
    std::swap(key_, other->key_);
    std::swap(value_, other->value_);
    std::swap(_has_bits_[0], other->_has_bits_[0]);
    _unknown_fields_.Swap(&other->_unknown_fields_);
    std::swap(_cached_size_, other->_cached_size_);
  }
}

::google::protobuf::Metadata KeyValuePair::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = KeyValuePair_descriptor_;
  metadata.reflection = KeyValuePair_reflection_;
  return metadata;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

// @@protoc_insertion_point(global_scope)
