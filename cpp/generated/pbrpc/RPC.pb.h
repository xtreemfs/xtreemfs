// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: pbrpc/RPC.proto

#ifndef PROTOBUF_pbrpc_2fRPC_2eproto__INCLUDED
#define PROTOBUF_pbrpc_2fRPC_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace xtreemfs {
namespace pbrpc {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();

class UserCredentials;
class AuthPassword;
class Auth;
class RPCHeader;
class RPCHeader_RequestHeader;
class RPCHeader_ErrorResponse;

enum MessageType {
  RPC_REQUEST = 0,
  RPC_RESPONSE_SUCCESS = 1,
  RPC_RESPONSE_ERROR = 2
};
bool MessageType_IsValid(int value);
const MessageType MessageType_MIN = RPC_REQUEST;
const MessageType MessageType_MAX = RPC_RESPONSE_ERROR;
const int MessageType_ARRAYSIZE = MessageType_MAX + 1;

const ::google::protobuf::EnumDescriptor* MessageType_descriptor();
inline const ::std::string& MessageType_Name(MessageType value) {
  return ::google::protobuf::internal::NameOfEnum(
    MessageType_descriptor(), value);
}
inline bool MessageType_Parse(
    const ::std::string& name, MessageType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MessageType>(
    MessageType_descriptor(), name, value);
}
enum AuthType {
  AUTH_NONE = 0,
  AUTH_PASSWORD = 1
};
bool AuthType_IsValid(int value);
const AuthType AuthType_MIN = AUTH_NONE;
const AuthType AuthType_MAX = AUTH_PASSWORD;
const int AuthType_ARRAYSIZE = AuthType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AuthType_descriptor();
inline const ::std::string& AuthType_Name(AuthType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AuthType_descriptor(), value);
}
inline bool AuthType_Parse(
    const ::std::string& name, AuthType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AuthType>(
    AuthType_descriptor(), name, value);
}
enum ErrorType {
  INVALID_INTERFACE_ID = 1,
  INVALID_PROC_ID = 2,
  GARBAGE_ARGS = 3,
  AUTH_FAILED = 4,
  INTERNAL_SERVER_ERROR = 5,
  ERRNO = 6,
  REDIRECT = 7,
  INVALID_VIEW = 8,
  IO_ERROR = 100
};
bool ErrorType_IsValid(int value);
const ErrorType ErrorType_MIN = INVALID_INTERFACE_ID;
const ErrorType ErrorType_MAX = IO_ERROR;
const int ErrorType_ARRAYSIZE = ErrorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* ErrorType_descriptor();
inline const ::std::string& ErrorType_Name(ErrorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    ErrorType_descriptor(), value);
}
inline bool ErrorType_Parse(
    const ::std::string& name, ErrorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<ErrorType>(
    ErrorType_descriptor(), name, value);
}
enum POSIXErrno {
  POSIX_ERROR_NONE = 9999,
  POSIX_ERROR_EPERM = 1,
  POSIX_ERROR_ENOENT = 2,
  POSIX_ERROR_EINTR = 4,
  POSIX_ERROR_EIO = 5,
  POSIX_ERROR_EAGAIN = 11,
  POSIX_ERROR_EACCES = 13,
  POSIX_ERROR_EEXIST = 17,
  POSIX_ERROR_EXDEV = 18,
  POSIX_ERROR_ENODEV = 19,
  POSIX_ERROR_ENOTDIR = 20,
  POSIX_ERROR_EISDIR = 21,
  POSIX_ERROR_EINVAL = 22,
  POSIX_ERROR_ENOSPC = 28,
  POSIX_ERROR_ENOTEMPTY = 39,
  POSIX_ERROR_ENODATA = 61
};
bool POSIXErrno_IsValid(int value);
const POSIXErrno POSIXErrno_MIN = POSIX_ERROR_EPERM;
const POSIXErrno POSIXErrno_MAX = POSIX_ERROR_NONE;
const int POSIXErrno_ARRAYSIZE = POSIXErrno_MAX + 1;

const ::google::protobuf::EnumDescriptor* POSIXErrno_descriptor();
inline const ::std::string& POSIXErrno_Name(POSIXErrno value) {
  return ::google::protobuf::internal::NameOfEnum(
    POSIXErrno_descriptor(), value);
}
inline bool POSIXErrno_Parse(
    const ::std::string& name, POSIXErrno* value) {
  return ::google::protobuf::internal::ParseNamedEnum<POSIXErrno>(
    POSIXErrno_descriptor(), name, value);
}
// ===================================================================

class UserCredentials : public ::google::protobuf::Message {
 public:
  UserCredentials();
  virtual ~UserCredentials();

  UserCredentials(const UserCredentials& from);

  inline UserCredentials& operator=(const UserCredentials& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const UserCredentials& default_instance();

  void Swap(UserCredentials* other);

  // implements Message ----------------------------------------------

  UserCredentials* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const UserCredentials& from);
  void MergeFrom(const UserCredentials& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string username = 1;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 1;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // repeated string groups = 2;
  inline int groups_size() const;
  inline void clear_groups();
  static const int kGroupsFieldNumber = 2;
  inline const ::std::string& groups(int index) const;
  inline ::std::string* mutable_groups(int index);
  inline void set_groups(int index, const ::std::string& value);
  inline void set_groups(int index, const char* value);
  inline void set_groups(int index, const char* value, size_t size);
  inline ::std::string* add_groups();
  inline void add_groups(const ::std::string& value);
  inline void add_groups(const char* value);
  inline void add_groups(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& groups() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_groups();

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.UserCredentials)
 private:
  inline void set_has_username();
  inline void clear_has_username();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::google::protobuf::RepeatedPtrField< ::std::string> groups_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();

  void InitAsDefaultInstance();
  static UserCredentials* default_instance_;
};
// -------------------------------------------------------------------

class AuthPassword : public ::google::protobuf::Message {
 public:
  AuthPassword();
  virtual ~AuthPassword();

  AuthPassword(const AuthPassword& from);

  inline AuthPassword& operator=(const AuthPassword& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AuthPassword& default_instance();

  void Swap(AuthPassword* other);

  // implements Message ----------------------------------------------

  AuthPassword* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AuthPassword& from);
  void MergeFrom(const AuthPassword& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string password = 1;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 1;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.AuthPassword)
 private:
  inline void set_has_password();
  inline void clear_has_password();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* password_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();

  void InitAsDefaultInstance();
  static AuthPassword* default_instance_;
};
// -------------------------------------------------------------------

class Auth : public ::google::protobuf::Message {
 public:
  Auth();
  virtual ~Auth();

  Auth(const Auth& from);

  inline Auth& operator=(const Auth& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Auth& default_instance();

  void Swap(Auth* other);

  // implements Message ----------------------------------------------

  Auth* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Auth& from);
  void MergeFrom(const Auth& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.AuthType auth_type = 1;
  inline bool has_auth_type() const;
  inline void clear_auth_type();
  static const int kAuthTypeFieldNumber = 1;
  inline ::xtreemfs::pbrpc::AuthType auth_type() const;
  inline void set_auth_type(::xtreemfs::pbrpc::AuthType value);

  // optional .xtreemfs.pbrpc.AuthPassword auth_passwd = 3;
  inline bool has_auth_passwd() const;
  inline void clear_auth_passwd();
  static const int kAuthPasswdFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::AuthPassword& auth_passwd() const;
  inline ::xtreemfs::pbrpc::AuthPassword* mutable_auth_passwd();
  inline ::xtreemfs::pbrpc::AuthPassword* release_auth_passwd();
  inline void set_allocated_auth_passwd(::xtreemfs::pbrpc::AuthPassword* auth_passwd);

  // optional bytes auth_data = 2;
  inline bool has_auth_data() const;
  inline void clear_auth_data();
  static const int kAuthDataFieldNumber = 2;
  inline const ::std::string& auth_data() const;
  inline void set_auth_data(const ::std::string& value);
  inline void set_auth_data(const char* value);
  inline void set_auth_data(const void* value, size_t size);
  inline ::std::string* mutable_auth_data();
  inline ::std::string* release_auth_data();
  inline void set_allocated_auth_data(::std::string* auth_data);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.Auth)
 private:
  inline void set_has_auth_type();
  inline void clear_has_auth_type();
  inline void set_has_auth_passwd();
  inline void clear_has_auth_passwd();
  inline void set_has_auth_data();
  inline void clear_has_auth_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::xtreemfs::pbrpc::AuthPassword* auth_passwd_;
  ::std::string* auth_data_;
  int auth_type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();

  void InitAsDefaultInstance();
  static Auth* default_instance_;
};
// -------------------------------------------------------------------

class RPCHeader_RequestHeader : public ::google::protobuf::Message {
 public:
  RPCHeader_RequestHeader();
  virtual ~RPCHeader_RequestHeader();

  RPCHeader_RequestHeader(const RPCHeader_RequestHeader& from);

  inline RPCHeader_RequestHeader& operator=(const RPCHeader_RequestHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCHeader_RequestHeader& default_instance();

  void Swap(RPCHeader_RequestHeader* other);

  // implements Message ----------------------------------------------

  RPCHeader_RequestHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCHeader_RequestHeader& from);
  void MergeFrom(const RPCHeader_RequestHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required fixed32 interface_id = 1;
  inline bool has_interface_id() const;
  inline void clear_interface_id();
  static const int kInterfaceIdFieldNumber = 1;
  inline ::google::protobuf::uint32 interface_id() const;
  inline void set_interface_id(::google::protobuf::uint32 value);

  // required fixed32 proc_id = 2;
  inline bool has_proc_id() const;
  inline void clear_proc_id();
  static const int kProcIdFieldNumber = 2;
  inline ::google::protobuf::uint32 proc_id() const;
  inline void set_proc_id(::google::protobuf::uint32 value);

  // required .xtreemfs.pbrpc.UserCredentials user_creds = 3;
  inline bool has_user_creds() const;
  inline void clear_user_creds();
  static const int kUserCredsFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::UserCredentials& user_creds() const;
  inline ::xtreemfs::pbrpc::UserCredentials* mutable_user_creds();
  inline ::xtreemfs::pbrpc::UserCredentials* release_user_creds();
  inline void set_allocated_user_creds(::xtreemfs::pbrpc::UserCredentials* user_creds);

  // required .xtreemfs.pbrpc.Auth auth_data = 4;
  inline bool has_auth_data() const;
  inline void clear_auth_data();
  static const int kAuthDataFieldNumber = 4;
  inline const ::xtreemfs::pbrpc::Auth& auth_data() const;
  inline ::xtreemfs::pbrpc::Auth* mutable_auth_data();
  inline ::xtreemfs::pbrpc::Auth* release_auth_data();
  inline void set_allocated_auth_data(::xtreemfs::pbrpc::Auth* auth_data);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.RPCHeader.RequestHeader)
 private:
  inline void set_has_interface_id();
  inline void clear_has_interface_id();
  inline void set_has_proc_id();
  inline void clear_has_proc_id();
  inline void set_has_user_creds();
  inline void clear_has_user_creds();
  inline void set_has_auth_data();
  inline void clear_has_auth_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 interface_id_;
  ::google::protobuf::uint32 proc_id_;
  ::xtreemfs::pbrpc::UserCredentials* user_creds_;
  ::xtreemfs::pbrpc::Auth* auth_data_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();

  void InitAsDefaultInstance();
  static RPCHeader_RequestHeader* default_instance_;
};
// -------------------------------------------------------------------

class RPCHeader_ErrorResponse : public ::google::protobuf::Message {
 public:
  RPCHeader_ErrorResponse();
  virtual ~RPCHeader_ErrorResponse();

  RPCHeader_ErrorResponse(const RPCHeader_ErrorResponse& from);

  inline RPCHeader_ErrorResponse& operator=(const RPCHeader_ErrorResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCHeader_ErrorResponse& default_instance();

  void Swap(RPCHeader_ErrorResponse* other);

  // implements Message ----------------------------------------------

  RPCHeader_ErrorResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCHeader_ErrorResponse& from);
  void MergeFrom(const RPCHeader_ErrorResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .xtreemfs.pbrpc.ErrorType error_type = 1;
  inline bool has_error_type() const;
  inline void clear_error_type();
  static const int kErrorTypeFieldNumber = 1;
  inline ::xtreemfs::pbrpc::ErrorType error_type() const;
  inline void set_error_type(::xtreemfs::pbrpc::ErrorType value);

  // optional .xtreemfs.pbrpc.POSIXErrno posix_errno = 2 [default = POSIX_ERROR_NONE];
  inline bool has_posix_errno() const;
  inline void clear_posix_errno();
  static const int kPosixErrnoFieldNumber = 2;
  inline ::xtreemfs::pbrpc::POSIXErrno posix_errno() const;
  inline void set_posix_errno(::xtreemfs::pbrpc::POSIXErrno value);

  // optional string error_message = 3;
  inline bool has_error_message() const;
  inline void clear_error_message();
  static const int kErrorMessageFieldNumber = 3;
  inline const ::std::string& error_message() const;
  inline void set_error_message(const ::std::string& value);
  inline void set_error_message(const char* value);
  inline void set_error_message(const char* value, size_t size);
  inline ::std::string* mutable_error_message();
  inline ::std::string* release_error_message();
  inline void set_allocated_error_message(::std::string* error_message);

  // optional string debug_info = 4;
  inline bool has_debug_info() const;
  inline void clear_debug_info();
  static const int kDebugInfoFieldNumber = 4;
  inline const ::std::string& debug_info() const;
  inline void set_debug_info(const ::std::string& value);
  inline void set_debug_info(const char* value);
  inline void set_debug_info(const char* value, size_t size);
  inline ::std::string* mutable_debug_info();
  inline ::std::string* release_debug_info();
  inline void set_allocated_debug_info(::std::string* debug_info);

  // optional string redirect_to_server_uuid = 5;
  inline bool has_redirect_to_server_uuid() const;
  inline void clear_redirect_to_server_uuid();
  static const int kRedirectToServerUuidFieldNumber = 5;
  inline const ::std::string& redirect_to_server_uuid() const;
  inline void set_redirect_to_server_uuid(const ::std::string& value);
  inline void set_redirect_to_server_uuid(const char* value);
  inline void set_redirect_to_server_uuid(const char* value, size_t size);
  inline ::std::string* mutable_redirect_to_server_uuid();
  inline ::std::string* release_redirect_to_server_uuid();
  inline void set_allocated_redirect_to_server_uuid(::std::string* redirect_to_server_uuid);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.RPCHeader.ErrorResponse)
 private:
  inline void set_has_error_type();
  inline void clear_has_error_type();
  inline void set_has_posix_errno();
  inline void clear_has_posix_errno();
  inline void set_has_error_message();
  inline void clear_has_error_message();
  inline void set_has_debug_info();
  inline void clear_has_debug_info();
  inline void set_has_redirect_to_server_uuid();
  inline void clear_has_redirect_to_server_uuid();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int error_type_;
  int posix_errno_;
  ::std::string* error_message_;
  ::std::string* debug_info_;
  ::std::string* redirect_to_server_uuid_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();

  void InitAsDefaultInstance();
  static RPCHeader_ErrorResponse* default_instance_;
};
// -------------------------------------------------------------------

class RPCHeader : public ::google::protobuf::Message {
 public:
  RPCHeader();
  virtual ~RPCHeader();

  RPCHeader(const RPCHeader& from);

  inline RPCHeader& operator=(const RPCHeader& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RPCHeader& default_instance();

  void Swap(RPCHeader* other);

  // implements Message ----------------------------------------------

  RPCHeader* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RPCHeader& from);
  void MergeFrom(const RPCHeader& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RPCHeader_RequestHeader RequestHeader;
  typedef RPCHeader_ErrorResponse ErrorResponse;

  // accessors -------------------------------------------------------

  // required fixed32 call_id = 1;
  inline bool has_call_id() const;
  inline void clear_call_id();
  static const int kCallIdFieldNumber = 1;
  inline ::google::protobuf::uint32 call_id() const;
  inline void set_call_id(::google::protobuf::uint32 value);

  // required .xtreemfs.pbrpc.MessageType message_type = 2;
  inline bool has_message_type() const;
  inline void clear_message_type();
  static const int kMessageTypeFieldNumber = 2;
  inline ::xtreemfs::pbrpc::MessageType message_type() const;
  inline void set_message_type(::xtreemfs::pbrpc::MessageType value);

  // optional .xtreemfs.pbrpc.RPCHeader.RequestHeader request_header = 3;
  inline bool has_request_header() const;
  inline void clear_request_header();
  static const int kRequestHeaderFieldNumber = 3;
  inline const ::xtreemfs::pbrpc::RPCHeader_RequestHeader& request_header() const;
  inline ::xtreemfs::pbrpc::RPCHeader_RequestHeader* mutable_request_header();
  inline ::xtreemfs::pbrpc::RPCHeader_RequestHeader* release_request_header();
  inline void set_allocated_request_header(::xtreemfs::pbrpc::RPCHeader_RequestHeader* request_header);

  // optional .xtreemfs.pbrpc.RPCHeader.ErrorResponse error_response = 4;
  inline bool has_error_response() const;
  inline void clear_error_response();
  static const int kErrorResponseFieldNumber = 4;
  inline const ::xtreemfs::pbrpc::RPCHeader_ErrorResponse& error_response() const;
  inline ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* mutable_error_response();
  inline ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* release_error_response();
  inline void set_allocated_error_response(::xtreemfs::pbrpc::RPCHeader_ErrorResponse* error_response);

  // @@protoc_insertion_point(class_scope:xtreemfs.pbrpc.RPCHeader)
 private:
  inline void set_has_call_id();
  inline void clear_has_call_id();
  inline void set_has_message_type();
  inline void clear_has_message_type();
  inline void set_has_request_header();
  inline void clear_has_request_header();
  inline void set_has_error_response();
  inline void clear_has_error_response();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 call_id_;
  int message_type_;
  ::xtreemfs::pbrpc::RPCHeader_RequestHeader* request_header_;
  ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* error_response_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_AssignDesc_pbrpc_2fRPC_2eproto();
  friend void protobuf_ShutdownFile_pbrpc_2fRPC_2eproto();

  void InitAsDefaultInstance();
  static RPCHeader* default_instance_;
};
// ===================================================================


// ===================================================================

// UserCredentials

// required string username = 1;
inline bool UserCredentials::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UserCredentials::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UserCredentials::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UserCredentials::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& UserCredentials::username() const {
  return *username_;
}
inline void UserCredentials::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserCredentials::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void UserCredentials::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserCredentials::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* UserCredentials::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UserCredentials::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated string groups = 2;
inline int UserCredentials::groups_size() const {
  return groups_.size();
}
inline void UserCredentials::clear_groups() {
  groups_.Clear();
}
inline const ::std::string& UserCredentials::groups(int index) const {
  return groups_.Get(index);
}
inline ::std::string* UserCredentials::mutable_groups(int index) {
  return groups_.Mutable(index);
}
inline void UserCredentials::set_groups(int index, const ::std::string& value) {
  groups_.Mutable(index)->assign(value);
}
inline void UserCredentials::set_groups(int index, const char* value) {
  groups_.Mutable(index)->assign(value);
}
inline void UserCredentials::set_groups(int index, const char* value, size_t size) {
  groups_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UserCredentials::add_groups() {
  return groups_.Add();
}
inline void UserCredentials::add_groups(const ::std::string& value) {
  groups_.Add()->assign(value);
}
inline void UserCredentials::add_groups(const char* value) {
  groups_.Add()->assign(value);
}
inline void UserCredentials::add_groups(const char* value, size_t size) {
  groups_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
UserCredentials::groups() const {
  return groups_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
UserCredentials::mutable_groups() {
  return &groups_;
}

// -------------------------------------------------------------------

// AuthPassword

// required string password = 1;
inline bool AuthPassword::has_password() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AuthPassword::set_has_password() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AuthPassword::clear_has_password() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AuthPassword::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& AuthPassword::password() const {
  return *password_;
}
inline void AuthPassword::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AuthPassword::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AuthPassword::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AuthPassword::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* AuthPassword::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AuthPassword::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Auth

// required .xtreemfs.pbrpc.AuthType auth_type = 1;
inline bool Auth::has_auth_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Auth::set_has_auth_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Auth::clear_has_auth_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Auth::clear_auth_type() {
  auth_type_ = 0;
  clear_has_auth_type();
}
inline ::xtreemfs::pbrpc::AuthType Auth::auth_type() const {
  return static_cast< ::xtreemfs::pbrpc::AuthType >(auth_type_);
}
inline void Auth::set_auth_type(::xtreemfs::pbrpc::AuthType value) {
  assert(::xtreemfs::pbrpc::AuthType_IsValid(value));
  set_has_auth_type();
  auth_type_ = value;
}

// optional .xtreemfs.pbrpc.AuthPassword auth_passwd = 3;
inline bool Auth::has_auth_passwd() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Auth::set_has_auth_passwd() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Auth::clear_has_auth_passwd() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Auth::clear_auth_passwd() {
  if (auth_passwd_ != NULL) auth_passwd_->::xtreemfs::pbrpc::AuthPassword::Clear();
  clear_has_auth_passwd();
}
inline const ::xtreemfs::pbrpc::AuthPassword& Auth::auth_passwd() const {
  return auth_passwd_ != NULL ? *auth_passwd_ : *default_instance_->auth_passwd_;
}
inline ::xtreemfs::pbrpc::AuthPassword* Auth::mutable_auth_passwd() {
  set_has_auth_passwd();
  if (auth_passwd_ == NULL) auth_passwd_ = new ::xtreemfs::pbrpc::AuthPassword;
  return auth_passwd_;
}
inline ::xtreemfs::pbrpc::AuthPassword* Auth::release_auth_passwd() {
  clear_has_auth_passwd();
  ::xtreemfs::pbrpc::AuthPassword* temp = auth_passwd_;
  auth_passwd_ = NULL;
  return temp;
}
inline void Auth::set_allocated_auth_passwd(::xtreemfs::pbrpc::AuthPassword* auth_passwd) {
  delete auth_passwd_;
  auth_passwd_ = auth_passwd;
  if (auth_passwd) {
    set_has_auth_passwd();
  } else {
    clear_has_auth_passwd();
  }
}

// optional bytes auth_data = 2;
inline bool Auth::has_auth_data() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Auth::set_has_auth_data() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Auth::clear_has_auth_data() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Auth::clear_auth_data() {
  if (auth_data_ != &::google::protobuf::internal::kEmptyString) {
    auth_data_->clear();
  }
  clear_has_auth_data();
}
inline const ::std::string& Auth::auth_data() const {
  return *auth_data_;
}
inline void Auth::set_auth_data(const ::std::string& value) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::kEmptyString) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(value);
}
inline void Auth::set_auth_data(const char* value) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::kEmptyString) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(value);
}
inline void Auth::set_auth_data(const void* value, size_t size) {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::kEmptyString) {
    auth_data_ = new ::std::string;
  }
  auth_data_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* Auth::mutable_auth_data() {
  set_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::kEmptyString) {
    auth_data_ = new ::std::string;
  }
  return auth_data_;
}
inline ::std::string* Auth::release_auth_data() {
  clear_has_auth_data();
  if (auth_data_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = auth_data_;
    auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void Auth::set_allocated_auth_data(::std::string* auth_data) {
  if (auth_data_ != &::google::protobuf::internal::kEmptyString) {
    delete auth_data_;
  }
  if (auth_data) {
    set_has_auth_data();
    auth_data_ = auth_data;
  } else {
    clear_has_auth_data();
    auth_data_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RPCHeader_RequestHeader

// required fixed32 interface_id = 1;
inline bool RPCHeader_RequestHeader::has_interface_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RPCHeader_RequestHeader::set_has_interface_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RPCHeader_RequestHeader::clear_has_interface_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RPCHeader_RequestHeader::clear_interface_id() {
  interface_id_ = 0u;
  clear_has_interface_id();
}
inline ::google::protobuf::uint32 RPCHeader_RequestHeader::interface_id() const {
  return interface_id_;
}
inline void RPCHeader_RequestHeader::set_interface_id(::google::protobuf::uint32 value) {
  set_has_interface_id();
  interface_id_ = value;
}

// required fixed32 proc_id = 2;
inline bool RPCHeader_RequestHeader::has_proc_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RPCHeader_RequestHeader::set_has_proc_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RPCHeader_RequestHeader::clear_has_proc_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RPCHeader_RequestHeader::clear_proc_id() {
  proc_id_ = 0u;
  clear_has_proc_id();
}
inline ::google::protobuf::uint32 RPCHeader_RequestHeader::proc_id() const {
  return proc_id_;
}
inline void RPCHeader_RequestHeader::set_proc_id(::google::protobuf::uint32 value) {
  set_has_proc_id();
  proc_id_ = value;
}

// required .xtreemfs.pbrpc.UserCredentials user_creds = 3;
inline bool RPCHeader_RequestHeader::has_user_creds() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RPCHeader_RequestHeader::set_has_user_creds() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RPCHeader_RequestHeader::clear_has_user_creds() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RPCHeader_RequestHeader::clear_user_creds() {
  if (user_creds_ != NULL) user_creds_->::xtreemfs::pbrpc::UserCredentials::Clear();
  clear_has_user_creds();
}
inline const ::xtreemfs::pbrpc::UserCredentials& RPCHeader_RequestHeader::user_creds() const {
  return user_creds_ != NULL ? *user_creds_ : *default_instance_->user_creds_;
}
inline ::xtreemfs::pbrpc::UserCredentials* RPCHeader_RequestHeader::mutable_user_creds() {
  set_has_user_creds();
  if (user_creds_ == NULL) user_creds_ = new ::xtreemfs::pbrpc::UserCredentials;
  return user_creds_;
}
inline ::xtreemfs::pbrpc::UserCredentials* RPCHeader_RequestHeader::release_user_creds() {
  clear_has_user_creds();
  ::xtreemfs::pbrpc::UserCredentials* temp = user_creds_;
  user_creds_ = NULL;
  return temp;
}
inline void RPCHeader_RequestHeader::set_allocated_user_creds(::xtreemfs::pbrpc::UserCredentials* user_creds) {
  delete user_creds_;
  user_creds_ = user_creds;
  if (user_creds) {
    set_has_user_creds();
  } else {
    clear_has_user_creds();
  }
}

// required .xtreemfs.pbrpc.Auth auth_data = 4;
inline bool RPCHeader_RequestHeader::has_auth_data() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RPCHeader_RequestHeader::set_has_auth_data() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RPCHeader_RequestHeader::clear_has_auth_data() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RPCHeader_RequestHeader::clear_auth_data() {
  if (auth_data_ != NULL) auth_data_->::xtreemfs::pbrpc::Auth::Clear();
  clear_has_auth_data();
}
inline const ::xtreemfs::pbrpc::Auth& RPCHeader_RequestHeader::auth_data() const {
  return auth_data_ != NULL ? *auth_data_ : *default_instance_->auth_data_;
}
inline ::xtreemfs::pbrpc::Auth* RPCHeader_RequestHeader::mutable_auth_data() {
  set_has_auth_data();
  if (auth_data_ == NULL) auth_data_ = new ::xtreemfs::pbrpc::Auth;
  return auth_data_;
}
inline ::xtreemfs::pbrpc::Auth* RPCHeader_RequestHeader::release_auth_data() {
  clear_has_auth_data();
  ::xtreemfs::pbrpc::Auth* temp = auth_data_;
  auth_data_ = NULL;
  return temp;
}
inline void RPCHeader_RequestHeader::set_allocated_auth_data(::xtreemfs::pbrpc::Auth* auth_data) {
  delete auth_data_;
  auth_data_ = auth_data;
  if (auth_data) {
    set_has_auth_data();
  } else {
    clear_has_auth_data();
  }
}

// -------------------------------------------------------------------

// RPCHeader_ErrorResponse

// required .xtreemfs.pbrpc.ErrorType error_type = 1;
inline bool RPCHeader_ErrorResponse::has_error_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RPCHeader_ErrorResponse::set_has_error_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RPCHeader_ErrorResponse::clear_has_error_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RPCHeader_ErrorResponse::clear_error_type() {
  error_type_ = 1;
  clear_has_error_type();
}
inline ::xtreemfs::pbrpc::ErrorType RPCHeader_ErrorResponse::error_type() const {
  return static_cast< ::xtreemfs::pbrpc::ErrorType >(error_type_);
}
inline void RPCHeader_ErrorResponse::set_error_type(::xtreemfs::pbrpc::ErrorType value) {
  assert(::xtreemfs::pbrpc::ErrorType_IsValid(value));
  set_has_error_type();
  error_type_ = value;
}

// optional .xtreemfs.pbrpc.POSIXErrno posix_errno = 2 [default = POSIX_ERROR_NONE];
inline bool RPCHeader_ErrorResponse::has_posix_errno() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RPCHeader_ErrorResponse::set_has_posix_errno() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RPCHeader_ErrorResponse::clear_has_posix_errno() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RPCHeader_ErrorResponse::clear_posix_errno() {
  posix_errno_ = 9999;
  clear_has_posix_errno();
}
inline ::xtreemfs::pbrpc::POSIXErrno RPCHeader_ErrorResponse::posix_errno() const {
  return static_cast< ::xtreemfs::pbrpc::POSIXErrno >(posix_errno_);
}
inline void RPCHeader_ErrorResponse::set_posix_errno(::xtreemfs::pbrpc::POSIXErrno value) {
  assert(::xtreemfs::pbrpc::POSIXErrno_IsValid(value));
  set_has_posix_errno();
  posix_errno_ = value;
}

// optional string error_message = 3;
inline bool RPCHeader_ErrorResponse::has_error_message() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RPCHeader_ErrorResponse::set_has_error_message() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RPCHeader_ErrorResponse::clear_has_error_message() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RPCHeader_ErrorResponse::clear_error_message() {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    error_message_->clear();
  }
  clear_has_error_message();
}
inline const ::std::string& RPCHeader_ErrorResponse::error_message() const {
  return *error_message_;
}
inline void RPCHeader_ErrorResponse::set_error_message(const ::std::string& value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_error_message(const char* value) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_error_message(const char* value, size_t size) {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  error_message_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCHeader_ErrorResponse::mutable_error_message() {
  set_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    error_message_ = new ::std::string;
  }
  return error_message_;
}
inline ::std::string* RPCHeader_ErrorResponse::release_error_message() {
  clear_has_error_message();
  if (error_message_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = error_message_;
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RPCHeader_ErrorResponse::set_allocated_error_message(::std::string* error_message) {
  if (error_message_ != &::google::protobuf::internal::kEmptyString) {
    delete error_message_;
  }
  if (error_message) {
    set_has_error_message();
    error_message_ = error_message;
  } else {
    clear_has_error_message();
    error_message_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string debug_info = 4;
inline bool RPCHeader_ErrorResponse::has_debug_info() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RPCHeader_ErrorResponse::set_has_debug_info() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RPCHeader_ErrorResponse::clear_has_debug_info() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RPCHeader_ErrorResponse::clear_debug_info() {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    debug_info_->clear();
  }
  clear_has_debug_info();
}
inline const ::std::string& RPCHeader_ErrorResponse::debug_info() const {
  return *debug_info_;
}
inline void RPCHeader_ErrorResponse::set_debug_info(const ::std::string& value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_debug_info(const char* value) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_debug_info(const char* value, size_t size) {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  debug_info_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCHeader_ErrorResponse::mutable_debug_info() {
  set_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    debug_info_ = new ::std::string;
  }
  return debug_info_;
}
inline ::std::string* RPCHeader_ErrorResponse::release_debug_info() {
  clear_has_debug_info();
  if (debug_info_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = debug_info_;
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RPCHeader_ErrorResponse::set_allocated_debug_info(::std::string* debug_info) {
  if (debug_info_ != &::google::protobuf::internal::kEmptyString) {
    delete debug_info_;
  }
  if (debug_info) {
    set_has_debug_info();
    debug_info_ = debug_info;
  } else {
    clear_has_debug_info();
    debug_info_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string redirect_to_server_uuid = 5;
inline bool RPCHeader_ErrorResponse::has_redirect_to_server_uuid() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RPCHeader_ErrorResponse::set_has_redirect_to_server_uuid() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RPCHeader_ErrorResponse::clear_has_redirect_to_server_uuid() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RPCHeader_ErrorResponse::clear_redirect_to_server_uuid() {
  if (redirect_to_server_uuid_ != &::google::protobuf::internal::kEmptyString) {
    redirect_to_server_uuid_->clear();
  }
  clear_has_redirect_to_server_uuid();
}
inline const ::std::string& RPCHeader_ErrorResponse::redirect_to_server_uuid() const {
  return *redirect_to_server_uuid_;
}
inline void RPCHeader_ErrorResponse::set_redirect_to_server_uuid(const ::std::string& value) {
  set_has_redirect_to_server_uuid();
  if (redirect_to_server_uuid_ == &::google::protobuf::internal::kEmptyString) {
    redirect_to_server_uuid_ = new ::std::string;
  }
  redirect_to_server_uuid_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_redirect_to_server_uuid(const char* value) {
  set_has_redirect_to_server_uuid();
  if (redirect_to_server_uuid_ == &::google::protobuf::internal::kEmptyString) {
    redirect_to_server_uuid_ = new ::std::string;
  }
  redirect_to_server_uuid_->assign(value);
}
inline void RPCHeader_ErrorResponse::set_redirect_to_server_uuid(const char* value, size_t size) {
  set_has_redirect_to_server_uuid();
  if (redirect_to_server_uuid_ == &::google::protobuf::internal::kEmptyString) {
    redirect_to_server_uuid_ = new ::std::string;
  }
  redirect_to_server_uuid_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RPCHeader_ErrorResponse::mutable_redirect_to_server_uuid() {
  set_has_redirect_to_server_uuid();
  if (redirect_to_server_uuid_ == &::google::protobuf::internal::kEmptyString) {
    redirect_to_server_uuid_ = new ::std::string;
  }
  return redirect_to_server_uuid_;
}
inline ::std::string* RPCHeader_ErrorResponse::release_redirect_to_server_uuid() {
  clear_has_redirect_to_server_uuid();
  if (redirect_to_server_uuid_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = redirect_to_server_uuid_;
    redirect_to_server_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RPCHeader_ErrorResponse::set_allocated_redirect_to_server_uuid(::std::string* redirect_to_server_uuid) {
  if (redirect_to_server_uuid_ != &::google::protobuf::internal::kEmptyString) {
    delete redirect_to_server_uuid_;
  }
  if (redirect_to_server_uuid) {
    set_has_redirect_to_server_uuid();
    redirect_to_server_uuid_ = redirect_to_server_uuid;
  } else {
    clear_has_redirect_to_server_uuid();
    redirect_to_server_uuid_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RPCHeader

// required fixed32 call_id = 1;
inline bool RPCHeader::has_call_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RPCHeader::set_has_call_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RPCHeader::clear_has_call_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RPCHeader::clear_call_id() {
  call_id_ = 0u;
  clear_has_call_id();
}
inline ::google::protobuf::uint32 RPCHeader::call_id() const {
  return call_id_;
}
inline void RPCHeader::set_call_id(::google::protobuf::uint32 value) {
  set_has_call_id();
  call_id_ = value;
}

// required .xtreemfs.pbrpc.MessageType message_type = 2;
inline bool RPCHeader::has_message_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RPCHeader::set_has_message_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RPCHeader::clear_has_message_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RPCHeader::clear_message_type() {
  message_type_ = 0;
  clear_has_message_type();
}
inline ::xtreemfs::pbrpc::MessageType RPCHeader::message_type() const {
  return static_cast< ::xtreemfs::pbrpc::MessageType >(message_type_);
}
inline void RPCHeader::set_message_type(::xtreemfs::pbrpc::MessageType value) {
  assert(::xtreemfs::pbrpc::MessageType_IsValid(value));
  set_has_message_type();
  message_type_ = value;
}

// optional .xtreemfs.pbrpc.RPCHeader.RequestHeader request_header = 3;
inline bool RPCHeader::has_request_header() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RPCHeader::set_has_request_header() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RPCHeader::clear_has_request_header() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RPCHeader::clear_request_header() {
  if (request_header_ != NULL) request_header_->::xtreemfs::pbrpc::RPCHeader_RequestHeader::Clear();
  clear_has_request_header();
}
inline const ::xtreemfs::pbrpc::RPCHeader_RequestHeader& RPCHeader::request_header() const {
  return request_header_ != NULL ? *request_header_ : *default_instance_->request_header_;
}
inline ::xtreemfs::pbrpc::RPCHeader_RequestHeader* RPCHeader::mutable_request_header() {
  set_has_request_header();
  if (request_header_ == NULL) request_header_ = new ::xtreemfs::pbrpc::RPCHeader_RequestHeader;
  return request_header_;
}
inline ::xtreemfs::pbrpc::RPCHeader_RequestHeader* RPCHeader::release_request_header() {
  clear_has_request_header();
  ::xtreemfs::pbrpc::RPCHeader_RequestHeader* temp = request_header_;
  request_header_ = NULL;
  return temp;
}
inline void RPCHeader::set_allocated_request_header(::xtreemfs::pbrpc::RPCHeader_RequestHeader* request_header) {
  delete request_header_;
  request_header_ = request_header;
  if (request_header) {
    set_has_request_header();
  } else {
    clear_has_request_header();
  }
}

// optional .xtreemfs.pbrpc.RPCHeader.ErrorResponse error_response = 4;
inline bool RPCHeader::has_error_response() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RPCHeader::set_has_error_response() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RPCHeader::clear_has_error_response() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RPCHeader::clear_error_response() {
  if (error_response_ != NULL) error_response_->::xtreemfs::pbrpc::RPCHeader_ErrorResponse::Clear();
  clear_has_error_response();
}
inline const ::xtreemfs::pbrpc::RPCHeader_ErrorResponse& RPCHeader::error_response() const {
  return error_response_ != NULL ? *error_response_ : *default_instance_->error_response_;
}
inline ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* RPCHeader::mutable_error_response() {
  set_has_error_response();
  if (error_response_ == NULL) error_response_ = new ::xtreemfs::pbrpc::RPCHeader_ErrorResponse;
  return error_response_;
}
inline ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* RPCHeader::release_error_response() {
  clear_has_error_response();
  ::xtreemfs::pbrpc::RPCHeader_ErrorResponse* temp = error_response_;
  error_response_ = NULL;
  return temp;
}
inline void RPCHeader::set_allocated_error_response(::xtreemfs::pbrpc::RPCHeader_ErrorResponse* error_response) {
  delete error_response_;
  error_response_ = error_response;
  if (error_response) {
    set_has_error_response();
  } else {
    clear_has_error_response();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace pbrpc
}  // namespace xtreemfs

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::MessageType>() {
  return ::xtreemfs::pbrpc::MessageType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::AuthType>() {
  return ::xtreemfs::pbrpc::AuthType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::ErrorType>() {
  return ::xtreemfs::pbrpc::ErrorType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::xtreemfs::pbrpc::POSIXErrno>() {
  return ::xtreemfs::pbrpc::POSIXErrno_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_pbrpc_2fRPC_2eproto__INCLUDED
